--[[============================================================
--=
--=  GuiLove v0.2 beta for LÖVE 0.10.2+
--=  - Written by Marcus 'ReFreezed' Thunström
--=  - MIT License (See the bottom of this file)
--=
--=  This file is generated from the source at:
--=  https://github.com/ReFreezed/GuiLove
--=
--==============================================================



	Basic usage
	----------------------------------------------------------------

	function love.load()
		local Gui = require("Gui")
		gui       = Gui()

		local tree = {"root",
			{"vbar", id="myContainer", width=200,
				{"text", text="I'm just a text."},
				{"input", value="foo bar"},
				{"button", id="myButton", text="Press Me!"},
			},
		}
		gui:load(tree)

		local myButton   = gui:find("myButton")
		local pressCount = 0

		myButton:on("press", function(myButton, event)
			pressCount = pressCount + 1

			local myContainer = gui:find("myContainer")
			local text        = "Pressed button " .. pressCount .. " " .. (pressCount == 1 and "time" or "times") .. "!"
			myContainer:insert{ "text", text=text }
		end)

		gui:getRoot():setDimensions(love.graphics.getDimensions())
	end

	function love.keypressed(key, scancode, isRepeat)
		gui:keypressed(key, scancode, isRepeat)
	end
	function love.keyreleased(key, scancode)
		gui:keyreleased(key, scancode)
	end
	function love.textinput(text)
		gui:textinput(text)
	end

	function love.mousepressed(mx, my, mbutton, isTouch, pressCount)
		gui:mousepressed(mx, my, mbutton, pressCount)
	end
	function love.mousemoved(mx, my, dx, dy, isTouch)
		gui:mousemoved(mx, my)
	end
	function love.mousereleased(mx, my, mbutton, isTouch, pressCount)
		gui:mousereleased(mx, my, mbutton, pressCount)
	end
	function love.wheelmoved(dx, dy)
		gui:wheelmoved(dx, dy)
	end

	function love.update(dt)
		gui:update(dt)
	end

	function love.draw()
		gui:draw()
	end



	Gui methods
	----------------------------------------------------------------

	update
	draw

	keypressed, keyreleased, textinput
	mousepressed, mousemoved, mousereleased, wheelmoved

	areStandardKeysActive, setStandardKeysActive
	blur
	defineStyle
	find, findAll, findActive, findToggled, match, matchAll
	getDefaultSound, setDefaultSound
	getElementAt
	getFont, setFont, getBoldFont, setBoldFont, getSmallFont, setSmallFont, getLargeFont, setLargeFont, getTooltipFont, setTooltipFont
	getHoveredElement
	getNavigationTarget, navigateTo, navigateToNext, navigateToPrevious, navigateToFirst, navigate, canNavigateTo
	getRoot
	getScissorCoordsConverter, setScissorCoordsConverter
	getScrollSpeed, setScrollSpeed
	getSoundPlayer, setSoundPlayer
	getSpriteLoader, setSpriteLoader
	getTarget, getTargetCallback, setTargetCallback
	getTextPreprocessor, setTextPreprocessor, reprocessTexts
	getTheme, setTheme
	getTime, getTimeSinceNavigation
	isBusy, isKeyboardBusy, isMouseBusy
	isIgnoringKeyboardInput
	isInputCaptured
	isInteractionLocked
	isMouseGrabbed, setMouseIsGrabbed
	load
	ok, back
	updateLayout



	Element types, methods and events
	----------------------------------------------------------------

	(element)
	- animate
	- close, canClose
	- exists
	- getAnchor, setAnchor, getAnchorX, setAnchorX, getAnchorY, setAnchorY
	- getCallback, setCallback, on, off, trigger, triggerBubbling
	- getClosest
	- getClosestInDirection, getNext, getPrevious
	- getData, setData, swapData
	- getDimensions, setDimensions, getWidth, setWidth, getHeight, setHeight
	- getGui
	- getGuiTime
	- getId, hasId
	- getIndex, getDepth
	- getLayout
	- getLayoutDimensions, getLayoutWidth, getLayoutHeight
	- getLayoutPosition, getLayoutX, getLayoutY, getLayoutCenterPosition
	- getMinDimensions, setMinDimensions, getMinWidth, setMinWidth, getMinHeight, setMinHeight
	- getMouseCursor, getResultingMouseCursor, setMouseCursor
	- getMousePosition, getMouseX, getMouseY
	- getOrigin, setOrigin, getOriginX, setOriginX, getOriginY, setOriginY
	- getParent, getAllParents, hasParent, getParentWithId, hasParentWithId, parents, parentsr, lineageUp
	- getPathDescription
	- getPosition, setPosition, getX, setX, getY, setY
	- getPositionOnScreen, getXOnScreen, getYOnScreen
	- getRoot, getNavigationRoot
	- getSibling
	- getSound, getResultingSound, setSound
	- getStyle
	- getTimeSinceBecomingVisible
	- getTooltip, setTooltip, drawTooltip
	- getTooltipFont, useTooltipFont
	- hasTag, addTag, removeTag, removeAllTags, setTag
	- isAt
	- isDisplayed, getClosestHiddenElement, getFarthestHiddenElement
	- isFirst, isLast
	- isHidden, isVisible, setHidden, setVisible, show, hide, toggleHidden
	- isHovered
	- isMouseFocus, isKeyboardFocus
	- isNavigationTarget
	- isScrollbarXHovered, isScrollbarYHovered, isScrollbarXHandleHovered, isScrollbarYHandleHovered
	- isScrollingX, isScrollingY
	- isSolid
	- isType
	- playSound
	- refresh
	- remove
	- reprocessTexts
	- scrollIntoView
	- setScissor, unsetScissor
	- showMenu
	- updateLayout
	- Event: beforedraw, afterdraw
	- Event: close, closed
	- Event: focused, blurred
	- Event: init
	- Event: keypressed
	- Event: layout
	- Event: mousepressed, mousemoved, mousereleased
	- Event: navigated
	- Event: pressed
	- Event: refresh
	- Event: show, hide
	- Event: textinput
	- Event: update
	- Event: wheelmoved

	container
	- find, findAll, findType, findActive, findToggled, match, matchAll
	- get, children
	- getChildAreaDimensions, getChildAreaWidth, getChildAreaHeight
	- getChildWithData
	- getElementAt
	- getInnerSpace, getInnerSpaceX, getInnerSpaceY
	- getMaxDimensions, setMaxDimensions, getMaxWidth, setMaxWidth, getMaxHeight, setMaxHeight
	- getPadding, setPadding
	- getScroll, getScrollX, getScrollY, setScroll, setScrollX, setScrollY, scroll, updateScroll
	- getScrollHandleX, getScrollHandleY
	- getScrollLimit, getScrollLimitX, getScrollLimitY
	- getToggledChild, setToggledChild
	- getVisibleChild, getVisibleChildNumber, getVisibleChildCount, setVisibleChild
	- getVisualScroll, getVisualScrollX, getVisualScrollY
	- hasAnyScrollbar, hasScrollbarOnRight, hasScrollbarOnBottom
	- indexOf
	- insert, removeAt, empty
	- setChildrenActive
	- setChildrenHidden
	- sort
	- traverse, traverseType, traverseVisible

		(bar)

			hbar

			vbar

		root
		- setDimensions

	(leaf)
	- getAlign, setAlign
	- getFont, useFont
	- getMnemonicOffset
	- getText, getUnprocessedText, setText, drawText, drawAlignedText
	- getTextColor, setTextColor, hasTextColor, useTextColor
	- isBold, setBold
	- isLarge, setLarge
	- isSmall, setSmall

		canvas
		- getCanvasBackgroundColor, setCanvasBackgroundColor
		- Event: draw

		image
		- Includes: imageInclude

		text

		(widget)
		- getPriority, setPriority
		- isActive, setActive
		- Event: navigate
		- Event: navupdate

			button
			- Includes: imageInclude
			- getArrow
			- getText2, getUnprocessedText2, setText2, drawText2, drawAlignedText2
			- isPressable, setPressable
			- isToggled, setToggled
			- press, isPressed
			- Event: press
			- Event: toggle

			input
			- focus, blur, isFocused
			- getBlinkPhase
			- getField
			- getSelectionOffset, getCursorOffset
			- getValue, setValue, getVisibleValue, drawValue, drawPlaceholder
			- isPasswordActive, setPasswordActive
			- Event: change
			- Event: submit
			- Event: valuechange



	Includes
	----------------------------------------------------------------

	imageInclude
	- drawImage
	- getImageBackgroundColor, setImageBackgroundColor, hasImageBackgroundColor, useImageBackgroundColor
	- getImageColor, setImageColor, hasImageColor, useImageColor
	- getImageDimensions, setImageSize, maximizeImageSize
	- getImageScale, getImageScaleX, getImageScaleY, setImageScale, setImageScaleX, setImageScaleY
	- getSprite, setSprite, hasSprite



	Tools
	----------------------------------------------------------------

	create9PartQuads
	draw9PartScaled
	newMonochromeImage, newImageUsingPalette
	parseTargetAndEvent



--============================================================]]



!local LG = `love.graphics`
!local LM = `love.mouse`

!local TAU               = 2*math.pi
!local UTF8_CHAR_PATTERN = "[%z\1-\127\194-\244][\128-\191]*" -- utf8.charpattern
!local MOUSE_POS_UNKNOWN = -999999



local setColor = $LG.setColor

if love.getVersion() < 11 then
	local _setColor = setColor
	function setColor(r, g, b, a)
		_setColor(r*255, g*255, b*255, (a and a*255))
	end
end

local class      = (function()  @insert "src/class.lua"       end)()
local InputField = (function()  @insert "src/InputField.lua"  end)()



local COLOR_TRANSPARENT = {1,1,1,0}
local COLOR_WHITE       = {1,1,1,1}

local _M = { -- The module.
	_VERSION = "0.2.0",
}

local Gui = class("Gui", {
	TOOLTIP_DELAY = 0.15,

	VALUE_MASK_INT    =  "^%-?%d+$",       -- Integer number.
	VALUE_MASK_UINT   =  "^%d+$",          -- Unsigned integer number.
	VALUE_MASK_FLOAT  =  "^%-?%d+%.?%d*$", -- Floating point number.
	VALUE_MASK_UFLOAT =  "^%d+%.?%d*$",    -- Unsigned floating point number.

	_allAnimations      = nil,
	_animationLockCount = 0,

	_font        = nil,
	_fontBold    = nil,
	_fontSmall   = nil,
	_fontLarge   = nil,
	_fontTooltip = nil,

	_defaultSounds = nil,
	_soundPlayer   = nil,

	_scissorCoordsConverter = nil,
	_elementScissorIsSet    = false,

	_mouseX                 = !(MOUSE_POS_UNKNOWN),
	_mouseY                 = !(MOUSE_POS_UNKNOWN),
	_mouseFocus             = nil,
	_mouseFocusButtonStates = nil,
	_mouseIsGrabbed         = false,
	_currentMouseCursor     = nil,

	_keyboardFocus                = nil,
	_ignoreKeyboardInputThisFrame = false,
	_standardKeysAreActive        = true,

	_navigationTarget    = nil,
	_timeSinceNavigation = 0.0,
	_lockNavigation      = false,

	_scrollSpeedX = 1.0,
	_scrollSpeedY = 1.0,

	_time        = 0.0,
	_tooltipTime = 0.0,

	_theme  = nil,
	_styles = nil,

	_root           = nil,
	_hoveredElement = nil,

	_lastAutomaticId = 0,

	_layoutNeedsUpdate = false,

	_textPreprocessor = nil,
	_spriteLoader     = nil,

	_heres = nil,

	debug = false,
})

local Cs = {} -- gui element Classes.
local Is = {} -- gui element Includes.

local validSoundKeys = {
	-- Generic
	["close"]  = true, -- Usually containers, but any element can be a closable.
	["focus"]  = true, -- Only used by Inputs so far.
	["press"]  = true, -- Buttons.
	["scroll"] = true, -- Containers.

	-- Element specific
	["inputsubmit"] = true, ["inputrevert"] = true,
}

local defaultTheme



--==============================================================
--= Local functions ============================================
--==============================================================

local F = string.format



-- printf( formatString, ... )
local function printf(s, ...)
	print(F(s, ...))
end

-- printerr( depth, formatString, ... )
local function printerr(depth, s, ...)
	local time    = require"socket".gettime()
	local timeStr = os.date("%H:%M:%S", time)
	local msStr   = F("%.3f", time%1):sub(2)
	io.stderr:write(debug.traceback(F("[%s%s] ERROR: "..s, timeStr, msStr, ...), 1+depth), "\n")
end



-- errorf( [ level=1, ] formatString, ... )
local function errorf(i, s, ...)
	if type(i) == "number" then
		error(F(s, ...), 1+i)
	else
		error(F(i, s, ...), 2)
	end
end

local function argerror(errLevel, argN, argName, v, ...)
	errorf(
		1+errLevel,
		"Bad argument #%d (%s) to '%s'. (Expected %s, got %s)",
		argN,
		argName,
		debug.getinfo(errLevel, "n").name or "?",
		table.concat({...}, " or "),
		type(v)
	)
end

!(
local function ARGS(levelAndArgs)
	local errLevel, argsStr = levelAndArgs:match"^(%d+) (%S.*)$"
	errLevel                = tonumber(errLevel) or error("Bad levelAndArgs format: "..levelAndArgs, 2)

	local lineSep = "\n" .. ("\t"):rep(#getOutputSoFarOnLine())

	local optionalPos = argsStr:find("?", 1, true) or #argsStr
	local argN        = 1
	local argsWritten = 0

	for pos, argNames, types in argsStr:gmatch"()([%w_,]+):([%w_,*]+)" do
		if types == "*" then
			argN = argN + #argNames:gsub("[^,]+", "") + 1

		else
			if pos > optionalPos then  types = types..",nil"  end

			for argName in argNames:gmatch"[%w_]+" do
				local conditions
				if types:find(",", 1, true) then
					conditions = {}
					for typeName in types:gmatch"[%w_]+" do
						table.insert(conditions, string.format("type(%s)==%q", argName, typeName))
					end
					conditions = string.format("not(%s)", table.concat(conditions, " or "))
				else
					conditions = string.format("type(%s)~=%q", argName, types)
				end

				conditions = conditions:gsub('type%(([%w_]+)%)([~=]=)"nil"', "%1%2nil")

				__LUA(string.format(
					"%sif %s then argerror(%d,%d,%q,%s,%s) end",
					(argsWritten == 0) and "" or lineSep,
					conditions,
					errLevel,
					argN,
					argName,
					argName,
					types:gsub("[%w_]+", '"%0"'),
				nil))

				argN        = argN        + 1
				argsWritten = argsWritten + 1
			end
		end
	end
end
)



-- class = newElementClass( className, parentClass|nil, includes, classTable, events )
local function newElementClass(className, parentClass, includes, classTable, events)
	local C = parentClass and parentClass:extend(className, classTable) or class(className, classTable)

	-- Include includes.
	for _, includeName in ipairs(includes) do
		for k, v in pairs(Is[includeName]) do
			@@ASSERT(C[k] == nil, k) -- An include should only add new stuff to classes, not override anything.
			C[k] = v
		end
	end

	-- Register events.
	for i, event in ipairs(C._events) do
		table.insert(events, i, event)
	end
	for i, event in ipairs(events) do
		events[event] = true
	end
	C._events = events

	return C
end



local function applyStyle(elData, styleData)
	for i, childStyleData in ipairs(styleData) do
		if elData[i] == nil then
			error("Cannot apply style. (Missing children.)")
		end
		applyStyle(elData[i], childStyleData)
	end
	for k, v in pairs(styleData) do
		if elData[k] == nil then  elData[k] = v  end
	end
end



local function checkValidSoundKey(soundK, errLevel)
	if soundK == nil or validSoundKeys[soundK] then  return  end

	local keys = {}
	for soundK in pairs(validSoundKeys) do
		table.insert(keys, soundK)
	end
	table.sort(keys)

	errorf(1+errLevel, "Bad sound key '%s'. (Must be any of '%s'.)", soundK, table.concat(keys, "', '"))
end



-- @Memory: Don't use this, yo!
-- iterator, coroutine = newIteratorCoroutine( callback, argument1, ... )
local newIteratorCoroutine
do
	-- ... = coroutineIterator( coroutine )
	local function coroutineIterator(co)
		return select(2, assert(coroutine.resume(co)))
	end
	local function initiator(cb, ...)
		coroutine.yield()
		return cb(...)
	end
	function newIteratorCoroutine(cb, ...)
		local co = coroutine.create(initiator)
		coroutine.resume(co, cb, ...)
		return coroutineIterator, co
	end
end



-- x, y, width, height = xywh( element )
local function xywh(el)
	return el:getXOnScreen(), el:getYOnScreen(), el._layoutWidth, el._layoutHeight
end



-- drawImage( image, quad, ... )
-- drawImage( image, nil, ... )
-- drawImage( nil, image, ... )
local function drawImage(image, quadOrImage, ...)
	if image and quadOrImage then
		$LG.draw(image, quadOrImage, ...)
	else
		$LG.draw((image or quadOrImage), ...)
	end
end



-- width, height = getTextDimensions( font, text, wrapLimit )
local function getTextDimensions(font, text, wrapLimit)
	local w, lines = font:getWrap(text, wrapLimit)
	local h        = font:getHeight()
	return w, h + math.floor(h*font:getLineHeight()) * (math.max(#lines, 1)-1)
end



-- elementType = getTypeFromElementData( elementData )
local function getTypeFromElementData(elData)
	if not elData.type and type(elData[1]) == "string" then
		elData.type = table.remove(elData, 1)
	end
	return elData.type
end



-- index = indexOf( array, value )
-- index = indexOf( container, element )
local function indexOf(arr, v)
	for i, item in ipairs(arr) do
		if item == v then  return i  end
	end
	return nil
end



-- for index, item in ipairsr( table )
local ipairsr
do
	local function iprev(arr, i)
		i       = i - 1
		local v = arr[i]
		if v ~= nil then  return i, v  end
	end
	function ipairsr(arr)
		return iprev, arr, #arr+1
	end
end



-- value = lerp( v1, v2, t )
local function lerp(v1, v2, t)
	return v1+t*(v2-v1)
end



-- matches = matchAll( string, pattern )
local function matchAll(s, pat)
	local matches, i = {}, 0
	for match in s:gmatch(pat) do
		i = i+1
		matches[i] = match
	end
	return matches
end



-- sprite = newSprite( image [, quad ] )
-- sprite = newSprite( image, frames )
-- frames = { frame1, ... }
-- frame  = { duration=duration, quad=quad }
local function newSprite(image, framesOrQuad)
	!ARGS"1 image:userdata framesOrQuad:userdata,table,nil" -- @Incomplete: Better errLevel.
	local frames

	if not framesOrQuad then
		local iw, ih = image:getDimensions()
		frames = {{duration=1/0, quad=$LG.newQuad(0, 0, iw, ih, iw, ih)}}

	elseif type(framesOrQuad) == "userdata" then
		frames = {{duration=1/0, quad=framesOrQuad}}

	else
		frames = framesOrQuad
		if not frames[1] then
			error("The frames table is empty. We need at least one frame!", 2)
		end
		for i, frame in ipairs(frames) do
			if not frame.duration then  errorf(2, "Frame %d is missing a duration.", i)  end
			if not frame.quad     then  errorf(2, "Frame %d is missing a quad."    , i)  end
		end
	end

	local duration = 0
	for _, frame in ipairs(frames) do
		duration = duration + frame.duration
	end

	local _, _, iw, ih = frames[1].quad:getViewport()

	local sprite = {
		image        = image,

		frames       = frames,

		width        = iw,
		height       = ih,

		length       = #frames,
		duration     = duration,

		currentFrame = 1,
		currentTime  = 0.0,
	}

	return sprite
end

-- -- clone = cloneSprite( sprite )
-- local function cloneSprite(sprite)
-- 	return (newSprite(sprite.image, sprite.frames))
-- end

-- image, quad, width, height = getCurrentViewOfSprite( sprite )
local function getCurrentViewOfSprite(sprite)
	local quad = sprite.frames[sprite.currentFrame].quad
	local _, _, w, h = quad:getViewport()
	return sprite.image, quad, w, h
end

-- updateSprite( sprite, deltaTime )
local function updateSprite(sprite, dt)
	if sprite.length == 1 then  return  end

	local frames = sprite.frames

	local i      = sprite.currentFrame
	local time   = sprite.currentTime + dt

	while time >= frames[i].duration do
		time = time - frames[i].duration
		i    = i % sprite.length + 1
	end

	sprite.currentFrame = i
	sprite.currentTime  = time
end



-- selectorPath = parseSelector( selector )
-- selector     = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Returns nil if the selector is empty or invalid.
local parseSelector
do
	local selPathCache = {}

	function parseSelector(selector)
		local selPath = selPathCache[selector]
		if selPath then
			return selPath
		end

		selPath = {}

		for section in selector:gmatch"[^ ]+" do
			local selPathSection = {}
			local i = 1
			while true do

				local c = section:sub(i, i)
				if c == "" then
					break
				end

				local selPathSegment

				-- ID
				if c == "#" then
					local id
					id, i = section:match("^([^#.]+)()", i+1)
					if not id then
						printerr(1, "Bad format in selector at '%s'.", section:sub(i))
						return nil
					end
					selPathSegment = {type="id", value=id}

				-- Tag
				elseif c == "." then
					local tag
					tag, i = section:match("^([^#.]+)()", i+1)
					if not tag then
						printerr(1, "Bad format in selector at '%s'.", section:sub(i))
						return nil
					end
					selPathSegment = {type="tag", value=tag}

				-- Element type
				else
					local elType
					elType, i = section:match("^([^#.]+)()", i)
					if not elType then
						printerr(1, "Bad format in selector at '%s'.", section:sub(i))
						return nil
					elseif not Cs[elType] then
						printerr(1, "Unknown element type '%s' in selector.", elType)
						return nil
					end
					selPathSegment = {type="type", value=elType}

				end
				table.insert(selPathSection, selPathSegment)
			end
			table.insert(selPath, selPathSection)
		end

		if not selPath[1] then
			return nil -- The selector was either empty or filled with just spaces.
		end

		selPathCache[selector] = selPath

		return selPath
	end
end

-- result = isElementMatchingSelectorPath( element, selectorPath [, breakElement ] )
-- The path match checking loop breaks before reaching 'breakElement'.
local isElementMatchingSelectorPath
do
	local function isMatchingSection(el, selPathSection)
		for _, selPathSegment in ipairs(selPathSection) do

			-- ID
			if selPathSegment.type == "id" then
				if not el:hasId(selPathSegment.value) then
					return false
				end

			-- Tag
			elseif selPathSegment.type == "tag" then
				if not el:hasTag(selPathSegment.value) then
					return false
				end

			-- Element type
			else--if selPathSegment.type == "type" then
				if not el:isType(selPathSegment.value) then
					return false
				end

			end
		end
		return true
	end

	function isElementMatchingSelectorPath(el, selPath, breakElement)
		local i = #selPath

		local selPathSection = selPath[i]
		if not selPathSection then
			return false -- An empty path means nothing can match!
		end

		if el == breakElement then
			return false -- We got to the break point before matching the whole path.
		end
		if isMatchingSection(el, selPathSection) then
			i = i-1
			selPathSection = selPath[i]
			if not selPathSection then
				return true -- The whole path (with only one section) matched.
			end
		else
			return false -- The last section must match the specified element, but didn't.
		end

		for _, parent in el:parents() do
			if parent == breakElement then
				return false -- We got to the break point before matching the whole path.
			end
			if isMatchingSection(parent, selPathSection) then
				i = i-1
				selPathSection = selPath[i]
				if not selPathSection then
					return true -- The whole path matched.
				end
			end
		end

		return false -- We went through all parents without matching the whole path.
	end
end



-- Prepare a sound for being played (Useful if it's possible the element will be removed in an event)
-- playSound:function = prepareSound( element, soundKey )
local function prepareSound(el, soundK)
	local gui = el._gui
	local soundPlayer = (gui and gui._soundPlayer)
	local sound = (soundPlayer and el:getResultingSound(soundK))
	return function()
		if sound ~= nil then
			soundPlayer(sound)
		end
	end
end



-- text = preprocessText( gui, text, el, hasMnemonics )
local function preprocessText(gui, unprocessedText, el, hasMnemonics)
	if unprocessedText == "" then  return ""  end

	local preprocessor = gui._textPreprocessor
	if not preprocessor then  return unprocessedText  end

	local text = preprocessor(unprocessedText, el, hasMnemonics)
	if text == nil then  return unprocessedText  end

	return tostring(text)
end



local function printHere(el0)
	local ids = {}
	local el  = el0

	repeat
		if not el._automaticId then  table.insert(ids, 1, el._id)  end
		el = el._parent
	until not el

	ids[1] = ids[1] or el0:getPathDescription()
	print("[Gui] HERE:  "..table.concat(ids, "."))
	-- ids[1] = ids[1] or "~"
	-- printf("[Gui] HERE:  %s  (%s)", table.concat(ids, "."), el0:getPathDescription())
end

local function printHeres(gui)
	local heres = gui._heres
	for i, el in ipairs(heres) do
		printHere(el)
		heres[i] = nil
	end
end



-- class = requireElementClass( elType )
local function requireElementClass(elType)
	return Cs[elType] or errorf(2, "Unknown element type '%s'.", elType)
end



-- retrieve( element, elementData, property1, ... ) -- @Cleanup: Remove function.
local function retrieve(el, elData, _k, ...)
	local v = elData[_k:sub(2)]
	if v ~= nil then
		el[_k] = v
	end
	if ... then
		return retrieve(el, elData, ...)
	end
end



local function reverseArray(arr)
	local lenPlusOne = #arr + 1

	for i1 = 1, #arr/2 do
		local i2         = lenPlusOne - i1
		arr[i1], arr[i2] = arr[i2], arr[i1]
	end
end



-- integer = round( number )
local function round(n)
	return math.floor(n+0.5)
end



local function setMouseFocus(gui, mbutton, el)
	if gui._mouseFocus and el ~= gui._mouseFocus then
		printerr(1, "Changing mouse focus without blurring the old focus first.")
		gui._mouseFocusButtonStates[1] = false
		gui._mouseFocusButtonStates[2] = false
		gui._mouseFocusButtonStates[3] = false
	end

	gui._mouseFocus                      = el
	gui._mouseFocusButtonStates[mbutton] = true
	$LM.setGrabbed(true)
end

-- blurMouseFocus( gui, mbutton=all )
local function blurMouseFocus(gui, mbutton)
	if mbutton then
		gui._mouseFocusButtonStates[mbutton] = false
	else
		gui._mouseFocusButtonStates[1] = false
		gui._mouseFocusButtonStates[2] = false
		gui._mouseFocusButtonStates[3] = false
	end

	if not (gui._mouseFocusButtonStates[1] or gui._mouseFocusButtonStates[2] or gui._mouseFocusButtonStates[3]) then
		gui._mouseFocus = nil
		$LM.setGrabbed(gui._mouseIsGrabbed)
	end
end



local function setKeyboardFocus(gui, el)
	gui._keyboardFocus = el
end

local function blurKeyboardFocus(gui)
	gui._keyboardFocus = nil
end



-- setScissor( gui, x, y, width, height ) -- Push scissor.
-- setScissor( gui, nil ) -- Pop scissor.
-- Must be called twice - first with arguments, then without!
local function setScissor(gui, x, y, w, h)
	if not x then
		$LG.pop()
		return
	end

	local convert = gui._scissorCoordsConverter
	if convert then
		x, y, w, h = convert(x, y, w, h)
	end

	$LG.push("all")
	$LG.intersectScissor(x, y, math.max(w, 0), math.max(h, 0))
end

-- Note: Does not push or pop state like setScissor()!
local function intersectScissor(gui, x, y, w, h)
	local convert = gui._scissorCoordsConverter
	if convert then
		x, y, w, h = convert(x, y, w, h)
	end
	$LG.intersectScissor(x, y, w, h)
end



-- value1, ... = themeCallBack( gui, sectionKey, what, argument1, ... )
local function themeCallBack(gui, k, what, ...)
	local section = gui._theme and gui._theme[k]
	local cb      = (section and section[what] or defaultTheme[k][what]) or errorf(2, "Missing default theme callback for '%s.%s'.", k, what)
	return cb(...)
end

-- value = themeGet( gui, key )
local function themeGet(gui, k)
	local v = gui._theme and gui._theme[k]
	if v == nil then
		return defaultTheme[k]
	end
	return v
end

-- themeRenderOnScreen( element, what, x, y, w, h, extraArgument1, ... )
local function themeRenderOnScreen(el, what, x, y, w, h, ...)
	local gui = el._gui
	if x+w < 0 or y+h < 0 then  return  end

	local rootW, rootH = gui._root:getDimensions()
	if x >= rootW or y >= rootH then  return  end

	$LG.push("all")
	$LG.translate(x, y)

	themeCallBack(gui, "draw", what, el, w, h, ...)
	el:unsetScissor()

	$LG.pop()
end

-- themeRenderArea( element, what, areaX, areaY, areaWidth, areaHeight, extraArgument1, ... )
local function themeRenderArea(el, what, areaX, areaY, areaW, areaH, ...)
	local x = round(el:getXOnScreen()+areaX)
	local y = round(el:getYOnScreen()+areaY)
	return themeRenderOnScreen(el, what, x, y, areaW, areaH, ...)
end

-- themeRender( element, what, extraArgument1, ... )
local function themeRender(el, what, ...)
	return themeRenderArea(el, what, 0, 0, el._layoutWidth, el._layoutHeight, ...)
end

-- width, height = themeGetSize( element, what, extraArgument1, ... )
local function themeGetSize(el, what, ...)
	local w, h = themeCallBack(el._gui, "size", what, el, ...)
	if not (type(w) == "number" and type(h) == "number") then
		errorf(2, "Theme (or default theme) did not return width and height for '%s', instead we got: %s, %s", what, tostring(w), tostring(h))
	end
	return w, h
end



local function drawLayoutBackground(el)
	if el._background == "" then  return  end

	if el._gui.debug then
		setColor(.27, .27, .27, .86)
		$LG.rectangle("fill", xywh(el))
	else
		themeRender(el, "background", el._background)
	end
end



-- value = trigger( element, event, value1, ... )
local function trigger(el, event, ...)
	local cb = el._callbacks[event]
	if not cb then  return nil  end

	return cb(el, event, ...)
end

-- value = triggerIncludingAnimations( element, event, value, ... )
local function triggerIncludingAnimations(el, event, ...)
	local time = el._gui._time

	for _, anim in ipairs(el._animations) do
		local cb = anim.callbacks[event]
		if cb then  cb(el, event, (time-anim.startTime)/anim.duration, ...)  end
	end

	return trigger(el, event, ...)
end



local function updateHoveredElement(gui)
	local el = (gui._mouseX ~= !(MOUSE_POS_UNKNOWN)) and gui:getElementAt(gui._mouseX, gui._mouseY, false) or nil
	if gui._hoveredElement == el then  return  end

	local oldEl         = gui._hoveredElement
	gui._hoveredElement = el

	if not (el and oldEl and el._tooltip ~= "" and oldEl._tooltip ~= "" and gui._tooltipTime >= gui.TOOLTIP_DELAY) then
		-- @UX: Don't reset tooltip time instantly - add a delay.
		gui._tooltipTime = 0
	end
end

-- Removes current navigation target if it isn't a valid target anymore.
local function validateNavigationTarget(gui)
	local nav = gui._navigationTarget
	if nav and not gui:canNavigateTo(nav) then
		gui:navigateTo(nil)
	end
end



-- didUpdate = updateLayout( element )
local function updateLayout(el)
	local gui = el._gui
	if gui.debug then
		print("Gui: Updating layout.")
	end

	local container = el:getRoot() -- @Incomplete @Speed: Make any element able to update it's layout. (See comment below.)
	if container._hidden then  return false  end

	container:_updateLayoutSize()
	container:_expandLayout(nil, nil) -- (Currently, most likely only works correctly if 'container' is the root.) (I think we need to save the last arguments to _expandLayout(). 2022-03-28)
	container:_updateLayoutPosition()

	gui._layoutNeedsUpdate = false

	for innerEl in container:traverseVisible() do
		triggerIncludingAnimations(innerEl, "layout")
	end

	updateHoveredElement(gui)

	return true
end

-- didUpdate = updateLayoutIfNeeded( gui )
local function updateLayoutIfNeeded(gui)
	if not gui._layoutNeedsUpdate then  return false  end
	gui._layoutNeedsUpdate = false

	local root = gui._root
	if not root then  return false  end

	return updateLayout(root)
end

local function scheduleLayoutUpdateIfDisplayed(el)
	local gui = el._gui
	if gui._layoutNeedsUpdate then  return  end

	gui._layoutNeedsUpdate = el:isDisplayed()
	if gui.debug and gui._layoutNeedsUpdate then
		print("Gui: Scheduling layout update.")
	end
end



local function setVisualScroll(container, scrollX, scrollY)
	local dx = scrollX - container._visualScrollX
	local dy = scrollY - container._visualScrollY

	local didScroll = false

	if dx ~= 0 then
		container._visualScrollX = container._visualScrollX + dx
		didScroll                = true
	end

	if dy ~= 0 then
		container._visualScrollY = container._visualScrollY + dy
		didScroll                = true
	end

	if not didScroll then  return  end

	for el in container:traverse() do
		el._layoutOffsetX = el._layoutOffsetX + dx
		el._layoutOffsetY = el._layoutOffsetY + dy
	end

	updateHoveredElement(container._gui)
end



-- useColor( color [, alphaMultiplier=1 ] )
local function useColor(color, opacity)
	if not opacity then
		setColor(color)
	else
		local r, g, b, a = unpack(color)
		setColor(r, g, b, (a or 1)*opacity)
	end
end



--==============================================================



-- updateContainerChildLayoutSizes( container )
local function updateContainerChildLayoutSizes(container)
	for _, child in ipairs(container) do
		if not child._hidden then
			child:_updateLayoutSize()
		end
	end
end



-- <see_return_statement> = getContainerLayoutSizeValues( bar )
local function getContainerLayoutSizeValues(bar)
	local staticW, dynamicW, highestW, highestDynamicW, expandablesX = 0, 0, 0, 0, 0
	local staticH, dynamicH, highestH, highestDynamicH, expandablesY = 0, 0, 0, 0, 0

	local currentSx = 0
	local currentSy = 0
	local sumSx     = 0
	local sumSy     = 0
	local first     = true

	for _, child in ipairs(bar) do
		if not (child._hidden or child._floating) then
			-- Dimensions.
			highestW = math.max(highestW, child._layoutWidth)
			highestH = math.max(highestH, child._layoutHeight)

			if child._width >= 0 then
				staticW = staticW + child._width
			else
				dynamicW        = dynamicW + child._layoutWidth
				highestDynamicW = math.max(highestDynamicW, child._layoutWidth)
				expandablesX    = expandablesX + 1
			end
			if child._height >= 0 then
				staticH = staticH + child._height
			else
				dynamicH        = dynamicH + child._layoutHeight
				highestDynamicH = math.max(highestDynamicH, child._layoutHeight)
				expandablesY    = expandablesY + 1
			end

			-- Spacing.
			if not first then
				currentSx = math.max(currentSx, (child._spacingLeft or child._spacingHorizontal or child._spacing))
				currentSy = math.max(currentSy, (child._spacingTop  or child._spacingVertical   or child._spacing))
			end
			sumSx, sumSy = sumSx+currentSx, sumSy+currentSy
			currentSx = (child._spacingRight  or child._spacingHorizontal or child._spacing)
			currentSy = (child._spacingBottom or child._spacingVertical   or child._spacing)
			first = false
		end
	end

	return staticW, dynamicW, highestW, highestDynamicW, expandablesX, currentSx, sumSx,
	       staticH, dynamicH, highestH, highestDynamicH, expandablesY, currentSy, sumSy
end



-- updateContainerLayoutSize( container )
local function updateContainerLayoutSize(container)
	local w = container._width
	if w < 0 then
		w = math.max(container._layoutInnerWidth+container:getInnerSpaceX(), container._minWidth)
		if container._maxWidth >= 0 then  w = math.min(w, container._maxWidth)  end
	end
	container._layoutWidth          = w
	-- container._layoutInnerWidth  = w - container:getInnerSpaceX() -- No! The inner size is the size of the contents.

	local h = container._height
	if h < 0 then
		h = math.max(container._layoutInnerHeight+container:getInnerSpaceY(), container._minHeight)
		if container._maxHeight >= 0 then  h = math.min(h, container._maxHeight)  end
	end
	container._layoutHeight         = h
	-- container._layoutInnerHeight = h - container:getInnerSpaceY() -- No! The inner size is the size of the contents.
end

-- expandContainer( container, expandWidth|nil, expandHeight|nil )
local function expandContainer(container, expandW, expandH)
	local parent = container._parent

	if (expandW or container._expandX) and container._width < 0 then
		local w = expandW or parent._layoutInnerWidth+container:getInnerSpaceX()
		if container._maxWidth >= 0  then  w = math.min(w, container._maxWidth)  end

		w                           = math.max(w, container._minWidth)
		container._layoutWidth      = w
		container._layoutInnerWidth = w - container:getInnerSpaceX()
	end

	if (expandH or container._expandY) and container._height < 0 then
		local h = expandH or parent._layoutInnerHeight+container:getInnerSpaceY()
		if container._maxHeight >= 0 then  h = math.min(h, container._maxHeight)  end

		h                            = math.max(h, container._minHeight)
		container._layoutHeight      = h
		container._layoutInnerHeight = h - container:getInnerSpaceY()
	end
end



-- updateFloatingElementPosition( element )
local function updateFloatingElementPosition(child)
	local parent = child._parent

	child._layoutX = round(0
		+ parent._layoutX
		+ parent._padding
		+ child._originX * parent._layoutInnerWidth
		+ child._x
		- child._anchorX * child._layoutWidth
	)

	child._layoutY = round(0
		+ parent._layoutY
		+ parent._padding
		+ child._originY * parent._layoutInnerHeight
		+ child._y
		- child._anchorY * child._layoutHeight
	)

	child:_updateLayoutPosition()
end



local font = nil

local function getDefaultFont()
	font = font or $LG.newFont(12)
	return font
end



--==============================================================
--= Library functions ==========================================
--==============================================================



-- quads = create9PartQuads( image, leftColumnSize, topRowSize [, rightColumnSize=leftColumnSize, bottomRowSize=topRowSize ] )
-- quads = {
--     topLeftQuad,    topCenterQuad,    topRightQuad,
--     middleLeftQuad, middleCenterQuad, middleRightQuad,
--     bottomLeftQuad, bottomCenterQuad, bottomRightQuad,
-- }
function _M.create9PartQuads(image, l, t, r, b)
	r = r or l
	b = b or t
	local iw, ih = image:getDimensions()
	return {
		$LG.newQuad(   0,    0,      l,      t, iw, ih),
		$LG.newQuad(   l,    0, iw-l-r,      t, iw, ih),
		$LG.newQuad(iw-r,    0,      r,      t, iw, ih),
		$LG.newQuad(   0,    t,      l, ih-t-b, iw, ih),
		$LG.newQuad(   l,    t, iw-l-r, ih-t-b, iw, ih),
		$LG.newQuad(iw-r,    t,      r, ih-t-b, iw, ih),
		$LG.newQuad(   0, ih-b,      l,      b, iw, ih),
		$LG.newQuad(   l, ih-b, iw-l-r,      b, iw, ih),
		$LG.newQuad(iw-r, ih-b,      r,      b, iw, ih),
	}
end



-- draw9PartScaled(
--     x, y, width, height,
--     topLeftImage,    topCenterImage,    topRightImage,
--     middleLeftImage, middleCenterImage, middleRightImage,
--     bottomLeftImage, bottomCenterImage, bottomRightImage
-- )
-- draw9PartScaled(
--     x, y, width, height, image,
--     topLeftQuad,    topCenterQuad,    topRightQuad,
--     middleLeftQuad, middleCenterQuad, middleRightQuad,
--     bottomLeftQuad, bottomCenterQuad, bottomRightQuad
-- )
function _M.draw9PartScaled(x, y, w, h, image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32, obj33)
	if not obj33 then
		image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32, obj33
			= nil, image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32
	end

	local t, l, r, b, sx, sy
	if image then
		local _, objW, objH
		_, _, l, objH = obj21:getViewport()
		_, _, r       = obj23:getViewport()
		_, _, objW, t = obj12:getViewport()
		_, _, _,    b = obj32:getViewport()
		sx = (w-l-r) / objW
		sy = (h-t-b) / objH
	else
		l  = obj21:getWidth()
		r  = obj23:getWidth()
		t  = obj12:getHeight()
		b  = obj32:getHeight()
		sx = (w-l-r) / obj12:getWidth()
		sy = (h-t-b) / obj21:getHeight()
	end

	$LG.push()
	$LG.translate(x, y)

	-- Fill.
	drawImage(image, obj22, l, t, 0, sx, sy)

	-- Sides.
	drawImage(image, obj12,   l,   0, 0, sx,  1)
	drawImage(image, obj23, w-r,   t, 0,  1, sy)
	drawImage(image, obj32,   l, h-b, 0, sx,  1)
	drawImage(image, obj21,   0,   t, 0,  1, sy)

	-- Corners.
	drawImage(image, obj11,   0,   0)
	drawImage(image, obj13, w-r,   0)
	drawImage(image, obj31,   0, h-b)
	drawImage(image, obj33, w-r, h-b)

	$LG.pop()
end



--
-- image     = Gui.newMonochromeImage( pixelRows [, red=1, green=1, blue=1 ] )
-- pixelRows = { pixelRow1, ... }
-- pixelRow: String with single-digit hexadecimal numbers. Invalid characters counts as 0.
--
-- Example:
--     blurryDiagonalLine = Gui.newMonochromeImage{
--         " 5F",
--         "5F5",
--         "F5 ",
--     }
--
function _M.newMonochromeImage(pixelRows, r, g, b)
	r = r or 1
	g = g or 1
	b = b or 1

	local imageData = love.image.newImageData(#pixelRows[1], #pixelRows)

	for row, pixelRow in ipairs(pixelRows) do
		for col = 1, #pixelRow do
			local pixel = tonumber(pixelRow:sub(col, col), 16) or 0
			imageData:setPixel(col-1, row-1, r, g, b, pixel/15) -- @Speed
		end
	end

	return $LG.newImage(imageData)
end

--
-- image     = Gui.newImageUsingPalette( pixelRows, palette )
-- pixelRows = { pixelRow1, ... }
-- pixelRow: String with single-character palette indices. Invalid indices counts as transparent pixels.
-- palette   = { ["index"]=color... }
-- color     = { red, green, blue [, alpha=1 ] }
--
-- Example:
--     doubleWideRainbow = Gui.newImageUsingPalette(
--         {
--             "rygcbp",
--             "rygcbp",
--         },
--         {
--             ["r"] = {1,0,0}, -- red
--             ["y"] = {1,1,0}, -- yellow
--             ["g"] = {0,1,0}, -- green
--             ["c"] = {0,1,1}, -- cyan
--             ["b"] = {0,0,1}, -- blue
--             ["p"] = {1,0,1}, -- purple
--         }
--     )
--
function _M.newImageUsingPalette(pixelRows, palette)
	local imageData = love.image.newImageData(#pixelRows[1], #pixelRows)

	for row, pixelRow in ipairs(pixelRows) do
		for col = 1, #pixelRow do
			local pixel      = (palette[pixelRow:sub(col, col)] or COLOR_TRANSPARENT)
			local r, g, b, a = unpack(pixel)
			imageData:setPixel(col-1, row-1, r, g, b, (a or 1)) -- @Speed
		end
	end

	return $LG.newImage(imageData)
end



-- target, event  = Gui.parseTargetAndEvent( targetAndEvent )
-- targetAndEvent = "ID.subID.anotherSubID.event" -- Sequence of dot-separated IDs followed by a dot and an event name.
-- Returns nil and a message on error.
function _M.parseTargetAndEvent(targetAndEvent)
	local target, event = targetAndEvent:match"^(.-)%.?([^.]+)$"
	if not target then
		return nil, F("Bad targetAndEvent format '%s'.", targetAndEvent)
	end
	return target, event
end



--==============================================================
--= GUI class ==================================================
--==============================================================



-- Gui( )
function Gui:init()
	self._allAnimations          = {}
	self._defaultSounds          = {}
	self._heres                  = {}
	self._mouseFocusButtonStates = {false, false, false} -- We only handle mouse button 1-3.

	self._styles = {
		["_MENU"] = {},
	}
end



-- gui:update( deltaTime )
function Gui:update(dt)
	local time                = self._time + dt
	self._time                = time
	self._tooltipTime         = self._tooltipTime + dt
	self._timeSinceNavigation = self._timeSinceNavigation + dt

	local allAnims = self._allAnimations

	if allAnims[1] then
		for i, anim in ipairsr(allAnims) do
			local el = anim.element

			if time >= anim.endTime then
				local cb = anim.callbacks["update"]
				if cb then  cb(el, "update", 1)  end -- Make sure 'update' gets progress=1.

				cb = anim.callbacks["done"]
				if cb then  cb(el, "done")  end

				local anims = el._animations
				table.remove(allAnims, i)
				table.remove(anims, assert(indexOf(anims, anim)))

				if anim.lockInteraction then
					self._animationLockCount = self._animationLockCount-1
				end

			else
				local cb = anim.callbacks["update"]
				if cb then
					cb(el, "update", (time-anim.startTime)/anim.duration)
				end
			end

		end

		if self._animationLockCount == 0 then
			updateHoveredElement(self)
		end
	end

	if self._root then
		self._root:_update(dt)

		if self._root:isVisible() then
			trigger(self._root, "update", dt)

			for el in self._root:traverseVisible() do
				trigger(el, "update", dt)
			end
		end
	end

	-- The navigation target has a special additional update event.
	local nav = self._navigationTarget
	if nav then  trigger(nav, "navupdate", dt)  end

	-- Check if mouse is inside window.
	if self._mouseX ~= !(MOUSE_POS_UNKNOWN) and not love.window.hasMouseFocus() then
		self:mousemoved(!(MOUSE_POS_UNKNOWN), !(MOUSE_POS_UNKNOWN))
	end

	--
	-- Update mouse cursor.
	--
	local el  = self._mouseFocus or self._hoveredElement
	local cur = el and el:getResultingMouseCursor()

	if self._currentMouseCursor ~= cur then
		self._currentMouseCursor = cur
		$LM.setCursor(cur)
	end

	self._ignoreKeyboardInputThisFrame = false
end



-- gui:draw( )
function Gui:draw()
	if self._root and not self._root._hidden then
		updateLayoutIfNeeded(self)

		-- Elements.
		self._root:_draw()

		-- Navigation target.
		if not self.debug then
			local nav = self._navigationTarget
			if nav then  themeRender(nav, "navigation", self._timeSinceNavigation)  end
		end

		-- Tooltip.
		local el = self._hoveredElement
		if el and not self._mouseFocus then
			el:_drawTooltip()
		end
	end
end



--==============================================================



-- handled = gui:keypressed( key, scancode, isRepeat )
function Gui:keypressed(key, scancode, isRepeat)
	!ARGS"2 key,scancode:string isRepeat:boolean"

	if self._animationLockCount > 0 then  return true  end

	local focus = (self._keyboardFocus or self._mouseFocus)
	local el = (focus or self._hoveredElement)

	if self._ignoreKeyboardInputThisFrame then
		return (el ~= nil)
	end

	el = (el or self._navigationTarget) -- Can this be on the 'el' declaration line?

	if el then
		if focus then
			if trigger(focus,     "keypressed", key, scancode, isRepeat) then  return true  end
		else
			if el:triggerBubbling("keypressed", key, scancode, isRepeat) then  return true  end
		end
		local handled, grabKbFocus = el:_keypressed(key, scancode, isRepeat)
		if handled then
			if grabKbFocus then  setKeyboardFocus(self, el)  end
			return true
		end
	end

	if focus then  return true  end

	local root = self._root
	if root and not root._hidden then
		for el in root:traverseVisible() do
			if key == "escape" and el:canClose() then
				el:close()
				return true
			elseif el._captureInput then
				return true
			elseif el._captureGuiInput then
				break
			end
		end
	end

	return false
end

-- handled = gui:keyreleased( key, scancode )
function Gui:keyreleased(key, scancode)
	!ARGS"2 key,scancode:string"

	local focus = self._keyboardFocus
	if focus then
		focus:_keyreleased(key, scancode)
		return true
	end

	return false
end

-- handled = gui:textinput( text )
function Gui:textinput(text)
	!ARGS"2 text:string"

	if self._animationLockCount > 0 then  return true  end

	local focus = self._keyboardFocus or self._mouseFocus
	local el    = focus or self._hoveredElement

	if self._ignoreKeyboardInputThisFrame then
		return (el ~= nil)
	end

	el = (el or self._navigationTarget) -- Can this be on the 'el' declaration line?

	if el then
		if not focus and el:triggerBubbling("textinput", text) then  return true  end

		if el:_textinput(text) then  return true  end
	end

	if focus then  return true  end

	local root = self._root
	if root and not root._hidden then
		for el in root:traverseVisible() do
			if el._captureInput    then  return true  end
			if el._captureGuiInput then  break        end
		end
	end

	return false
end



-- handled = gui:mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Gui:mousepressed(mx, my, mbutton, pressCount)
	!ARGS"2 mx,my,mbutton,pressCount:number"
	if mbutton > 3 then  return false  end

	self._mouseX = mx
	self._mouseY = my

	if self._animationLockCount > 0 then  return true  end

	if self._mouseFocusButtonStates[mbutton] then
		-- The mouse button got pressed twice or more with no release inbetween.
		-- Should be an error, but it's not really an issue.
		return true
	end

	updateLayoutIfNeeded(self) -- Updates hovered element.

	local mouseFocus = self._mouseFocus
	local currentEl  = mouseFocus or self._hoveredElement

	if self._keyboardFocus and currentEl ~= self._keyboardFocus then
		self._keyboardFocus:blur() -- We assume this is a GuiInput. @Volatile
	end

	while currentEl do
		-- Trigger any custom mousepressed event handler.
		-- Returning true from the handler suppresses the default behavior.
		local screenX, screenY = currentEl:getPositionOnScreen()
		if currentEl:trigger("mousepressed", mx-screenX, my-screenY, mbutton, pressCount) then
			return true
		end

		-- Trigger the internal mousepressed event handler.
		local handled, grabMouseFocus = currentEl:_mousepressed(mx, my, mbutton, pressCount)
		if handled then
			if grabMouseFocus then  setMouseFocus(self, mbutton, currentEl)  end
			return true
		end

		if mouseFocus or currentEl._captureInput or currentEl._captureGuiInput or currentEl:isSolid() then
			return true
		end

		currentEl = currentEl._parent
	end

	return false
end

-- handled = gui:mousemoved( mouseX, mouseY )
function Gui:mousemoved(mx, my)
	!ARGS"2 mx,my:number"

	self._mouseX = mx
	self._mouseY = my

	if self._animationLockCount > 0 then  return true  end

	if not updateLayoutIfNeeded(self) then
		updateHoveredElement(self) -- Make sure hovered element updates whenever mouse moves.
	end

	local focus = self._mouseFocus
	if not focus then  return false  end

	local el = (mx and focus or self._hoveredElement)
	if el then
		el:_mousemoved(mx, my)
		trigger(el, "mousemoved", mx-el:getXOnScreen(), my-el:getYOnScreen())
	end

	return true
end

-- handled = gui:mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Gui:mousereleased(mx, my, mbutton, pressCount)
	!ARGS"2 mx,my,mbutton,pressCount:number"
	if mbutton > 3 then  return false  end

	self._mouseX = mx
	self._mouseY = my

	local focus = self._mouseFocus
	if not (focus and self._mouseFocusButtonStates[mbutton]) then
		return false
	end

	blurMouseFocus(self, mbutton)
	updateLayoutIfNeeded(self) -- Updates hovered element.

	local el = focus or self._hoveredElement
	if el then
		el:_mousereleased(mx, my, mbutton, pressCount)
	end

	if el then
		trigger(el, "mousereleased", mx-el:getXOnScreen(), my-el:getYOnScreen(), mbutton, pressCount)
	end

	return true
end

-- handled = gui:wheelmoved( dx, dy )
function Gui:wheelmoved(dx, dy)
	!ARGS"2 dx,dy:number"

	if self._animationLockCount > 0 then  return true  end

	local isScroll = (dx ~= 0 or dy ~= 0)

	-- Shift key swaps X and Y scrolling.
	if love.keyboard.isDown("lshift","rshift") then
		dx, dy = dy, dx
	end

	local focus = self._mouseFocus
	if not focus then
		updateLayoutIfNeeded(self) -- Updates hovered element.
	end

	-- Focus (non-bubbling event)
	-- OR hovered element (bubbling event).
	local el         = focus or self._hoveredElement
	local anyIsSolid = false

	while el do
		if isScroll then
			-- Trigger any custom wheelmoved event handler.
			-- Returning true from the handler suppresses the default behavior.
			if el:trigger("wheelmoved", dx, dy) then  return true  end

			if el:_wheelmoved(dx, dy) then  return true  end
		end

		if focus then  return focus:isSolid()  end

		anyIsSolid = anyIsSolid or el:isSolid()
		el         = el._parent
	end

	return anyIsSolid
end



--==============================================================



-- bool = gui:areStandardKeysActive( )
function Gui:areStandardKeysActive()
	return self._standardKeysAreActive
end

-- gui:setStandardKeysActive( bool )
function Gui:setStandardKeysActive(active)
	self._standardKeysAreActive = active
end



-- gui:blur( )
function Gui:blur()
	if self._mouseFocus then
		for mbutton, state in ipairs(self._mouseFocusButtonStates) do
			if state then
				self:mousereleased(self._mouseX, self._mouseY, mbutton, 1--[[ @Polish: Keep track of pressCount. ]])
			end
		end
	end

	blurMouseFocus(self, nil)

	if self._keyboardFocus then
		self._keyboardFocus:blur() -- We assume this is a GuiInput. @Volatile
	end
end



--
-- gui:defineStyle( styleName, styleData )
-- styleData = { parameter1=value, ..., [1]=child1StyleData, ... }
--
-- Examples:
--     gui:defineStyle("centered", {originX=.5, originY=.5, anchorX=.5, anchorY=.5})
--     gui:defineStyle("dialogHeader", {background="header",
--         [2] = {bold=true, textColor={1,1,1,.86}}, -- Style data for the second child.
--     })
--
-- @Incomplete: A way to specify style for a child (or grandchild?) by ID.
--
function Gui:defineStyle(styleName, styleData)
	!ARGS"2 styleName:string styleData:table"
	self._styles[styleName] = styleData
end



-- element = gui:find( id )
function Gui:find(id)
	local root = self._root
	if root then
		return (root._id == id and root or root:find(id))
	end
	return nil
end

-- elements = gui:findAll( id )
function Gui:findAll(id)
	local root = self._root
	if not root then  return {}  end

	local els = root:findAll(id)
	if root._id == id then
		table.insert(els, 1, root)
	end

	return els
end

-- element = gui:findActive( )
function Gui:findActive()
	local root = self._root
	return (root and root:findActive())
end

-- element = gui:findToggled( )
function Gui:findToggled()
	local root = self._root
	return (root and root:findToggled())
end

-- Match an element using a CSS-like selector.
-- element  = gui:match( selector )
-- selector = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Gui:match(selector)
	local root = self._root
	if not root then  return nil  end
	return root:match(selector, true)
end

-- Match elements using a CSS-like selector.
-- elements = gui:matchAll( selector )
-- selector = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Gui:matchAll(selector)
	local root = self._root
	if not root then  return {}  end
	return root:matchAll(selector, true)
end



-- sound = gui:getDefaultSound( soundKey )
function Gui:getDefaultSound(soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	return self._defaultSounds[soundK]
end

-- gui:setDefaultSound( soundKey, sound )
-- gui:setDefaultSound( soundKey, nil ) -- Remove default sound.
-- Note: 'sound' is the value sent to the GUI sound player callback.
function Gui:setDefaultSound(soundK, sound)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	self._defaultSounds[soundK] = sound
end



-- element = gui:getElementAt( x, y [, includeNonSolid=false ] )
function Gui:getElementAt(x, y, nonSolid)
	local root = self._root
	if root and not root._hidden then
		return root:getElementAt(x, y, nonSolid)
	end
	return nil
end



-- font = gui:getFont( )
function Gui:getFont()
	return self._font
end

-- gui:setFont( font )
function Gui:setFont(font)
	if self._font == font then  return  end
	self._font              = font
	self._layoutNeedsUpdate = true
end

-- font = gui:getBoldFont( )
function Gui:getBoldFont()
	return self._fontBold
end

-- gui:setBoldFont( font )
function Gui:setBoldFont(font)
	if self._fontBold == font then  return  end
	self._fontBold          = font
	self._layoutNeedsUpdate = true
end

-- font = gui:getSmallFont( )
function Gui:getSmallFont()
	return self._fontSmall
end

-- gui:setSmallFont( font )
function Gui:setSmallFont(font)
	if self._fontSmall == font then  return  end
	self._fontSmall         = font
	self._layoutNeedsUpdate = true
end

-- font = gui:getLargeFont( )
function Gui:getLargeFont()
	return self._fontLarge
end

-- gui:setLargeFont( font )
function Gui:setLargeFont(font)
	if self._fontLarge == font then  return  end
	self._fontLarge         = font
	self._layoutNeedsUpdate = true
end

-- font = gui:getTooltipFont( )
function Gui:getTooltipFont()
	return self._fontTooltip
end

-- gui:setTooltipFont( font )
function Gui:setTooltipFont(font)
	self._fontTooltip = font
end



-- element = gui:getHoveredElement( )
function Gui:getHoveredElement()
	return self._hoveredElement
end



do
	local function setNavigationTarget(self, widget)
		if self._navigationTarget == widget then
			return false -- no change
		end
		self._navigationTarget    = widget
		self._timeSinceNavigation = 0
		if widget then
			widget:scrollIntoView()
		end
		;(widget or self._root):triggerBubbling("navigated", widget)
		return true -- change happened!
	end

	-- widget = gui:getNavigationTarget( )
	function Gui:getNavigationTarget()
		return self._navigationTarget
	end

	-- success = gui:navigateTo( widget )
	function Gui:navigateTo(widget)
		if self._navigationTarget == widget then  return true   end
		if self._lockNavigation             then  return false  end
		if not self:canNavigateTo(widget)   then  return false  end
		setNavigationTarget(self, widget)
		return true
	end

	do
		local function navigateToNextOrPrevious(self, id, allowNone, usePrev)
			local root = self._root
			if not root or root._hidden then  return nil  end

			local nav = self._navigationTarget
			if not nav and not usePrev then  return self:navigateToFirst()  end

			local foundNav   = false
			local lastWidget = nil

			for el in (nav and nav:getNavigationRoot() or root):traverseVisible() do
				-- Note: Remember that we're traversing backwards.
				local elIsValid = el:is(Cs.widget) and (not id or el._id == id)

				if elIsValid and usePrev and foundNav then
					setNavigationTarget(self, el)
					return el
				end

				foundNav = (foundNav or el == nav)

				if not usePrev and foundNav then
					if lastWidget or allowNone then
						setNavigationTarget(self, lastWidget)
						return lastWidget
					end
					return nav
				end

				if elIsValid then  lastWidget = el  end

				if el._captureInput or el._captureGuiInput then  break  end
			end

			if not allowNone then  return nav  end

			setNavigationTarget(self, nil)
			return nil
		end

		-- element = gui:navigateToNext( [ id=any, allowNone=false ] )
		-- Note: Calls gui:navigateToFirst() if there's no current navigation target.
		function Gui:navigateToNext(id, allowNone)
			return navigateToNextOrPrevious(self, id, allowNone, false)
		end

		-- element = gui:navigateToPrevious( [ id=any, allowNone=false ] )
		function Gui:navigateToPrevious(id, allowNone)
			return navigateToNextOrPrevious(self, id, allowNone, true)
		end
	end

	-- element = gui:navigateToFirst( )
	function Gui:navigateToFirst()
		if self._lockNavigation then  return nil  end

		local root = self._root
		if not root or root._hidden then  return nil  end

		local first = nil

		for el in root:traverseVisible() do
			if el:is(Cs.widget) and not (first and first._priority > el._priority) then
				first = el
			end
			if el._captureInput or el._captureGuiInput then
				break
			end
		end

		setNavigationTarget(self, first)
		return first
	end

	-- landingElement = gui:navigate( angle )
	function Gui:navigate(angle)
		if self._lockNavigation then  return nil  end

		local root = self._root
		if not root or root._hidden then  return nil  end

		local nav = self._navigationTarget
		if not nav then  return self:navigateToFirst()  end

		if trigger(nav, "navigate", angle) then
			return self._navigationTarget -- Suppress default behavior.
		end

		local closestEl = nav:getClosestInDirection(angle)
		if closestEl then
			setNavigationTarget(self, closestEl)
		end

		return (closestEl or nav)
	end

	-- bool = gui:canNavigateTo( element|nil )
	-- Note: Does not check if navigation is locked.
	function Gui:canNavigateTo(widget)
		if widget == nil            then  return true   end -- Navigation target can always be nothing.
		if not widget:is(Cs.widget) then  return false  end
		if not widget:isDisplayed() then  return false  end

		local root = self._root
		if not root or root._hidden then  return false  end

		for el in root:traverseVisible() do
			if el == widget then
				return true
			elseif (el._captureInput or el._captureGuiInput) then
				return false
			end
		end

		error("Somehow the element is a displayed active widget but not among the visible elements under the root.")
	end
end



-- root = gui:getRoot( )
function Gui:getRoot()
	return self._root
end



-- converter|nil = gui:getScissorCoordsConverter( )
function Gui:getScissorCoordsConverter()
	return self._scissorCoordsConverter
end

--
-- gui:setScissorCoordsConverter( converter|nil )
-- x, y, width, height = converter( x, y, width, height )
--
-- If the graphics transform is changed outside the GUI system then a scissor
-- coordinate converter is needed for scissoring to work properly.
--
function Gui:setScissorCoordsConverter(converter)
	self._scissorCoordsConverter = converter
end



-- speedX, speedY = gui:getScrollSpeed( )
function Gui:getScrollSpeed()
	return self._scrollSpeedX, self._scrollSpeedY
end

-- gui:setScrollSpeed( speedX [, speedY=speedX ] )
function Gui:setScrollSpeed(speedX, speedY)
	!ARGS"2 speedX:number ? speedY:number"
	self._scrollSpeedX = speedX
	self._scrollSpeedY = speedY or speedX
end



-- soundPlayer = gui:getSoundPlayer( )
function Gui:getSoundPlayer()
	return self._soundPlayer
end

-- gui:setSoundPlayer( soundPlayer|nil )
-- soundPlayer = function( sound )
function Gui:setSoundPlayer(soundPlayer)
	self._soundPlayer = soundPlayer
end



-- spriteLoader = gui:getSpriteLoader( )
function Gui:getSpriteLoader()
	return self._spriteLoader
end

-- gui:setSpriteLoader( spriteLoader|nil )
-- image, frames = spriteLoader( spriteName )
-- frames        = { frame1, ... }
-- frame         = { duration=duration, quad=quad }
function Gui:setSpriteLoader(spriteLoader)
	self._spriteLoader = spriteLoader
end



-- targetElement = gui:getTarget( target )
-- target        = "ID.subID.anotherSubID" -- Sequence of dot-separated IDs.
-- Returns nil and a message on error.
function Gui:getTarget(target)
	local el = self._root
	if not el then  return nil, "There is no root element."  end

	local ids = matchAll(target, "[^.]+") -- @Memory

	for i = 1, #ids do
		if not el:is(Cs.container) then
			return false, F("'%s' is not a container.", el._id)
		end

		el = el:find(ids[i])
		if not el then
			return nil, F("'%s' does not exist in '%s'.", ids[i], (ids[i-1] or "root"))
		end
	end

	return el
end

-- callback       = gui:getTargetCallback( targetAndEvent )
-- targetAndEvent = "ID.subID.anotherSubID.event" -- Sequence of dot-separated IDs followed by a dot and an event name.
-- Returns nil and a message on error.
-- Returns nil (and no message) if there's no callback.
function Gui:getTargetCallback(targetAndEvent)
	local target, eventOrErr = _M.parseTargetAndEvent(targetAndEvent)
	if not target then  return nil, eventOrErr  end

	local el, err = self:getTarget(target)
	if not el then  return nil, err  end

	return el:getCallback(eventOrErr)
end

-- targetElement  = gui:setTargetCallback( targetAndEvent, callback|nil )
-- targetAndEvent = "ID.subID.anotherSubID.event" -- Sequence of dot-separated IDs followed by a dot and an event name.
-- Returns nil and a message on error.
function Gui:setTargetCallback(targetAndEvent, cb)
	local target, eventOrErr = _M.parseTargetAndEvent(targetAndEvent)
	if not target then  return nil, eventOrErr  end

	local el, err = self:getTarget(target)
	if not el then  return nil, err  end

	el:on(eventOrErr, cb)
	return el
end



-- textPreprocessor|nil = gui:getTextPreprocessor( )
function Gui:getTextPreprocessor()
	return self._textPreprocessor
end

-- gui:setTextPreprocessor( textPreprocessor|nil )
-- newText = textPreprocessor( text, element, mnemonicsAreEnabled )
function Gui:setTextPreprocessor(f)
	!ARGS"2 f:function,nil"
	self._textPreprocessor = f
end

-- gui:reprocessTexts( )
-- Manually re-preprocess texts. Useful if e.g. the program's language has changed.
function Gui:reprocessTexts()
	local root = self._root
	if root then
		root:reprocessTexts()
	end
end



-- theme|nil = gui:getTheme( )
function Gui:getTheme()
	return self._theme
end

-- gui:setTheme( theme|nil )
function Gui:setTheme(theme)
	!ARGS"2 theme:table,nil"
	if self._theme == theme then  return  end
	self._theme             = theme
	self._layoutNeedsUpdate = true
end



-- time = gui:getTime( )
function Gui:getTime()
	return self._time
end

-- time = gui:getTimeSinceNavigation( )
function Gui:getTimeSinceNavigation()
	return self._timeSinceNavigation
end



-- bool = gui:isBusy( )
function Gui:isBusy()
	return self:isKeyboardBusy() or self:isMouseBusy()
end

-- bool = gui:isKeyboardBusy( )
function Gui:isKeyboardBusy()
	return self._keyboardFocus ~= nil
end

-- bool = gui:isMouseBusy( )
function Gui:isMouseBusy()
	return self._mouseFocus ~= nil
end



-- bool = gui:isIgnoringKeyboardInput( )
function Gui:isIgnoringKeyboardInput()
	return self._ignoreKeyboardInputThisFrame
end



-- bool = gui:isInputCaptured( [ includeGuiInput=false ] )
function Gui:isInputCaptured(includeGuiInput)
	local root = self._root
	if not root or root._hidden then  return false  end

	for el in root:traverseVisible() do
		if el._captureInput or (includeGuiInput and el._captureGuiInput) then
			return true
		end
	end

	return false
end



-- bool = gui:isInteractionLocked( )
function Gui:isInteractionLocked()
	return (self._animationLockCount > 0)
end



-- bool = gui:isMouseGrabbed( )
function Gui:isMouseGrabbed()
	return self._mouseIsGrabbed
end

-- gui:setMouseIsGrabbed( bool )
function Gui:setMouseIsGrabbed(grabbed)
	self._mouseIsGrabbed = grabbed
end



-- gui:load( elementData )
-- elementData = { type=elementType, parameter1=value, ..., [1]=child1Data, ... }
-- elementData = {      elementType, parameter1=value, ..., [1]=child1Data, ... }
function Gui:load(elData)
	if getTypeFromElementData(elData) ~= "root" then
		errorf(2, "Gui root element must be of type 'root'.")
	end

	local root = Cs.root(self, elData, nil)
	self._root = root

	printHeres(self)

	local themeInit = themeGet(self, "init")
	themeInit(root)
	for el in root:traverse() do
		themeInit(el)
	end

	self._layoutNeedsUpdate = true
end



-- handled = gui:ok( )
-- Trigger 'ok' action.
function Gui:ok()
	local nav = self._navigationTarget
	if nav and nav._active then  return nav:_ok()  end
	return false
end

-- handled = gui:back( )
-- Trigger 'back' action.
function Gui:back()
	local root = self._root
	if not root or root._hidden then  return false  end

	-- Close closable (like Escape does).
	for el in root:traverseVisible() do
		if el:canClose() then
			el:close()
			return true
		elseif el._captureInput or el._captureGuiInput then
			break
		end
	end

	return false
end



-- gui:updateLayout( )
-- Force a layout update. (Should never be needed as it's done automatically.)
function Gui:updateLayout()
	local root = self._root
	if root and not root._hidden then
		return updateLayout(root)
	end
end



--==============================================================
--= Image include ==============================================
--==============================================================



Is.imageInclude = {
	-- Parameters.
	_imageBackgroundColor = nil,
	_imageColor           = nil,
	_imageScaleX          = 1.0, _imageScaleY = 1.0,
	_sprite               = nil,

	_spriteName = nil,
}

local function initImageInclude(self, elData)
	retrieve(self, elData, "_imageBackgroundColor")
	retrieve(self, elData, "_imageColor")
	-- retrieve(self, elData, "_imageScaleX","_imageScaleY")
	-- retrieve(self, elData, "_sprite")

	self._imageScaleX = elData.imageScaleX or elData.imageScale or self._imageScaleX
	self._imageScaleY = elData.imageScaleY or elData.imageScale or self._imageScaleY

	self:setSprite(elData.sprite)
end



-- imageIncludeElement:drawImage( x, y )
function Is.imageInclude:drawImage(x, y)
	if not self._sprite then  return  end
	local image, quad = getCurrentViewOfSprite(self._sprite)
	local padding = (self:is(Cs.button) and self._imagePadding or 0)
	$LG.draw(image, quad, x+padding, y+padding, 0, self._imageScaleX, self._imageScaleY)
end



-- colorTable|nil = imageIncludeElement:getImageBackgroundColor( )
function Is.imageInclude:getImageBackgroundColor()
	return self._imageBackgroundColor
end

-- imageIncludeElement:setImageBackgroundColor( colorTable|nil )
function Is.imageInclude:setImageBackgroundColor(color)
	self._imageBackgroundColor = color
end

-- bool = imageIncludeElement:hasImageBackgroundColor( )
function Is.imageInclude:hasImageBackgroundColor()
	return (self._imageBackgroundColor ~= nil)
end

-- hasImageBackgroundColor = imageIncludeElement:useImageBackgroundColor( [ alphaMultiplier=1 ] )
-- Tell LÖVE to use the image background color.
function Is.imageInclude:useImageBackgroundColor(opacity)
	local color = self._imageBackgroundColor
	useColor((color or COLOR_TRANSPARENT), opacity)
	return (color ~= nil)
end



-- colorTable|nil = imageIncludeElement:getImageColor( )
function Is.imageInclude:getImageColor()
	return self._imageColor
end

-- imageIncludeElement:setImageColor( colorTable|nil )
function Is.imageInclude:setImageColor(color)
	self._imageColor = color
end

-- bool = imageIncludeElement:hasImageColor( )
function Is.imageInclude:hasImageColor()
	return (self._imageColor ~= nil)
end

-- hasImageColor = imageIncludeElement:useImageColor( [ alphaMultiplier=1 ] )
-- Tell LÖVE to use the image color.
function Is.imageInclude:useImageColor(opacity)
	local color = self._imageColor
	useColor((color or COLOR_WHITE), opacity)
	return (color ~= nil)
end



-- width, height = imageIncludeElement:getImageDimensions( )
function Is.imageInclude:getImageDimensions()
	local sprite = self._sprite
	if not sprite then  return 0, 0  end
	return sprite.width, sprite.height
end

-- Sets the scale of the image by specifying a size. Does nothing if there's no image.
-- imageIncludeElement:setImageSize( width, height )
function Is.imageInclude:setImageSize(w, h)
	local sprite = self._sprite
	if not sprite then  return  end
	self:setImageScale(w/sprite.width, h/sprite.height)
end

-- Scales the image so it fills the element. Does nothing if there's no image or if no dimensions are set.
-- imageIncludeElement:maximizeImageSize( [ extraWidth=0, extraHeight=0 ] )
function Is.imageInclude:maximizeImageSize(extraW, extraH)
	local sprite = self._sprite
	if not sprite then  return  end

	local paddingSum = (self:is(Cs.button) and 2*self._imagePadding or 0)

	local scaleX = (self._width  >= 0) and (self._width  - paddingSum + (extraH or 0)) / sprite.width  or self._imageScaleX
	local scaleY = (self._height >= 0) and (self._height - paddingSum + (extraW or 0)) / sprite.height or self._imageScaleY
	self:setImageScale(scaleX, scaleY)
end



-- scaleX, scaleY = imageIncludeElement:getImageScale( )
-- scale = imageIncludeElement:getImageScaleX( )
-- scale = imageIncludeElement:getImageScaleY( )
function Is.imageInclude:getImageScale()
	return self._imageScaleX, self._imageScaleY
end
function Is.imageInclude:getImageScaleX()
	return self._imageScaleX
end
function Is.imageInclude:getImageScaleY()
	return self._imageScaleY
end

-- imageIncludeElement:setImageScale( scaleX [, scaleY=scaleX ] )
-- imageIncludeElement:setImageScaleX( scale )
-- imageIncludeElement:setImageScaleY( scale )
function Is.imageInclude:setImageScale(sx, sy)
	!ARGS"2 sx:number ? sy:number"

	sy = sy or sx
	if self._imageScaleX == sx and self._imageScaleY == sy then  return  end

	self._imageScaleX = sx
	self._imageScaleY = sy
	if self._sprite then  scheduleLayoutUpdateIfDisplayed(self)  end
end
function Is.imageInclude:setImageScaleX(sx)
	!ARGS"2 sx:number"
	if self._imageScaleX == sx then  return  end

	self:setImageScale(sx, self._imageScaleY)
	if self._sprite then  scheduleLayoutUpdateIfDisplayed(self)  end
end
function Is.imageInclude:setImageScaleY(sy)
	!ARGS"2 sy:number"
	if self._imageScaleY == sy then  return  end

	self:setImageScale(self._imageScaleY, sy)
	if self._sprite then  scheduleLayoutUpdateIfDisplayed(self)  end
end



-- spriteName|nil = imageIncludeElement:getSprite( )
function Is.imageInclude:getSprite()
	return self._spriteName
end

-- imageIncludeElement:setSprite( image [, quad ] )
-- imageIncludeElement:setSprite( image, frames )
-- imageIncludeElement:setSprite( spriteName )
-- imageIncludeElement:setSprite( nil ) -- Remove sprite.
-- frames = { frame1, ... }
-- frame  = { duration=duration, quad=quad }
function Is.imageInclude:setSprite(imageOrName, framesOrQuad)
	!ARGS"2 imageOrName:userdata,string,nil"

	local image      = nil
	local spriteName = ""

	if type(imageOrName) == "string" then
		spriteName = imageOrName
		if spriteName ~= "" and spriteName == self._spriteName then  return  end

		local spriteLoader = self._gui._spriteLoader
		if not spriteLoader then
			printerr(2, "There is no sprite loader to convert the sprite name %q to a sprite.", spriteName)
			return
		end

		image, framesOrQuad = spriteLoader(spriteName)
		if not image then
			printerr(2, "The sprite loader did not return a required image for sprite name %q.", spriteName)
			return
		end

	elseif imageOrName then
		!ARGS"2 imageOrName:* framesOrQuad:userdata,table,nil"
		image = imageOrName
	end

	local oldIw, oldIh = 0, 0
	if self._sprite then
		oldIw, oldIh = self._sprite.width, self._sprite.height
	end

	self._sprite     = image and newSprite(image, framesOrQuad)
	self._spriteName = spriteName

	local iw, ih = 0, 0
	if self._sprite then
		iw, ih = self._sprite.width, self._sprite.height
	end

	if not (iw == oldIw and ih == oldIh) then
		scheduleLayoutUpdateIfDisplayed(self)
	end
end

-- bool = imageIncludeElement:hasSprite( )
function Is.imageInclude:hasSprite()
	return (self._sprite ~= nil)
end



--==============================================================
--= Element class (abstract) ===================================
--==============================================================



Cs.element = newElementClass("GuiElement", nil, {}, {
	--[[STATIC]] _events = {--[[ event1, [event1]=true, ... ]]},

	-- Parameters.
	_id   = "",
	_data = nil,

	_hidden   = false,
	_floating = false, -- Disables natural positioning in certain parents (e.g. bars).
	_closable = false,

	_captureInput    = false, -- All input.
	_captureGuiInput = false, -- All input affecting GUI.

	_width  = -1, -- Negative means dynamic.
	_height = -1,

	_minWidth  = 0,
	_minHeight = 0,

	_x = 0, -- Offset from the origin.
	_y = 0,

	_originX = 0.0, -- Where in the parent to base x and y off.
	_originY = 0.0,

	_anchorX = 0.0, -- Where in self to base off x and y.
	_anchorY = 0.0,

	_spacing           = 0,
	_spacingVertical   = nil, -- Falls back to _spacing.
	_spacingHorizontal = nil, -- Falls back to _spacing.
	_spacingTop        = nil, -- Falls back to _spacingVertical.
	_spacingRight      = nil, -- Falls back to _spacingHorizontal.
	_spacingBottom     = nil, -- Falls back to _spacingVertical.
	_spacingLeft       = nil, -- Falls back to _spacingHorizontal.

	_background = "",
	_style      = "",
	_tags       = nil,

	_mouseCursor = nil, -- cursor|systemCursorType|nil
	_sounds      = nil,

	_tooltip            = "",
	_unprocessedTooltip = "",
	--

	_automaticId = false,

	_timeBecomingVisible = 0.00,

	_callbacks  = nil,
	_animations = nil,

	_gui    = nil,
	_parent = nil,

	_layoutInnerWidth  = 0,
	_layoutInnerHeight = 0,

	_layoutOffsetX          = 0.0, -- Sum of parents' scrolling.
	_layoutOffsetY          = 0.0,
	_layoutImmediateOffsetX = 0, -- Sum of parents' scrolling, excluding smooth scrolling.
	_layoutImmediateOffsetY = 0,

	_layoutWidth  = 0,
	_layoutHeight = 0,

	_layoutX = 0,
	_layoutY = 0,

	data = nil, -- Alias for _data.
}, {
	"beforedraw"   , --            function( element, event, x, y, w, h )
	"afterdraw"    , --            function( element, event, x, y, w, h )

	"close"        , -- suppress = function( element, event )
	"closed"       , --            function( element, event )

	"focused"      , --            function( element, event )
	"blurred"      , --            function( element, event )

	"init"         , --            function( element, event )

	"keypressed"   , -- suppress = function( element, event, key, scancode, isRepeat )

	"layout"       , --            function( element, event )

	"mousepressed" , --            function( element, event, mx, my, mbutton, pressCount )
	"mousemoved"   , --            function( element, event, mx, my )
	"mousereleased", --            function( element, event, mx, my, mbutton, pressCount )

	"navigated"    , --            function( element, event )

	"pressed"      , --            function( element, event )

	"refresh"      , --            function( element, event )

	"show"         , --            function( element, event )
	"hide"         , --            function( element, event )

	"textinput"    , -- suppress = function( element, event, text )

	"update"       , --            function( element, event, deltaTime )

	"wheelmoved"   , -- suppress = function( element, event, dx, dy )
})

function Cs.element:init(gui, elData, parent)
	self._gui    = gui or error("Missing gui object argument.")
	self._parent = parent

	self._animations = {}
	self._callbacks  = {}

	local styleName = elData.style

	if styleName then
		local styleData = gui._styles[styleName] or errorf("No style with name '%s' exist.", styleName)
		applyStyle(elData, styleData)
		self._style = styleName
	end

	retrieve(self, elData, "_anchorX", "_anchorY")
	retrieve(self, elData, "_background")
	retrieve(self, elData, "_captureInput", "_captureGuiInput")
	retrieve(self, elData, "_closable")
	-- retrieve(self, elData, "_data")
	retrieve(self, elData, "_floating")
	retrieve(self, elData, "_hidden")
	retrieve(self, elData, "_id")
	retrieve(self, elData, "_minWidth", "_minHeight")
	-- retrieve(self, elData, "_mouseCursor")
	retrieve(self, elData, "_originX", "_originY")
	-- retrieve(self, elData, "_sounds")
	retrieve(self, elData, "_spacing", "_spacingVertical", "_spacingHorizontal")
	retrieve(self, elData, "_spacingTop", "_spacingRight", "_spacingBottom", "_spacingLeft")
	-- retrieve(self, elData, "_style")
	-- retrieve(self, elData, "_tags")
	-- retrieve(self, elData, "_tooltip")
	retrieve(self, elData, "_width", "_height")
	retrieve(self, elData, "_x", "_y")

	self._timeBecomingVisible = gui._time

	-- Set data table.
	@@ASSERT(elData.data == nil or type(elData.data) == "table")
	self._data = elData.data or {}
	self.data  = self._data -- element.data is exposed for easy access.

	-- Make sure the element has an ID.
	if self._id == "" then
		local numId          = gui._lastAutomaticId + 1
		gui._lastAutomaticId = numId
		self._id             = "__"..numId
		self._automaticId    = true
	end

	-- Set sounds table.
	self._sounds = {}
	if elData.sounds ~= nil then
		@@ASSERT(type(elData.sounds) == "table")
		for soundK, sound in pairs(elData.sounds) do
			checkValidSoundKey(soundK, 2)
			self._sounds[soundK] = sound
		end
	end

	-- Add tags.
	self._tags = {}
	if elData.tags ~= nil then
		@@ASSERT(type(elData.tags) == "table")
		for _, tag in ipairs(elData.tags) do
			self._tags[tag] = true
		end
	end

	if elData.mouseCursor ~= nil then  self:setMouseCursor(elData.mouseCursor)  end
	if elData.tooltip     ~= nil then  self:setTooltip(elData.tooltip)          end

	-- Set initial offset.
	if parent then
		self._layoutImmediateOffsetX = parent._layoutImmediateOffsetX + parent._scrollX
		self._layoutImmediateOffsetY = parent._layoutImmediateOffsetY + parent._scrollY
		self._layoutOffsetX          = parent._layoutOffsetX          + parent._visualScrollX
		self._layoutOffsetY          = parent._layoutOffsetY          + parent._visualScrollY
	end

	-- The 'here' debug attribute prints the path to the element.
	if elData.here then  table.insert(gui._heres, self)  end

	if elData.debug then  gui.debug = true  end
end



-- INTERNAL  element:_update( deltaTime )
function Cs.element:_update(dt)
	-- void
end



-- INTERNAL  element:_draw( )
function Cs.element:_draw()
	local x, y, w, h = xywh(self)

	if not self._gui.debug then
		triggerIncludingAnimations(self, "beforedraw", x, y, w, h)
	end

	drawLayoutBackground(self)

	if not self._gui.debug then
		triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
	end
end

-- INTERNAL  element:_drawDebug( red, green, blue [, backgroundOpacity=1 ] )
function Cs.element:_drawDebug(r, g, b, bgOpacity)
	local gui = self._gui
	if not gui.debug then  return  end

	local isContainer = self:is(Cs.container)

	local x, y, w, h = xywh(self)
	local innerW, innerH = self._layoutInnerWidth, self._layoutInnerHeight
	local padding = (isContainer and self._padding or 0)
	local lw = math.max(padding, 1)

	local sbW = themeGet(gui, "scrollbarWidth")

	if self:isKeyboardFocus() then
		r, g, b = 1, 1, 0
	elseif self:isNavigationTarget() then
		r, g, b = 1, 1, 1
	end

	$LG.push("all")

	$LG.translate(x, y)

	-- Background and center line
	setColor(r, g, b, .24*(bgOpacity or 1))
	$LG.rectangle("fill", 0, 0, w, h)
	$LG.line(padding, padding, w/2, h/2)

	-- Border
	$LG.setLineWidth(lw)
	setColor(r, g, b, .4)
	$LG.rectangle("line", lw/2, lw/2, w-lw, h-lw)
	if isContainer then
		if self:hasScrollbarOnRight()  then  $LG.rectangle("fill", w-lw-sbW, lw, sbW, h-2*lw)  end
		if self:hasScrollbarOnBottom() then  $LG.rectangle("fill", lw, h-lw-sbW, w-w*lw, sbW)  end
	end
	$LG.setLineWidth(1)
	setColor(r, g, b, .6)
	$LG.rectangle("line", 0.5, 0.5, w-1, h-1)

	-- Info
	r, g, b = lerp(r, 1, 0.5), lerp(g, 1, 0.5), lerp(b, 1, 0.5)
	$LG.setFont(gui._font or getDefaultFont())
	setColor(r, g, b, .8)
	if self._automaticId then
		$LG.print(F("%d.%d"   , self:getDepth(), (self:getIndex() or 0)          ), 2, 1)
	else
		$LG.print(F("%d.%d:%s", self:getDepth(), (self:getIndex() or 0), self._id), 2, 1)
	end

	$LG.pop()
end

-- INTERNAL  element:_drawTooltip( )
function Cs.element:_drawTooltip()
	local gui  = self._gui
	local text = self._tooltip

	if text == "" or gui._tooltipTime < gui.TOOLTIP_DELAY then  return  end

	local root = gui._root

	local font         = gui._font or getDefaultFont()
	local textW, textH = getTextDimensions(font, text, 1/0)

	local w, h = themeGetSize(self, "tooltip", textW, textH) -- @Speed: Get tooltip size when tooltip text changes.

	local x = math.max(math.min(self._layoutX+self._layoutImmediateOffsetX, root._width-w), 0)
	local y = self._layoutY + self._layoutHeight + self._layoutImmediateOffsetY

	if y+h > root._height then
		y = math.max(y-h-self._layoutHeight, 0)
	end

	themeRenderOnScreen(self, "tooltip", x, y, w, h, text, textW, textH, gui._tooltipTime-gui.TOOLTIP_DELAY)
end



--
-- element:animate( duration, [ lockInteraction=false, ] callbackTable )
-- callbackTable = { [event1]=callback, ... }
-- callback      = function( element, event, progress, ... ) -- Unlike in normal event callbacks there's an extra 'progress' argument before the rest of the arguments.
--
-- Example:
--     myGui:find("myButton"):animate(1, true, {
--         afterdraw = function(myButton, event, progress, x, y, w, h)
--             -- Fade in and out a green cover over the button.
--             setColor(0, 1, 0, .5+.5*math.sin(progress*math.pi))
--             love.graphics.rectangle("fill", x, y, w, h)
--         end,
--     })
--
function Cs.element:animate(duration, lockInteraction, callbacks)
	!ARGS"2 duration:number"

	if type(lockInteraction) == "table" then
		lockInteraction, callbacks = false, lockInteraction
	else
		!ARGS"2 duration:* lockInteraction:boolean callbacks,table"
	end

	local gui = self._gui

	local anim = {
		element         = self,
		lockInteraction = lockInteraction,
		callbacks       = callbacks,

		startTime       = gui._time,
		endTime         = gui._time+duration,
		duration        = duration,
	}

	table.insert(self._animations, anim)
	table.insert(gui._allAnimations, anim)

	if lockInteraction then
		gui._animationLockCount = gui._animationLockCount+1
	end
end



-- success = element:close( )
-- Trigger 'close' action, if possible.
function Cs.element:close()
	if not self:canClose() then
		return false
	end

	local preparedSound = prepareSound(self, "close")
	if trigger(self, "close") then
		return false -- Suppress default behavior.
	end

	preparedSound()
	self:hide()
	self:triggerBubbling("closed", self)

	return true
end

-- result = element:canClose( )
function Cs.element:canClose()
	return (self._closable and not self._gui._lockNavigation and self:isDisplayed())
end



-- bool = element:exists( )
function Cs.element:exists()
	return (self._parent ~= nil or self == self._gui._root)
end



-- anchorX, anchorY = element:getAnchor( )
-- anchor = element:getAnchorX( )
-- anchor = element:getAnchorY( )
function Cs.element:getAnchor()
	return self._anchorX, self._anchorY
end
function Cs.element:getAnchorX()
	return self._anchorX
end
function Cs.element:getAnchorY()
	return self._anchorY
end

-- element:setAnchor( anchorX, anchorY )
-- element:setAnchorX( anchor )
-- element:setAnchorY( anchor )
function Cs.element:setAnchor(anchorX, anchorY)
	if self._anchorX == anchorX and self._anchorY == anchorY then  return  end
	self._anchorX, self._anchorY = anchorY
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setAnchorX(anchor)
	if self._anchorX == anchor then  return  end
	self._anchorX = anchor
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setAnchorY(anchor)
	if self._anchorY == anchor then  return  end
	self._anchorY = anchor
	scheduleLayoutUpdateIfDisplayed(self)
end



-- callback|nil = element:getCallback( event )
function Cs.element:getCallback(event)
	return self._callbacks[event]
end

-- element:setCallback( event, callback|nil )
function Cs.element:setCallback(event, cb)
	!ARGS"2 event:string cb:function,nil"

	if not self._events[event] then
		printerr(2, "Unknown event '%s'. (%s)", event, self:getPathDescription())
		return
	end

	self._callbacks[event] = cb

	-- Since callbacks can only be attached to elements after the actual
	-- initialization has happened we instead trigger the init event here.
	if cb and event == "init" then
		trigger(self, "init")
	end
end

-- element:on( event, callback|nil )
-- Alias for element:setCallback().
Cs.element.on = Cs.element.setCallback

-- element:off( event )
function Cs.element:off(event)
	self:on(event, nil)
end

-- value = element:trigger( event [, extraArgument1, ... ] )
function Cs.element:trigger(event, ...)
	!ARGS"2 event:string"
	if not self._events[event] then
		printerr(2, "Unknown event '%s'. (%s)", event, self:getPathDescription())
		return nil
	end
	return trigger(self, event, ...)
end

-- value = element:triggerBubbling( event [, extraArgument1, ... ] )
function Cs.element.triggerBubbling(el, event, ...)
	!ARGS"2 event:string"

	if not el._events[event] then
		printerr(2, "Unknown event '%s'. (%s)", event, el:getPathDescription())
		return nil
	end

	local returnV = nil
	repeat
		returnV = trigger(el, event, ...)
		el      = el._parent
	until returnV or not el

	return returnV
end



-- closestElement|nil = element:getClosest( elementType )
-- Returns closest ancestor matching elementType (including self).
function Cs.element.getClosest(el, elType)
	local C = requireElementClass(elType)
	repeat
		if el:is(C) then  return el  end
		el = el._parent
	until not el
	return nil
end



do
	!local MAX_ANGLE_DIFF = TAU/4

	local function _getClosestInDirection(navRoot, C, fromX, fromY, angle, ignoreCapture, elToIgnore)
		local closestEl      = nil
		local closestDistSqr = 1/0
		local closestAngDiff = 1/0

		for el in navRoot:traverseVisible() do
			if el ~= elToIgnore and el:is(C) then
				local x, y = el:getPositionOnScreen()
				x          = math.min(math.max(fromX, x+.01), x+el._layoutWidth -.01)
				y          = math.min(math.max(fromY, y+.01), y+el._layoutHeight-.01)

				local dx = x - fromX
				local dy = y - fromY

				local distSqr = dx*dx+dy*dy

				if distSqr <= closestDistSqr then
					local angDiff = math.atan2(dy, dx) - angle
					angDiff       = math.abs(math.atan2(math.sin(angDiff), math.cos(angDiff))) -- Normalize.

					if angDiff < !(MAX_ANGLE_DIFF) then
						closestEl      = el
						closestDistSqr = distSqr
						closestAngDiff = angDiff
					end
				end
			end

			if not ignoreCapture and (el._captureInput or el._captureGuiInput) then
				break
			end
		end

		return closestEl
	end

	-- otherElement|nil = element:getClosestInDirection( angle [, elementType="widget", ignoreInputCaptureState=false, ignoreConfinement=false ] )
	function Cs.element:getClosestInDirection(angle, elType, ignoreCapture, ignoreConfinement)
		!ARGS"2 angle:number ? elType:string ignoreCapture,ignoreConfinement:boolean"

		local C = elType and requireElementClass(elType) or Cs.widget

		local gui = self._gui
		updateLayoutIfNeeded(gui)

		local navRoot = (ignoreConfinement and gui._root or self:getNavigationRoot())

		local centerX, centerY = self:getLayoutCenterPosition()

		local fromX = centerX+self._layoutOffsetX+0.495*self._layoutWidth *math.cos(angle)
		local fromY = centerY+self._layoutOffsetY+0.495*self._layoutHeight*math.sin(angle)
		local closestEl = _getClosestInDirection(navRoot, C, fromX, fromY, angle, ignoreCapture, self)

		if not closestEl and not ignoreConfinement and navRoot._confineNavigation then
			fromX = centerX+self._layoutOffsetX-10000*math.cos(angle)
			fromY = centerY+self._layoutOffsetY-10000*math.sin(angle)
			closestEl = _getClosestInDirection(navRoot, C, fromX, fromY, angle, ignoreCapture, nil)
		end

		return closestEl
	end
end

do
	local function getNextOrPrevious(self, elType, ignoreCapture, usePrev)
		local C = elType and requireElementClass(elType) or Cs.widget

		local root = self._gui._root
		if not root or root._hidden then  return nil  end

		local foundSelf = false
		local lastMatch = nil

		for el in self:getNavigationRoot():traverseVisible() do
			-- Note: Remember that we're traversing backwards.

			local elIsValid = el:is(C)
			if elIsValid and usePrev and foundSelf then  return el  end

			foundSelf = (foundSelf or el == self)
			if not usePrev and foundSelf then
				return lastMatch -- May be nil.
			end

			if elIsValid then  lastMatch = el  end

			if not ignoreCapture and (el._captureInput or el._captureGuiInput) then
				break
			end

		end
		return nil
	end

	-- otherElement = element:getNext( [ elType="widget", ignoreInputCaptureState=false ] )
	function Cs.element:getNext(elType, ignoreCapture)
		return (getNextOrPrevious(self, elType, ignoreCapture, false))
	end

	-- otherElement = element:getPrevious( [ elType="widget", ignoreInputCaptureState=false ] )
	function Cs.element:getPrevious(elType, ignoreCapture)
		return (getNextOrPrevious(self, elType, ignoreCapture, true))
	end
end



-- value = element:getData( key )
-- Note: element:getData(k) is the same as element.data[k]
function Cs.element:getData(k)
	-- @Memory: We probably don't need _data to always be set, but we'd probably
	-- have to remove the element.data property and change some other things.
	return self._data[k]
end

-- element:setData( key, value )
-- Note: element:setData(key, value) is the same as element.data[key]=value
function Cs.element:setData(k, v)
	self._data[k] = v
end

-- oldDataTable = element:swapData( newDataTable )
function Cs.element:swapData(data)
	!ARGS"2 data:table"
	local oldData = self._data
	self._data    = data
	self.data     = data
	return oldData
end



-- width, height = element:getDimensions( )
-- width  = element:getWidth( )
-- height = element:getHeight( )
function Cs.element:getDimensions()
	return self._width, self._height
end
function Cs.element:getWidth()
	return self._width
end
function Cs.element:getHeight()
	return self._height
end

-- element:setDimensions( width, height )
-- element:setWidth( width )
-- element:setHeight( height )
function Cs.element:setDimensions(w, h)
	!ARGS"2 w,h:number"
	if self._width == w and self._height == h then  return  end
	self._width, self._height = w, h
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setWidth(w)
	!ARGS"2 w:number"
	if self._width == w then  return  end
	self._width = w
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setHeight(h)
	!ARGS"2 h:number"
	if self._height == h then  return  end
	self._height = h
	scheduleLayoutUpdateIfDisplayed(self)
end



-- gui = element:getGui( )
function Cs.element:getGui()
	return self._gui
end



-- time = element:getGuiTime( )
-- Alias for element:getGui():getTime().
function Cs.element:getGuiTime()
	return self._gui._time
end



-- id = element:getId( )
function Cs.element:getId()
	return self._id
end

-- bool = element:hasId( id [, id2, ... ] )
function Cs.element:hasId(id, ...)
	if self._id == id then
		return true
	elseif ... then
		return self:hasId(...)
	end
	return false
end



-- index|nil = element:getIndex( )
-- Get the child index in the parent, if there is a parent.
function Cs.element:getIndex()
	local parent = self._parent
	return (parent and parent:indexOf(self))
end

-- depth = element:getDepth( )
function Cs.element:getDepth()
	local depth, current = 0, self
	while true do
		current = current._parent
		if not current then
			return depth
		end
		depth = depth+1
	end
end



-- x, y, width, height = element:getLayout( )
function Cs.element:getLayout()
	updateLayoutIfNeeded(self._gui)
	return self._layoutX, self._layoutY, self._layoutWidth, self._layoutHeight
end

-- width, height = element:getLayoutDimensions( )
-- width  = element:getLayoutWidth( )
-- height = element:getLayoutHeight( )
function Cs.element:getLayoutDimensions()
	updateLayoutIfNeeded(self._gui)
	return self._layoutWidth, self._layoutHeight
end
function Cs.element:getLayoutWidth()
	updateLayoutIfNeeded(self._gui)
	return self._layoutWidth
end
function Cs.element:getLayoutHeight()
	updateLayoutIfNeeded(self._gui)
	return self._layoutHeight
end

-- x, y = element:getLayoutPosition( )
-- x = element:getLayoutX( )
-- y = element:getLayoutY( )
function Cs.element:getLayoutPosition()
	updateLayoutIfNeeded(self._gui)
	return self._layoutX, self._layoutY
end
function Cs.element:getLayoutX()
	updateLayoutIfNeeded(self._gui)
	return self._layoutX
end
function Cs.element:getLayoutY()
	updateLayoutIfNeeded(self._gui)
	return self._layoutY
end

-- x, y = element:getLayoutCenterPosition( )
function Cs.element:getLayoutCenterPosition()
	updateLayoutIfNeeded(self._gui)
	return self._layoutX + .5*self._layoutWidth,
	       self._layoutY + .5*self._layoutHeight
end



-- width, height = element:getMinDimensions( )
-- width  = element:getMinWidth( )
-- height = element:getMinHeight( )
function Cs.element:getMinDimensions()
	return self._minWidth, self._minHeight
end
function Cs.element:getMinWidth()
	return self._minWidth
end
function Cs.element:getMinHeight()
	return self._minHeight
end

-- element:setMinDimensions( width, height )
-- element:setMinWidth( width )
-- element:setMinHeight( height )
function Cs.element:setMinDimensions(w, h)
	w = math.max(w or 0, 0)
	h = math.max(h or 0, 0)
	if self._minWidth == w and self._minHeight == h then  return  end
	self._minWidth  = w
	self._minHeight = h
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setMinWidth(w)
	w = math.max(w or 0, 0)
	if self._minWidth == w then  return  end
	self._minWidth = w
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setMinHeight(h)
	h = math.max(h or 0, 0)
	if self._minHeight == h then  return  end
	self._minHeight = h
	scheduleLayoutUpdateIfDisplayed(self)
end



-- cursor|systemCursorType|nil = element:getMouseCursor( )
function Cs.element:getMouseCursor()
	return self._mouseCursor
end

-- cursor|nil = getResultingMouseCursor( )
function Cs.element:getResultingMouseCursor()
	local cur = self._mouseCursor
	if type(cur) ~= "string" then  return cur  end
	return $LM.getSystemCursor(cur)
end

-- element:setMouseCursor( cursor|systemCursorType|nil )
function Cs.element:setMouseCursor(cur)
	!ARGS"2 cur:userdata,string,nil"

	if type(cur) == "string" and not pcall($LM.getSystemCursor, cur) then
		errorf(2, "Invalid system cursor type '%s'.", cur)
	end

	self._mouseCursor = cur
end



-- x, y = element:getMousePosition( )
-- x = element:getMouseX( )
-- y = element:getMouseY( )
-- Get the mouse position relative the element.
-- Returns nil if the mouse position is unknown.
function Cs.element:getMousePosition()
	local gui = self._gui
	if gui._mouseX == !(MOUSE_POS_UNKNOWN) then  return nil  end
	local x, y = self:getPositionOnScreen()
	return gui._mouseX-x, gui._mouseY-y
end
function Cs.element:getMouseX()
	local x = self._gui._mouseX
	return x ~= !(MOUSE_POS_UNKNOWN) and x-self:getXOnScreen() or nil
end
function Cs.element:getMouseY()
	local y = self._gui._mouseY
	return y ~= !(MOUSE_POS_UNKNOWN) and y-self:getYOnScreen() or nil
end



-- originX, originY = element:getOrigin( )
-- origin = element:getOriginX( )
-- origin = element:getOriginY( )
function Cs.element:getOrigin()
	return self._originX, self._originY
end
function Cs.element:getOriginX()
	return self._originX
end
function Cs.element:getOriginY()
	return self._originY
end

-- element:setOrigin( originX, originY )
-- element:setOriginX( origin )
-- element:setOriginY( origin )
function Cs.element:setOrigin(originX, originY)
	if self._originX == originX and self._originY == originY then  return  end
	self._originX, self._originY = originX, originY
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setOriginX(originX)
	if self._originX == originX then  return  end
	self._originX = originX
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setOriginY(originY)
	if self._originY == originY then  return  end
	self._originY = originY
	scheduleLayoutUpdateIfDisplayed(self)
end



-- container|nil = element:getParent( )
function Cs.element:getParent()
	return self._parent
end

-- containers = element:getAllParents( )
-- Returns an array of parents, with the closest parent first.
function Cs.element.getAllParents(el)
	local parents = {} -- @Memory
	local i       = 0

	while true do
		el = el._parent
		if not el then  return parents  end

		i          = i + 1
		parents[i] = el
	end
end

-- bool = element:hasParent( parent )
-- Note: Checks all grandparents too.
function Cs.element.hasParent(el, parent)
	while true do
		el = el._parent
		if not el       then  return false  end
		if el == parent then  return true   end
	end
	return false
end

-- container = element:getParentWithId( id )
function Cs.element.getParentWithId(el, id)
	while true do
		el = el._parent
		if not el       then  return nil  end
		if el._id == id then  return el   end
	end
	return nil
end

-- bool = element:hasParentWithId( id )
function Cs.element:hasParentWithId(id)
	return self:getParentWithId() ~= nil
end

-- for index, container in element:parents( )
-- Iterate over parents, from parent to grandparent.
function Cs.element.parents(el)
	local i = 0

	return function()
		el = el._parent
		if not el then  return  end

		i = i + 1
		return i, el
	end
end

-- for index, container in element:parentsr( )
-- Iterate over parents in reverse, from grandparent to parent.
function Cs.element:parentsr()
	return ipairsr(self:getAllParents())
end

-- for index, element in element:lineageUp( )
-- Traverse from self to the grandest parent.
function Cs.element.lineageUp(el)
	local i = 0

	return function()
		if not el then  return  end

		local current = el

		i  = i + 1
		el = el._parent

		return i, current
	end
end



local parts = {}

-- description = element:getPathDescription( )
function Cs.element.getPathDescription(el)
	for i = 1, #parts do  parts[i] = nil  end

	while true do
		-- Note that we construct the description in reverse.
		if not el._automaticId then
			table.insert(parts, ")")
			table.insert(parts, el._id)
			table.insert(parts, "(")
		end

		table.insert(parts, el.__name:sub(4)) -- Remove the "Gui" prefix from the class name.

		local i = el:getIndex()
		if i then
			table.insert(parts, ":")
			table.insert(parts, i)
		end

		el = el._parent
		if not el then  break  end

		table.insert(parts, "/")
	end

	reverseArray(parts)
	return table.concat(parts)
end



-- x, y = element:getPosition( )
-- x = element:getX( )
-- y = element:getY( )
function Cs.element:getPosition()
	return self._x, self._y
end
function Cs.element:getX()
	return self._x
end
function Cs.element:getY()
	return self._y
end

-- element:setPosition( x, y )
-- element:setX( x )
-- element:setY( y )
function Cs.element:setPosition(x, y)
	if self._x == x and self._y == y then  return  end
	self._x, self._y = x, y
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setX(x)
	if self._x == x then  return  end
	self._x = x
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.element:setY(y)
	if self._y == y then  return  end
	self._y = y
	scheduleLayoutUpdateIfDisplayed(self)
end



-- x, y = element:getPositionOnScreen( [ ignoreSmoothScrolling=false ] )
-- x = element:getXOnScreen( [ ignoreSmoothScrolling=false ] )
-- y = element:getYOnScreen( [ ignoreSmoothScrolling=false ] )
function Cs.element:getPositionOnScreen(ignoreSmoothScrolling)
	updateLayoutIfNeeded(self._gui)
	if ignoreSmoothScrolling then
		return self._layoutX+self._layoutImmediateOffsetX, self._layoutY+self._layoutImmediateOffsetY
	else
		return self._layoutX+self._layoutOffsetX, self._layoutY+self._layoutOffsetY
	end
end
function Cs.element:getXOnScreen(ignoreSmoothScrolling)
	updateLayoutIfNeeded(self._gui)
	if ignoreSmoothScrolling then
		return self._layoutX+self._layoutImmediateOffsetX
	else
		return self._layoutX+self._layoutOffsetX
	end
end
function Cs.element:getYOnScreen(ignoreSmoothScrolling)
	updateLayoutIfNeeded(self._gui)
	if ignoreSmoothScrolling then
		return self._layoutY+self._layoutImmediateOffsetY
	else
		return self._layoutY+self._layoutOffsetY
	end
end



-- root|nil = element:getRoot( )
-- Note: Returns the root the element knows of, which itself may have been
-- removed from the GUI. So this function differs slightly from gui:getRoot().
function Cs.element.getRoot(el)
	repeat
		if el.class == Cs.root then  return el  end
		el = el._parent
	until not el
	return nil -- We've been removed from the root.
end

-- container = element:getNavigationRoot( )
function Cs.element:getNavigationRoot()
	local container = self._parent
	if not container then  return nil  end -- Should we allow returning self if we're a container?

	while container._parent do
		if container._confineNavigation then  return container  end
		container = container._parent
	end

	return container -- We've reached the top container we know of.
end



-- sibling = element:getSibling( offset )
-- getSibling(1) returns the next sibling etc.
function Cs.element:getSibling(offset)
	local i = self:getIndex()
	return i and self._parent[i+offset]
end



-- sound|nil = element:getSound( soundKey )
function Cs.element:getSound(soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	return self._sounds[soundK]
end

-- sound|nil = element:getResultingSound( soundKey )
function Cs.element:getResultingSound(soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)

	local sound = self._sounds[soundK]

	if sound == nil then
		for _, parent in self:parents() do
			sound = parent._sounds[soundK]
			if sound ~= nil then  break  end
		end
		if sound == nil and self._gui then
			sound = self._gui._defaultSounds[soundK]
		end
	end

	if sound == "" then  sound = nil  end -- Special case: An empty string intercepts the bubbling and tells that no sound should be played.

	return sound
end

-- element:setSound( soundKey, sound )
-- element:setSound( soundKey, nil ) -- Remove sound.
function Cs.element:setSound(soundK, sound)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	self._sounds[soundK] = sound
end



-- style = element:getStyle( )
function Cs.element:getStyle()
	return self._style
end

-- @Incomplete: Should there be a element:setStyle()?



-- duration = element:getTimeSinceBecomingVisible( )
function Cs.element:getTimeSinceBecomingVisible()
	return self._gui._time-self._timeBecomingVisible
end



-- tooltip = element:getTooltip( )
function Cs.element:getTooltip()
	return self._tooltip
end

-- element:setTooltip( text )
function Cs.element:setTooltip(unprocessedText)
	unprocessedText = tostring(unprocessedText == nil and "" or unprocessedText)

	local text = preprocessText(self._gui, unprocessedText, self, false)
	if self._tooltip == text then  return  end

	self._tooltip            = text
	self._unprocessedTooltip = unprocessedText
end

-- element:drawTooltip( x, y )
function Cs.element:drawTooltip(x, y)
	$LG.print(self._tooltip, x, y)
end



-- font = element:getTooltipFont( )
function Cs.element:getTooltipFont()
	return (self._gui._fontTooltip or getDefaultFont())
end

-- element:useTooltipFont( )
-- Tell LÖVE to use the tooltip font.
function Cs.element:useTooltipFont()
	$LG.setFont(self:getTooltipFont())
end



-- bool = element:hasTag( tag )
function Cs.element:hasTag(tag)
	return self._tags[tag] ~= nil -- @Memory: _tags probably don't need to be set at all times. :NilTagsTable
end

-- element:addTag( tag )
function Cs.element:addTag(tag)
	self._tags[tag] = true
end

-- element:removeTag( tag )
-- element:removeAllTags( )
function Cs.element:removeTag(tag)
	self._tags[tag] = nil
end
function Cs.element:removeAllTags()
	self._tags = {} -- @Memory :NilTagsTable
end

-- element:setTag( tag, bool )
function Cs.element:setTag(tag, state)
	if state then
		self:addTag(tag)
	else
		self:removeTag(tag)
	end
end



-- bool = element:isAt( x, y )
function Cs.element:isAt(x, y)
	updateLayoutIfNeeded(self._gui)

	x = x - self._layoutOffsetX
	y = y - self._layoutOffsetY

	return x >= self._layoutX
	   and y >= self._layoutY
	   and x <  self._layoutX + self._layoutWidth
	   and y <  self._layoutY + self._layoutHeight
end



-- handled, grabKeyboardFocus = element:_keypressed( key, scancode, isRepeat )
function Cs.element:_keypressed(key, scancode, isRepeat)
	return false, false
end

-- INTERNAL  element:_keyreleased( key, scancode )
function Cs.element:_keyreleased(key, scancode)
	-- void
end

-- handled = element:_textinput( text )
function Cs.element:_textinput(text)
	return false
end



-- handled, grabMouseFocus = element:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.element:_mousepressed(mx, my, mbutton, pressCount)
	return false, false
end

-- INTERNAL  element:_mousemoved( mouseX, mouseY )
function Cs.element:_mousemoved(mx, my)
	-- void
end

-- INTERNAL  element:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.element:_mousereleased(mx, my, mbutton, pressCount)
	-- void
end

-- handled = element:_wheelmoved( deltaX, deltaY )
function Cs.element:_wheelmoved(dx, dy)
	return false
end



-- bool = element:isDisplayed( )
-- Returns true if the element and its parents are visible (and the element exists).
function Cs.element.isDisplayed(el)
	if not el:exists() then  return false  end
	repeat
		if el._hidden then  return false  end
		el = el._parent
	until not el
	return true
end

-- hiddenElement|nil = element:getClosestHiddenElement( )
-- hiddenElement|nil = element:getFarthestHiddenElement( )
function Cs.element:getClosestHiddenElement()
	local el = self
	repeat
		if el._hidden then  return el  end
		el = el._parent
	until not el
	return nil
end
function Cs.element:getFarthestHiddenElement()
	local el, hiddenEl = self, nil
	repeat
		if el._hidden then  hiddenEl = el  end
		el = el._parent
	until not el
	return hiddenEl
end



-- bool = element:isFirst( )
-- bool = element:isLast( )
function Cs.element:isFirst()
	return (not self._parent or self:getIndex() == 1)
end
function Cs.element:isLast()
	local parent = self._parent
	return (not parent or self:getIndex() == #parent)
end



-- bool = element:isHidden( )
-- bool = element:isVisible( )
function Cs.element:isHidden()
	return self._hidden
end
function Cs.element:isVisible()
	return (not self._hidden)
end

-- stateChanged = element:setHidden( bool )
function Cs.element:setHidden(hidden)
	!ARGS"2 hidden:boolean"
	if self._hidden == hidden then  return false  end

	local wasDisplayed = self:isDisplayed()
	self._hidden       = hidden
	local isDisplayed  = self:isDisplayed()
	local gui          = self._gui

	if wasDisplayed or isDisplayed then
		if wasDisplayed then  validateNavigationTarget(gui)  end

		gui._layoutNeedsUpdate = true

		if isDisplayed then
			local time = gui._time

			self._timeBecomingVisible = time

			if self:is(Cs.container) then
				for el in self:traverseVisible() do
					el._timeBecomingVisible = time
				end
			end

		end
	end

	trigger(self, (hidden and "hide" or "show"))
	return true
end

-- stateChanged = element:setVisible( bool )
function Cs.element:setVisible(visible)
	return self:setHidden(not visible)
end

-- stateChanged = element:show( )
-- stateChanged = element:hide( )
-- stateChanged = element:toggleHidden( )
function Cs.element:show()
	return self:setHidden(false)
end
function Cs.element:hide()
	return self:setHidden(true)
end
function Cs.element:toggleHidden()
	return self:setHidden(not self._hidden)
end



-- bool = element:isHovered( [ ignoreMouseFocus=false ] )
function Cs.element:isHovered(ignoreMouseFocus)
	local gui = self._gui
	updateLayoutIfNeeded(gui) -- Updates hovered element.
	return self == gui._hoveredElement and (ignoreMouseFocus or self == (gui._mouseFocus or self))
end



-- bool = element:isMouseFocus( )
-- bool = element:isKeyboardFocus( )
function Cs.element:isMouseFocus()
	return self == self._gui._mouseFocus
end
function Cs.element:isKeyboardFocus()
	return self == self._gui._keyboardFocus
end



-- bool = element:isNavigationTarget( )
function Cs.element:isNavigationTarget()
	return (self == self._gui._navigationTarget)
end



-- bool = element:isScrollbarXHovered( )
-- bool = element:isScrollbarYHovered( )
function Cs.element:isScrollbarXHovered()
	local gui  = self._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local x1, y1 = self:getPositionOnScreen()
	local x2, y2 = x1+self:getChildAreaWidth(), y1+self._layoutHeight
	y1           = y2 - themeGet(self._gui, "scrollbarWidth")

	return (x >= x1 and x < x2 and y >= y1 and y < y2)
end
function Cs.element:isScrollbarYHovered()
	local gui  = self._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local x1, y1 = self:getPositionOnScreen()
	local x2, y2 = x1+self._layoutWidth, y1+self:getChildAreaHeight()
	x1           = x2 - themeGet(self._gui, "scrollbarWidth")

	return (x >= x1 and x < x2 and y >= y1 and y < y2)
end

-- bool = element:isScrollbarXHandleHovered( )
-- bool = element:isScrollbarYHandleHovered( )
function Cs.element:isScrollbarXHandleHovered()
	local gui  = self._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local handlePos, handleLen = self:getScrollHandleX()
	local x1, y1               = self:getPositionOnScreen()

	x1       = x1 + handlePos
	local x2 = x1 + handleLen

	local y2 = y1 + self._layoutHeight
	y1       = y2 - themeGet(self._gui, "scrollbarWidth")

	return x >= x1 and x < x2 and y >= y1 and y < y2
end
function Cs.element:isScrollbarYHandleHovered()
	local gui  = self._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local handlePos, handleLen = self:getScrollHandleY()
	local x1, y1               = self:getPositionOnScreen()

	local x2 = x1 + self._layoutWidth
	x1       = x2 - themeGet(self._gui, "scrollbarWidth")

	y1       = y1 + handlePos
	local y2 = y1 + handleLen

	return x >= x1 and x < x2 and y >= y1 and y < y2
end



-- bool = element:isScrollingX( )
-- bool = element:isScrollingY( )
function Cs.element:isScrollingX()
	return self._mouseScrollDirection == "x"
end
function Cs.element:isScrollingY()
	return self._mouseScrollDirection == "y"
end



-- bool = element:isSolid( )
-- If the element has collision or not.
function Cs.element:isSolid()
	return false
end



-- bool = element:isType( elementType )
function Cs.element:isType(elType)
	return self:is(requireElementClass(elType))
end



-- element:playSound( soundKey )
function Cs.element:playSound(soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)

	local soundPlayer = self._gui   and self._gui._soundPlayer
	local sound       = soundPlayer and self:getResultingSound(soundK)

	if sound ~= nil then  soundPlayer(sound)  end
end



-- element:refresh( )
-- Trigger helper event "refresh".
function Cs.element:refresh()
	trigger(self, "refresh")
end



-- handled = element:_ok( )
function Cs.element:_ok()
	return false
end



-- element:remove( )
-- Remove element from parent.
function Cs.element:remove()
	local parent = self._parent
	if parent then
		parent:removeAt(parent:indexOf(self))
	end
end



-- element:reprocessTexts( )
-- Manually re-preprocess texts. Also see gui:reprocessTexts().
function Cs.element:reprocessTexts()
	self:setTooltip(self._unprocessedTooltip)
end



-- element:scrollIntoView( )
function Cs.element.scrollIntoView(el)
	updateLayoutIfNeeded(el._gui)

	local sbW     = themeGet(el._gui, "scrollbarWidth")
	local navSize = themeGet(el._gui, "navigationSize")

	local x1, y1 = el:getPositionOnScreen(true)
	local x2, y2 = x1+el._layoutWidth, y1+el._layoutHeight

	x1, y1 = x1-navSize, y1-navSize
	x2, y2 = x2+navSize, y2+navSize

	-- @Incomplete: navSize should probably be applied in places here below,
	-- (though it only matters if there are scrollables inside scrollables).

	repeat
		local parent = el._parent
		local maxW   = parent._maxWidth
		local maxH   = parent._maxHeight

		if maxW >= 0 or maxH >= 0 then
			local scrollX = parent._scrollX
			local scrollY = parent._scrollY

			if maxW >= 0 then
				local distOutside = parent:getXOnScreen(true) - x1
				if distOutside >= 0 then
					scrollX = scrollX + distOutside
				else
					distOutside = x2 - (parent:getXOnScreen(true) + maxW - (maxH >= 0 and sbW or 0))
					if distOutside > 0 then  scrollX = scrollX - distOutside  end
				end
				x1 = el:getXOnScreen(true)
				x2 = x1 + el._layoutWidth
			end

			if maxH >= 0 then
				local distOutside = parent:getYOnScreen(true) - y1
				if distOutside >= 0 then
					scrollY = scrollY + distOutside
				else
					distOutside = y2 - (parent:getYOnScreen(true) + maxH - (maxW >= 0 and sbW or 0))
					if distOutside > 0 then  scrollY = scrollY - distOutside  end
				end
				y1 = el:getYOnScreen(true)
				y2 = y1 + el._layoutHeight
			end

			parent:setScroll(scrollX, scrollY)
		end

		el, parent = parent, parent._parent
	until not parent
end



-- element:setScissor( relativeX, relativeY, width, height [, ignoreParentScrollables=false ] )
-- element:setScissor( ) -- Only applies scissors from parent scrollables.
-- Helper function for themes' drawing functions.
-- Note that each call replaces the previous scissor.
function Cs.element:setScissor(x, y, w, h, ignoreScrollables)
	local gui = self._gui

	self:unsetScissor()

	if x then
		setScissor(gui, self:getXOnScreen()+x, self:getYOnScreen()+y, w, h)
		gui._elementScissorIsSet = true
	end

	if not ignoreScrollables then
		local parent = self._parent
		while parent do

			if not parent then  break  end

			if parent:hasAnyScrollbar() then
				local parentX, parentY = parent:getPositionOnScreen()

				if not gui._elementScissorIsSet then
					setScissor(gui, parentX, parentY, parent:getChildAreaDimensions())
					gui._elementScissorIsSet = true
				else
					intersectScissor(self._gui, parentX, parentY, parent:getChildAreaDimensions())
				end

			end

			parent = parent._parent
		end
	end
end

-- element:unsetScissor( )
-- Remove scissor set by element:setScissor().
-- Helper function for themes' drawing functions.
function Cs.element:unsetScissor()
	local gui = self._gui
	if gui._elementScissorIsSet then
		setScissor(gui, nil)
		gui._elementScissorIsSet = false
	end
end



-- menuElement = element:showMenu( items, [ highlightedIndex,   ] [ offsetX=0, offsetY=0, ] callback )
-- menuElement = element:showMenu( items, [ highlightedIndices, ] [ offsetX=0, offsetY=0, ] callback )
-- items       = { itemText1, ... }
-- items       = { { itemText1, itemExtraText1 }, ... }
-- callback    = function( index, itemText ) -- 'index' will be 0 if no item was chosen.
function Cs.element:showMenu(items, hlIndices, offsetX, offsetY, cb)
	!ARGS"2 items:table"

	-- showMenu( items, highlightedIndex,   offsetX, offsetY, callback )
	-- showMenu( items, highlightedIndices, offsetX, offsetY, callback )
	if (type(hlIndices) == "number" or type(hlIndices) == "table") and type(offsetX) == "number" and type(offsetY) == "number" then
		-- void

	-- showMenu( items, offsetX, offsetY, callback )
	elseif (type(hlIndices) == "number" or type(hlIndices) == "table") and type(offsetX) == "number" then
		hlIndices, offsetX, offsetY, cb = nil, hlIndices, offsetX, offsetY

	-- showMenu( items, highlightedIndex,   callback )
	-- showMenu( items, highlightedIndices, callback )
	elseif type(hlIndices) == "number" or type(hlIndices) == "table" then
		offsetX, offsetY, cb = 0, 0, offsetX

	-- showMenu( items, callback )
	else
		hlIndices, offsetX, offsetY, cb = nil, 0, 0, hlIndices

	end
	if type(cb) ~= "function" then
		error("Missing callback argument.", 2)
	end

	if type(hlIndices) == "number" then
		hlIndices = {hlIndices}
	end


	local gui  = self._gui
	local root = self:getRoot()

	updateLayoutIfNeeded(gui) -- So we get the correct self size and position here below.

	-- Create menu.

	local menu = root:insert{
		type="container", style="_MENU", expandX=true, expandY=true,
		closable=true, captureGuiInput=true, confineNavigation=true,
		[1] = {type="vbar", minWidth=self._layoutWidth, maxHeight=root._height},
	}

	menu:on("closed", function(button, event)
		local _cb = cb
		cb        = nil

		menu:remove()

		if _cb then  _cb(0, "")  end
	end)

	menu:on("mousepressed", function(button, event, mx, my, mbutton, pressCount)
		menu:close()
	end)

	-- Add menu items.
	local buttons = menu[1]

	for i, text in ipairs(items) do
		local text2 = nil
		if type(text) == "table" then  text, text2 = unpack(text)  end

		local isToggled = (hlIndices ~= nil and indexOf(hlIndices, i) ~= nil)
		local button = buttons:insert{ type="button", text=text, text2=text2, align="left", toggled=isToggled }

		button:on("mousepressed", function(button, event, mx, my, mbutton, pressCount)
			if mbutton == 1 then  button:press()  end
			return true -- Prevent the menu from receiving the mousepressed event.
		end)

		button:on("press", function(button, event)
			local _cb = cb
			cb = nil

			menu:remove()

			if _cb then  _cb(i, text)  end
		end)

		button:on("navigated", function(button, event)
			buttons:setToggledChild(button._id)
		end)
	end

	local searchTerm       = ""
	local searchStartIndex = 1
	local lastInputTime    = -99

	if gui._standardKeysAreActive then
		menu:on("keypressed", function(button, event, key, scancode, isRepeat)
			if key == "up" then
				local button     = buttons:getToggledChild()
				searchStartIndex = button and (button:getIndex()-2)%#buttons+1 or 1
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "down" then
				local button     = buttons:getToggledChild()
				searchStartIndex = button and button:getIndex()%#buttons+1 or 1
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "home" or key == "pageup" then
				searchStartIndex = 1
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "end" or key == "pagedown" then
				searchStartIndex = #buttons
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "return" or key == "kpenter" then
				local button = buttons:getToggledChild()
				if button then  button:press()  end
				return true

			end
		end)
	end

	menu:on("textinput", function(button, event, text)
		-- Append to old or start a new term.
		local time = gui._time
		if time-lastInputTime > 1.00 then
			searchTerm       = text:lower()
			local button     = buttons:getToggledChild()
			searchStartIndex = button and button:getIndex() or 1
		else
			searchTerm = searchTerm..text:lower()
		end
		lastInputTime = time

		-- Pressing the same letter over and over should just cycle through all items starting with that letter.
		if #searchTerm > 1 then -- @Robustness: Use UTF-8 character length - not byte length!
			local firstChar = searchTerm:match!("^"..UTF8_CHAR_PATTERN)
			local reps      = #searchTerm / #firstChar

			if reps == math.floor(reps) and searchTerm == firstChar:rep(reps) then
				local i        = searchStartIndex
				local foundAny = false

				while true do
					i            = i % #buttons + 1
					local button = buttons[i]

					if button._text:lower():find(firstChar, 1, true) == 1 then
						reps     = reps - 1
						foundAny = true

						if reps <= 0 then
							gui:navigateTo(button)
							return
						end

					elseif i == searchStartIndex and not foundAny then
						return
					end
				end

			end
		end

		-- Otherwise search for the whole term.
		for i = 1, #buttons do
			i = (searchStartIndex+i-1)%#buttons+1
			local button = buttons[i]

			if button._text:lower():find(searchTerm, 1, true) == 1 then
				gui:navigateTo(button)
				break
			end
		end
	end)

	-- Set position.

	menu:_updateLayoutSize() -- Expanding and positioning of the whole menu isn't necessary right here.

	buttons:setPosition(
		math.max(math.min(self:getXOnScreen()+offsetX, root._width -buttons._layoutWidth ), 0),
		math.max(math.min(self:getYOnScreen()+offsetY, root._height-buttons._layoutHeight), 0)
	)

	local button = buttons:getToggledChild()
	if button then  gui:navigateTo(button)  end

	return menu
end



-- FINAL  element:updateLayout( )
-- Force a layout update. (Should never be needed as it's done automatically.)
-- Also see gui:updateLayout().
function Cs.element:updateLayout()
	return updateLayout(self)
end

-- INTERNAL  element:_updateLayoutSize( )
function Cs.element:_updateLayoutSize()
	-- void (subclasses should replace this method)
end

-- INTERNAL  element:_expandLayout( expandWidth|nil, expandHeight|nil )
function Cs.element:_expandLayout(expandW, expandH)
	if expandW then
		self._layoutWidth = expandW
		self._layoutInnerWidth = self._layoutWidth
	end
	if expandH then
		self._layoutHeight = expandH
		self._layoutInnerHeight = self._layoutHeight
	end
end

-- INTERNAL  element:_updateLayoutPosition( )
function Cs.element:_updateLayoutPosition()
	-- void (position is always set by the parent container)
end



--==============================================================
--= Container element class ====================================
--==============================================================



Cs.container = newElementClass("GuiContainer", Cs.element, {}, {
	SCROLL_SMOOTHNESS = 0.65,

	SCROLL_SPEED_X = 30,
	SCROLL_SPEED_Y = 50,

	-- Parameters.
	_confineNavigation = false,
	_solid             = false,

	_padding = 0,

	_maxWidth  = -1, -- Negative means no limit.
	_maxHeight = -1,

	_expandX = false,
	_expandY = false,
	--

	_mouseScrollDirection = "", -- "" | "x" | "y"
	_mouseScrollOffset    = 0,

	_scrollX = 0.0,
	_scrollY = 0.0,

	_visualScrollX = 0.0,
	_visualScrollY = 0.0,
}, {
	-- void
})

function Cs.container:init(gui, elData, parent)
	Cs.container.super.init(self, gui, elData, parent)

	retrieve(self, elData, "_confineNavigation")
	retrieve(self, elData, "_expandX", "_expandY")
	retrieve(self, elData, "_maxWidth", "_maxHeight")
	retrieve(self, elData, "_padding")
	retrieve(self, elData, "_solid")

	for i, childData in ipairs(elData) do
		local C     = Cs[getTypeFromElementData(childData)] or errorf("Bad GUI type '%s'.", getTypeFromElementData(childData))
		local child = C(gui, childData, self)
		self[i]     = child
	end
end



-- INTERNAL OVERRIDE  container:_update( deltaTime )
function Cs.container:_update(dt)
	Cs.container.super._update(self, dt)

	for _, child in ipairs(self) do
		child:_update(dt)
	end

	local scrollX = self._scrollX
	local scrollY = self._scrollY

	local visualScrollX = self._visualScrollX
	local visualScrollY = self._visualScrollY

	local didScroll = false

	if visualScrollX ~= scrollX then
		visualScrollX = scrollX+self.SCROLL_SMOOTHNESS*(visualScrollX-scrollX)
		if math.abs(visualScrollX-scrollX) < 0.5 then
			visualScrollX = scrollX
		end
		didScroll = true
	end

	if visualScrollY ~= scrollY then
		visualScrollY = scrollY+self.SCROLL_SMOOTHNESS*(visualScrollY-scrollY)
		if math.abs(visualScrollY-scrollY) < 0.5 then
			visualScrollY = scrollY
		end
		didScroll = true
	end

	if didScroll then
		setVisualScroll(self, visualScrollX, visualScrollY)
	end
end



-- INTERNAL REPLACE  container:_draw( )
function Cs.container:_draw()
	if self._hidden then  return  end

	local gui        = self._gui
	local x, y, w, h = xywh(self)

	local maxW      , maxH       = self._maxWidth, self._maxHeight
	local childAreaW, childAreaH = self:getChildAreaDimensions()

	local sbW    = themeGet(gui, "scrollbarWidth")
	local sbMinW = themeGet(gui, "scrollbarMinLength")

	if not self._gui.debug then
		triggerIncludingAnimations(self, "beforedraw", x, y, w, h)
	end

	drawLayoutBackground(self)
	self:_drawDebug(0, 0, 1)

	if maxW >= 0 or maxH >= 0 then
		setScissor(gui, x, y, childAreaW, childAreaH)
	end
	for _, child in ipairs(self) do
		child:_draw()
	end
	if maxW >= 0 or maxH >= 0 then
		setScissor(gui, nil)
	end

	if not self._gui.debug then
		-- Horizontal scrollbar.
		if maxW >= 0 then
			local handlePos, handleLen = self:getScrollHandleX()
			themeRenderArea(self, "scrollbar", 0, h-sbW, childAreaW, sbW, "x", round(handlePos), handleLen)
		end

		-- Vertical scrollbar.
		if maxH >= 0 then
			local handlePos, handleLen = self:getScrollHandleY()
			themeRenderArea(self, "scrollbar", w-sbW, 0, sbW, childAreaH, "y", round(handlePos), handleLen)
		end

		if maxW >= 0 and maxH >= 0 then
			themeRenderArea(self, "scrollbardeadzone", w-sbW, h-sbW, sbW, sbW)
		end

		triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
	end
end



-- element|nil = container:find( id )
function Cs.container:find(id)
	for el in self:traverse() do
		if el._id == id then
			return el
		end
	end
	return nil
end

-- elements = container:findAll( id )
function Cs.container:findAll(id)
	local els = {}
	for el in self:traverse() do
		if el._id == id then
			table.insert(els, el)
		end
	end
	return els
end

-- element|nil = container:findType( elementType )
function Cs.container:findType(elType)
	local C = requireElementClass(elType)

	for el in self:traverse() do
		if el:is(C) then  return el  end
	end

	return nil
end

-- widget|nil = container:findActive( )
function Cs.container:findActive()
	for el in self:traverse() do
		if el:is(Cs.widget) and el._active then  return el  end
	end
	return nil
end

-- button|nil = container:findToggled( )
function Cs.container:findToggled()
	for el in self:traverse() do
		if el:is(Cs.button) and el._toggled then  return el  end
	end
	return nil
end

-- element|nil = container:match( selector [, includeSelf=false ] )
-- selector    = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Match an element using a CSS-like selector.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Cs.container:match(selector, includeSelf)
	local selPath = parseSelector(selector)
	if not selPath then  return nil  end

	local breakElement = (not includeSelf and self or self._parent)
	if includeSelf and isElementMatchingSelectorPath(self, selPath, breakElement) then
		return self
	end

	for el in self:traverse() do
		if isElementMatchingSelectorPath(el, selPath, breakElement) then
			return el
		end
	end

	return nil
end

-- elements = container:matchAll( selector [, includeSelf=false ] )
-- selector = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Match elements using a CSS-like selector.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Cs.container:matchAll(selector, includeSelf)
	local elements = {}
	local selPath = parseSelector(selector)

	if selPath then
		local breakElement = (not includeSelf and self or self._parent)
		if includeSelf and isElementMatchingSelectorPath(self, selPath, breakElement) then
			table.insert(elements, self)
		end

		for el in self:traverse() do
			if isElementMatchingSelectorPath(el, selPath, breakElement) then
				table.insert(elements, el)
			end
		end
	end

	return elements
end



-- spaceX, spaceY = container:getInnerSpace( )
-- space = container:getInnerSpaceX( )
-- space = container:getInnerSpaceY( )
function Cs.container:getInnerSpace()
	local spaceX = 2*self._padding
	local spaceY = spaceX
	local sbW    = themeGet(self._gui, "scrollbarWidth")
	if self:hasScrollbarOnRight()  then  spaceX = spaceX+sbW  end
	if self:hasScrollbarOnBottom() then  spaceY = spaceY+sbW  end
	return spaceX, spaceY
end
function Cs.container:getInnerSpaceX()
	local spaceX = 2*self._padding
	if self:hasScrollbarOnRight() then
		spaceX = spaceX+themeGet(self._gui, "scrollbarWidth")
	end
	return spaceX
end
function Cs.container:getInnerSpaceY()
	local spaceY = 2*self._padding
	if self:hasScrollbarOnBottom() then
		spaceY = spaceY+themeGet(self._gui, "scrollbarWidth")
	end
	return spaceY
end



-- width, height = container:getMaxDimensions( )
-- width  = container:getMaxWidth( )
-- height = container:getMaxHeight( )
function Cs.container:getMaxDimensions()
	return self._maxWidth, self._maxHeight
end
function Cs.container:getMaxWidth()
	return self._maxWidth
end
function Cs.container:getMaxHeight()
	return self._maxHeight
end

-- container:setMaxDimensions( width, height )
-- container:setMaxWidth( width )
-- container:setMaxHeight( height )
-- Negative values remove restrictions.
function Cs.container:setMaxDimensions(w, h)
	!ARGS"2 w,h:number"
	if self._maxWidth == w and self._maxHeight == h then  return  end

	self._maxWidth  = w
	self._maxHeight = h
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.container:setMaxWidth(w)
	!ARGS"2 w:number"
	if self._maxWidth == w then  return  end

	self._maxWidth = w
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.container:setMaxHeight(h)
	!ARGS"2 h:number"
	if self._maxHeight == h then  return  end

	self._maxHeight = h
	scheduleLayoutUpdateIfDisplayed(self)
end



-- padding = container:getPadding( )
function Cs.container:getPadding()
	return self._padding
end

-- container:setPadding( padding )
function Cs.container:setPadding(padding)
	if self._padding == padding then
		return
	end
	self._padding = padding
	scheduleLayoutUpdateIfDisplayed(self)
end



-- x, y = container:getScroll( )
-- x = container:getScrollX( )
-- y = container:getScrollY( )
function Cs.container:getScroll()
	return self._scrollX, self._scrollY
end
function Cs.container:getScrollX()
	return self._scrollX
end
function Cs.container:getScrollY()
	return self._scrollY
end

-- scrollChanged = container:setScroll( x, y [, immediate=false ] )
function Cs.container:setScroll(scrollX, scrollY, immediate)
	!ARGS"2 scrollX,scrollY:number"
	updateLayoutIfNeeded(self._gui)

	-- Limit scrolling
	local limitX, limitY = self:getScrollLimit()
	scrollX = math.min(math.max(scrollX, limitX), 0)
	scrollY = math.min(math.max(scrollY, limitY), 0)
	local dx, dy = scrollX-self._scrollX, scrollY-self._scrollY
	if dx == 0 and dy == 0 then  return false  end

	self._scrollX, self._scrollY = scrollX, scrollY

	for el in self:traverse() do
		el._layoutImmediateOffsetX = el._layoutImmediateOffsetX+dx
		el._layoutImmediateOffsetY = el._layoutImmediateOffsetY+dy
	end

	if immediate then  setVisualScroll(self, scrollX, scrollY)  end

	if self:isDisplayed() then
		self:playSound("scroll") -- @Robustness: May have to add more limitations to whether "scroll" sound plays or not.
		updateHoveredElement(self._gui)
	end

	return true
end

-- scrollChanged = container:setScrollX( x [, immediate=false ] )
-- scrollChanged = container:setScrollY( y [, immediate=false ] )
function Cs.container:setScrollX(scrollX, immediate)
	return self:setScroll(scrollX, self._scrollY, immediate)
end
function Cs.container:setScrollY(scrollY, immediate)
	return self:setScroll(self._scrollX, scrollY, immediate)
end

-- scrollChanged = container:scroll( deltaX, deltaY [, immediate=false ] )
function Cs.container:scroll(dx, dy, immediate)
	return self:setScroll(self._scrollX+dx, self._scrollY+dy, immediate)
end

-- scrollChanged = container:updateScroll( [, immediate=false ] )
-- @Incomplete: Update scroll automatically when elements change size etc.
function Cs.container:updateScroll(immediate)
	return self:scroll(0, 0, immediate)
end



do
	local function getScrollHandle(self, childAreaSize, innerSize, scroll)
		local insideSize = (childAreaSize-2*self._padding)

		local handleLen = math.max(
			round(childAreaSize*insideSize/innerSize),
			themeGet(self._gui, "scrollbarMinLength"))

		local handlePos, handleMaxPos = 0, 0
		if innerSize > insideSize then
			handleMaxPos = childAreaSize-handleLen
			handlePos = -scroll*handleMaxPos/(innerSize-insideSize)
		end

		return handlePos, handleLen, handleMaxPos
	end

	-- @Incomplete: container:getScrollHandles()?

	-- position, length, maxPosition = container:getScrollHandleX( )
	-- position, length, maxPosition = container:getScrollHandleY( )
	-- Units are in pixels.
	function Cs.container:getScrollHandleX()
		updateLayoutIfNeeded(self._gui)
		return getScrollHandle(self, self:getChildAreaWidth(), self._layoutInnerWidth, self._scrollX)
	end
	function Cs.container:getScrollHandleY()
		updateLayoutIfNeeded(self._gui)
		return getScrollHandle(self, self:getChildAreaHeight(), self._layoutInnerHeight, self._scrollY)
	end
end



-- x, y = container:getScrollLimit( )
-- x = container:getScrollLimitX( )
-- y = container:getScrollLimitY( )
function Cs.container:getScrollLimit()
	local childAreaW, childAreaH = self:getChildAreaDimensions()
	return
		childAreaW-2*self._padding-self._layoutInnerWidth,
		childAreaH-2*self._padding-self._layoutInnerHeight
end
function Cs.container:getScrollLimitX()
	local childAreaW = self:getChildAreaWidth()
	return childAreaW-2*self._padding-self._layoutInnerWidth
end
function Cs.container:getScrollLimitY()
	local childAreaH = self:getChildAreaHeight()
	return childAreaH-2*self._padding-self._layoutInnerHeight
end



-- child = container:getVisibleChild( [ number=1 ] )
function Cs.container:getVisibleChild(n)
	n = (n or 1)
	for _, child in ipairs(self) do
		if not child._hidden then
			n = n - 1
			if n == 0 then  return child  end
		end
	end
	return nil
end

-- number = container:getVisibleChildNumber( child )
function Cs.container:getVisibleChildNumber(el)
	local n = 0
	for _, child in ipairs(self) do
		if not child._hidden then
			n = n + 1
			if child == el then  return n  end
		end
	end
	return nil
end

-- count = container:getVisibleChildCount( )
function Cs.container:getVisibleChildCount()
	local count = 0
	for _, child in ipairs(self) do
		if not child._hidden then  count = count + 1  end
	end
	return count
end

-- visibleChild = container:setVisibleChild( id )
-- If multiple children have the specified ID then the last one is returned.
-- @Cleanup: Rename to setVisibleChildById()? Maybe more functions should be changed too.
function Cs.container:setVisibleChild(id)
	local visibleChild = nil
	for _, child in ipairs(self) do
		if child._id == id then
			child:show()
			visibleChild = child
		else
			child:hide()
		end
	end
	return visibleChild
end



-- x, y = container:getVisualScroll( )
-- x = container:getVisualScrollX( )
-- y = container:getVisualScrollY( )
function Cs.container:getVisualScroll()
	return self._visualScrollX, self._visualScrollY
end
function Cs.container:getVisualScrollX()
	return self._visualScrollX
end
function Cs.container:getVisualScrollY()
	return self._visualScrollY
end



-- bool = hasAnyScrollbar( )
-- bool = hasScrollbarOnRight( )
-- bool = hasScrollbarOnBottom( )
function Cs.container:hasAnyScrollbar()
	return self:hasScrollbarOnRight() or self:hasScrollbarOnBottom()
end
function Cs.container:hasScrollbarOnRight()
	return self._maxHeight >= 0
end
function Cs.container:hasScrollbarOnBottom()
	return self._maxWidth >= 0
end



-- index|nil = container:indexOf( element )
-- Returns nil if the element isn't a child.
Cs.container.indexOf = indexOf



-- REPLACE  bool = container:isSolid( )
function Cs.container:isSolid()
	return self._solid or self._background ~= "" or self._maxWidth >= 0 or self._maxHeight >= 0
end



-- child, index = container:get( index )
-- child, index = container:get( id )
-- Note: container:get(index) is the same as container[index].
-- Returns nil if no child matches.
function Cs.container:get(iOrId)
	if type(iOrId) == "string" then
		for i, child in ipairs(self) do
			if child._id == iOrId then  return child, i  end
		end
		return nil
	else
		local child = self[iOrId]
		return child, (child and iOrId or nil)
	end
end

-- for index, child in container:children( )
function Cs.container:children()
	return ipairs(self)
end



-- width, height = container:getChildAreaDimensions( )
-- width  = container:getChildAreaWidth( )
-- height = container:getChildAreaHeight( )
function Cs.container:getChildAreaDimensions()
	updateLayoutIfNeeded(self._gui)
	local sbW = themeGet(self._gui, "scrollbarWidth")
	return
		(self._maxHeight >= 0 and self._layoutWidth -sbW or self._layoutWidth),
		(self._maxWidth  >= 0 and self._layoutHeight-sbW or self._layoutHeight)
end
function Cs.container:getChildAreaWidth()
	updateLayoutIfNeeded(self._gui)
	return
		self:hasScrollbarOnRight() and self._layoutWidth-themeGet(self._gui, "scrollbarWidth")
		or self._layoutWidth
end
function Cs.container:getChildAreaHeight()
	updateLayoutIfNeeded(self._gui)
	return
		self:hasScrollbarOnBottom() and self._layoutHeight-themeGet(self._gui, "scrollbarWidth")
		or self._layoutHeight
end



-- child|nil = container:getChildWithData( dataKey, dataValue )
function Cs.container:getChildWithData(k, v)
	for _, child in ipairs(self) do
		if child._data[k] == v then  return child  end
	end
	return nil
end



-- element|nil = container:getElementAt( x, y [, includeNonSolid=false ] )
function Cs.container:getElementAt(x, y, nonSolid)
	updateLayoutIfNeeded(self._gui)

	if self._maxWidth  >= 0 and (x < self._layoutX or x >= self._layoutX+self._layoutWidth ) then  return nil  end
	if self._maxHeight >= 0 and (y < self._layoutY or y >= self._layoutY+self._layoutHeight) then  return nil  end

	for el in self:traverseVisible(x, y) do
		if ((nonSolid or el:isSolid()) and el:isAt(x, y)) or (el._captureInput or el._captureGuiInput) then
			return el
		end
	end

	return nil
end



-- child = container:insert( elementData [, index=atEnd ] )
-- See gui:load() for the elementData format.
function Cs.container:insert(childData, i)
	!ARGS"2 childData:table ? i:number"

	local C     = Cs[getTypeFromElementData(childData)] or errorf("Bad element type '%s'.", getTypeFromElementData(childData))
	local child = C(self._gui, childData, self)
	table.insert(self, (i or #self+1), child)

	printHeres(self._gui)
	scheduleLayoutUpdateIfDisplayed(child)

	local themeInit = themeGet(self._gui, "init")
	themeInit(child)
	if child:is(Cs.container) then
		for el in child:traverse() do
			themeInit(el)
		end
	end

	validateNavigationTarget(self._gui)
	scheduleLayoutUpdateIfDisplayed(child)

	return child
end

-- REPLACE  container:removeAt( index )
-- Note that grandchildren are also removed from their parent. (Is this good?)
function Cs.container:removeAt(i)
	!ARGS"2 i:number"

	local child = self[i]
	if not child then
		printerr(2, "Child index %d is out of bounds.", i)
		return
	end

	if child:is(Cs.container) then
		child:empty()
	end

	-- Note: The child still keeps the reference to the GUI.
	child._parent = nil
	table.remove(self, i)

	validateNavigationTarget(self._gui)
	scheduleLayoutUpdateIfDisplayed(self)
end

-- container:empty( )
-- Note that children are also emptied recursively. (Is this good?)
function Cs.container:empty()
	for i = #self, 1, -1 do
		self:removeAt(i)
	end
end



-- INTERNAL REPLACE  handled, grabMouseFocus = container:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.container:_mousepressed(mx, my, mbutton, pressCount)
	if mbutton == 1 then
		local x0        , y0         = self:getPositionOnScreen()
		local childAreaW, childAreaH = self:getChildAreaDimensions()
		local sbW                    = themeGet(self._gui, "scrollbarWidth")

		-- Horizontal scrolling.
		----------------------------------------------------------------
		local x2, y2 = x0+childAreaW, y0+self._layoutHeight
		local x1, y1 = x0           , y2-sbW

		if mx >= x1 and mx < x2 and my >= y1 and my < y2 then
			local handlePos, handleLen, handleMaxPos = self:getScrollHandleX()

			self._mouseScrollDirection = "x"

			-- Drag handle.
			if mx >= x1+handlePos and mx < x1+handlePos+handleLen then
				self._mouseScrollOffset = mx-x1-handlePos

			-- Jump and drag.
			else
				self._mouseScrollOffset = handleLen/2
				self:_mousemoved(mx, my)
			end

			return true, true
		end

		-- Vertical scrolling.
		----------------------------------------------------------------
		local x2, y2 = x0+self._layoutWidth, y0+childAreaH
		local x1, y1 = x2-sbW              , y0

		if mx >= x1 and mx < x2 and my >= y1 and my < y2 then
			local handlePos, handleLen, handleMaxPos = self:getScrollHandleY()

			self._mouseScrollDirection = "y"

			-- Drag handle.
			if my >= y1+handlePos and my < y1+handlePos+handleLen then
				self._mouseScrollOffset = my-y1-handlePos

			-- Jump and drag.
			else
				self._mouseScrollOffset = handleLen/2
				self:_mousemoved(mx, my)
			end

			return true, true
		end

		----------------------------------------------------------------
	end

	return false, false
end

-- INTERNAL REPLACE  container:_mousemoved( mouseX, mouseY )
function Cs.container:_mousemoved(mx, my)
	-- Horizontal scrolling.
	if self._mouseScrollDirection == "x" then
		local _, _, handleMaxPos = self:getScrollHandleX()
		self:setScrollX((mx - self:getXOnScreen() - self._mouseScrollOffset) * self:getScrollLimitX() / handleMaxPos, true)

	-- Vertical scrolling.
	elseif self._mouseScrollDirection == "y" then
		local _, _, handleMaxPos = self:getScrollHandleY()
		self:setScrollY((my - self:getYOnScreen() - self._mouseScrollOffset) * self:getScrollLimitY() / handleMaxPos, true)
	end
end

-- INTERNAL REPLACE  container:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.container:_mousereleased(mx, my, mbutton, pressCount)
	if mbutton == 1 then
		self._mouseScrollDirection = ""
		self._mouseScrollOffset    = 0
	end
end

-- INTERNAL REPLACE  handled = container:_wheelmoved( deltaX, deltaY )
function Cs.container:_wheelmoved(dx, dy)
	if (dx ~= 0 and self._maxWidth >= 0) or (dy ~= 0 and self._maxHeight >= 0) then
		if self:scroll(
			self._gui._scrollSpeedX * self.SCROLL_SPEED_X * dx, -- @Incomplete: Scroll relative to font size instead of SCROLL_SPEED_*.
			self._gui._scrollSpeedY * self.SCROLL_SPEED_Y * dy
		) then
			return true
		end
	end
	return false
end



-- OVERRIDE  container:remove( )
function Cs.container:remove(_removeAt_i)
	if _removeAt_i ~= nil then
		printerr(2, "WARNING: container:remove() called with an argument. Did you mean to call container:removeAt(index)?")
	end
	return Cs.container.super.remove(self)
end



-- OVERRIDE  container:reprocessTexts( )
function Cs.container:reprocessTexts()
	Cs.container.super.reprocessTexts(self)
	for _, child in ipairs(self) do
		child:reprocessTexts()
	end
end



-- container:setChildrenActive( bool )
function Cs.container:setChildrenActive(active)
	for _, child in ipairs(self) do
		if child:is(Cs.widget) then  child:setActive(active)  end
	end
end



-- container:setChildrenHidden( bool )
function Cs.container:setChildrenHidden(hidden)
	for _, child in ipairs(self) do
		child:setHidden(hidden)
	end
end



-- button|nil = container:getToggledChild( [ includeGrandchildren=false ] )
function Cs.container:getToggledChild(deep)
	if deep then
		for button in self:traverseType"button" do
			if button:isToggled() then  return button  end
		end
	else
		for _, child in ipairs(self) do
			if child:is(Cs.button) and child:isToggled() then  return child  end
		end
	end
	return nil
end

-- button|nil = container:setToggledChild( id [, includeGrandchildren=false ] )
-- If multiple children have the specified ID then the last one is returned.
function Cs.container:setToggledChild(id, deep)
	local toggledChild = nil
	if deep then
		for button in self:traverseType"button" do
			if button._id == id then
				button:setToggled(true)
				toggledChild = button
			else
				button:setToggled(false)
			end
		end
	else
		for _, child in ipairs(self) do
			if child:is(Cs.button) then
				if child._id == id then
					child:setToggled(true)
					toggledChild = child
				else
					child:setToggled(false)
				end
			end
		end
	end
	return toggledChild
end



-- container:sort( sortFunction )
-- aIsLessThanB = sortFunction( elementA, elementB )
function Cs.container:sort(f)
	!ARGS"2 f:function"
	table.sort(self, f)
	scheduleLayoutUpdateIfDisplayed(self)
end



-- for element in container:traverse( )
function Cs.container:traverse()
	local stack = {self, 0}
	local len   = 2

	return function()
		local child

		repeat
			local i    = stack[len] + 1
			stack[len] = i
			child      = stack[len-1][i]

			if not child then
				len = len - 2 -- Don't bother removing values from the stack.
				if len == 0 then  return  end
			end
		until child

		if child:is(Cs.container) then
			len          = len + 2
			stack[len-1] = child
			stack[len  ] = 0
		end

		return child
	end
end

-- for element in container:traverseType( elementType )
function Cs.container:traverseType(elType)
	local C     = requireElementClass(elType)
	local stack = {self, 0}
	local len   = 2

	return function()
		local child

		repeat
			repeat
				local i    = stack[len] + 1
				stack[len] = i
				child      = stack[len-1][i]

				if not child then
					len = len - 2 -- Don't bother removing values from the stack.
					if len == 0 then  return  end
				end
			until child

			if child:is(Cs.container) then
				len          = len + 2
				stack[len-1] = child
				stack[len  ] = 0
			end
		until child:is(C)

		return child
	end
end

do
	local function traverseVisibleChildren(el)
		for i = #el, 1, -1 do
			local child = el[i]

			if not child._hidden then
				if child:is(Cs.container) then
					traverseVisibleChildren(child)
				end

				coroutine.yield(child)
			end
		end
	end

	local function traverseVisibleChildrenUnderCoords(el, x, y, sbW)
		for i = #el, 1, -1 do
			local child = el[i]

			if not child._hidden then
				local isContainer     = child:is(Cs.container)
				local includeSelf     = true
				local includeChildren = isContainer

				if isContainer then
					local x1, y1 = child:getPositionOnScreen()
					local x2, y2 = x1+child._layoutWidth, y1+child._layoutHeight

					local maxW = child._maxWidth
					local maxH = child._maxHeight

					if maxW >= 0 and (x < x1 or x >= x2-(maxH >= 0 and sbW or 0)) then
						includeChildren = false
						includeSelf     = (x < x2)
					elseif maxH >= 0 and (y < y1 or y >= y2-(maxW >= 0 and sbW or 0)) then
						includeChildren = false
						includeSelf     = (y < y2)
					end
				end

				if includeSelf then
					if includeChildren then
						traverseVisibleChildrenUnderCoords(child, x, y, sbW)
					end
					coroutine.yield(child)
				end
			end
		end
	end

	-- for element in container:traverseVisible( )
	-- for element in container:traverseVisible( x, y )
	function Cs.container:traverseVisible(x, y)
		if x then
			return newIteratorCoroutine(traverseVisibleChildrenUnderCoords, self, x, y, themeGet(self._gui, "scrollbarWidth"))
		else
			return newIteratorCoroutine(traverseVisibleChildren, self)
		end
	end
end



-- INTERNAL REPLACE  container:_updateLayoutSize( )
function Cs.container:_updateLayoutSize()
	updateContainerChildLayoutSizes(self)

	local maxX, maxY = 0, 0
	for _, child in ipairs(self) do
		if not (child._hidden or child._floating) then

			-- Note: We don't consider the anchor as we only care about the size here.
			-- We do treat the position offset as part of the size (added to the top left of the child).
			-- (Maybe the reasoning is flawed somewhere here but it seems to work.)
			maxX = math.max(maxX, child._x+child._layoutWidth)
			maxY = math.max(maxY, child._y+child._layoutHeight)

		end
	end

	self._layoutInnerWidth  = (self._width  >= 0 and self._width -self:getInnerSpaceX() or maxX)
	self._layoutInnerHeight = (self._height >= 0 and self._height-self:getInnerSpaceY() or maxY)

	updateContainerLayoutSize(self)
end

-- INTERNAL REPLACE  container:_expandLayout( expandWidth|nil, expandHeight|nil )
function Cs.container:_expandLayout(expandW, expandH)
	expandContainer(self, expandW, expandH)

	for _, child in ipairs(self) do
		if not child._hidden then  child:_expandLayout(nil, nil)  end
	end
end

-- INTERNAL REPLACE  container:_updateLayoutPosition( )
function Cs.container:_updateLayoutPosition()
	for _, child in ipairs(self) do
		if not child._hidden then
			updateFloatingElementPosition(child) -- All children counts as floating in plain containers.
		end
	end
end



--==============================================================
--= Bar element class (abstract) ===============================
--==============================================================



Cs.bar = newElementClass("GuiBar", Cs.container, {}, {
	-- Parameters.
	_expandChildren = true,  -- Perpendicular to the layout direction of the bar.
	_homogeneous    = false, -- If children should be the same size.
	--

	_layoutInnerStaticWidth  = 0,
	_layoutInnerStaticHeight = 0,
	_layoutInnerSpacingsX    = 0,
	_layoutInnerSpacingsY    = 0,
	_layoutExpandablesX      = 0,
	_layoutExpandablesY      = 0,
}, {
	-- void
})

function Cs.bar:init(gui, elData, parent)
	Cs.bar.super.init(self, gui, elData, parent)

	retrieve(self, elData, "_expandChildren")
	retrieve(self, elData, "_homogeneous")
end



--==============================================================
--= Hbar and Vbar element classes ==============================
--==============================================================



Cs.hbar = newElementClass("GuiHorizontalBar", Cs.bar, {}, {
	-- void
}, {
	-- void
})
Cs.vbar = newElementClass("GuiVerticalBar", Cs.bar, {}, {
	-- void
}, {
	-- void
})

-- function Cs.hbar:init(gui, elData, parent)
-- 	Cs.hbar.super.init(self, gui, elData, parent)
-- end
-- function Cs.vbar:init(gui, elData, parent)
-- 	Cs.vbar.super.init(self, gui, elData, parent)
-- end



-- INTERNAL REPLACE  hbar:_updateLayoutSize( )
-- INTERNAL REPLACE  vbar:_updateLayoutSize( )
function Cs.hbar:_updateLayoutSize()
	updateContainerChildLayoutSizes(self)

	local staticW, dynamicW, highestW, highestDynamicW, expandablesX, currentSx, sumSx,
	      staticH, dynamicH, highestH, highestDynamicH, expandablesY, currentSy, sumSy
	      = getContainerLayoutSizeValues(self)

	local innerW = (self._homogeneous and highestDynamicW*expandablesX or dynamicW)+staticW+sumSx

	innerW   = math.max(innerW,   self._minWidth -self:getInnerSpaceX())
	highestH = math.max(highestH, self._minHeight-self:getInnerSpaceY())

	self._layoutInnerWidth  = (self._width  >= 0 and self._width -self:getInnerSpaceX() or innerW)
	self._layoutInnerHeight = (self._height >= 0 and self._height-self:getInnerSpaceY() or highestH)

	self._layoutInnerStaticWidth, self._layoutInnerStaticHeight = staticW, 0
	self._layoutInnerSpacingsX,   self._layoutInnerSpacingsY    = sumSx, 0
	self._layoutExpandablesX,     self._layoutExpandablesY      = expandablesX, expandablesY

	updateContainerLayoutSize(self)
end
function Cs.vbar:_updateLayoutSize()
	updateContainerChildLayoutSizes(self)

	local staticW, dynamicW, highestW, highestDynamicW, expandablesX, currentSx, sumSx,
	      staticH, dynamicH, highestH, highestDynamicH, expandablesY, currentSy, sumSy
	      = getContainerLayoutSizeValues(self)

	local innerH = (self._homogeneous and highestDynamicH*expandablesY or dynamicH)+staticH+sumSy

	highestW = math.max(highestW, self._minWidth -self:getInnerSpaceX())
	innerH   = math.max(innerH,   self._minHeight-self:getInnerSpaceY())

	self._layoutInnerWidth  = (self._width  >= 0 and self._width -self:getInnerSpaceX() or highestW)
	self._layoutInnerHeight = (self._height >= 0 and self._height-self:getInnerSpaceY() or innerH)

	self._layoutInnerStaticWidth, self._layoutInnerStaticHeight = 0, staticH
	self._layoutInnerSpacingsX,   self._layoutInnerSpacingsY    = 0, sumSy
	self._layoutExpandablesX,     self._layoutExpandablesY      = expandablesX, expandablesY

	updateContainerLayoutSize(self)
end

-- INTERNAL REPLACE  hbar:_expandLayout( expandWidth|nil, expandHeight|nil )
-- INTERNAL REPLACE  vbar:_expandLayout( expandWidth|nil, expandHeight|nil )
function Cs.hbar:_expandLayout(expandW, expandH)
	-- Expand self
	expandContainer(self, expandW, expandH)

	-- Calculate amount of space for children to expand into (total or extra, whether homogeneous or not).
	local totalSpaceX = 0
	if expandW then
		totalSpaceX = self._layoutInnerWidth - self._layoutInnerSpacingsX
		if self._homogeneous then
			totalSpaceX = totalSpaceX - self._layoutInnerStaticWidth
		else
			for _, child in ipairs(self) do
				if not (child._hidden or child._floating) then
					totalSpaceX = totalSpaceX - child._layoutWidth
				end
			end
		end
	end

	-- Expand children.
	local expandablesX = self._layoutExpandablesX

	for _, child in ipairs(self) do
		if not child._hidden then
			if child._floating then
				child:_expandLayout(nil, nil)
			else
				if child._width < 0 then
					if expandW then
						local spaceX = round(totalSpaceX / expandablesX)
						totalSpaceX  = totalSpaceX - spaceX
						expandW      = (self._homogeneous and 0 or child._layoutWidth) + spaceX
					end
					expandablesX = expandablesX - 1
				end
				child:_expandLayout(
					(child._width < 0     and expandW                 or nil),
					(self._expandChildren and self._layoutInnerHeight or nil)
				)
			end
		end
	end

	@@ASSERT(expandablesX == 0, tostring(expandablesX))
end
function Cs.vbar:_expandLayout(expandW, expandH)
	-- Expand self
	expandContainer(self, expandW, expandH)

	-- Calculate amount of space for children to expand into (total or extra, whether homogeneous or not).
	local totalSpaceY = 0
	if expandH then
		totalSpaceY = self._layoutInnerHeight - self._layoutInnerSpacingsY
		if self._homogeneous then
			totalSpaceY = totalSpaceY - self._layoutInnerStaticHeight
		else
			for _, child in ipairs(self) do
				if not (child._hidden or child._floating) then
					totalSpaceY = totalSpaceY - child._layoutHeight
				end
			end
		end
	end

	-- Expand children.
	local expandablesY = self._layoutExpandablesY

	for _, child in ipairs(self) do
		if not child._hidden then
			if child._floating then
				child:_expandLayout(nil, nil)
			else
				if child._height < 0 then
					if expandH then
						local spaceY = round(totalSpaceY / expandablesY)
						totalSpaceY  = totalSpaceY - spaceY
						expandH      = (self._homogeneous and 0 or child._layoutHeight) + spaceY
					end
					expandablesY = expandablesY - 1
				end
				child:_expandLayout(
					(self._expandChildren and self._layoutInnerWidth or nil),
					(child._height < 0    and expandH                or nil)
				)
			end
		end
	end

	@@ASSERT(expandablesY == 0, tostring(expandablesY))
end

-- INTERNAL REPLACE  hbar:_updateLayoutPosition( )
-- INTERNAL REPLACE  vbar:_updateLayoutPosition( )
function Cs.hbar:_updateLayoutPosition()
	local x      = self._layoutX+self._padding
	local y      = self._layoutY+self._padding
	local margin = 0
	local first  = true

	for _, child in ipairs(self) do
		if child._hidden then
			-- void

		elseif child._floating then
			updateFloatingElementPosition(child)

		else
			if not first then
				margin = math.max(margin, child._spacingLeft or child._spacingHorizontal or child._spacing)
				x      = x + margin
			end

			child._layoutX = x
			child._layoutY = y
			child:_updateLayoutPosition()

			x      = x + child._layoutWidth
			margin = child._spacingRight or child._spacingHorizontal or child._spacing
			first  = false
		end
	end
end
function Cs.vbar:_updateLayoutPosition()
	local x      = self._layoutX+self._padding
	local y      = self._layoutY+self._padding
	local margin = 0
	local first  = true

	for _, child in ipairs(self) do
		if child._hidden then
			-- void

		elseif child._floating then
			updateFloatingElementPosition(child)

		else
			if not first then
				margin = math.max(margin, child._spacingTop or child._spacingVertical or child._spacing)
				y      = y + margin
			end

			child._layoutX = x
			child._layoutY = y
			child:_updateLayoutPosition()

			y      = y + child._layoutHeight
			margin = child._spacingBottom or child._spacingVertical or child._spacing
			first  = false
		end
	end
end



--==============================================================
--= Root element class =========================================
--==============================================================



Cs.root = newElementClass("GuiRoot", Cs.container, {}, {
	--[[REPLACE]] _width  = 0, -- The root always has a fixed size (i.e. not dynamic).
	--[[REPLACE]] _height = 0,
}, {
	-- void
})

-- function Cs.root:init(gui, elData, parent)
-- 	Cs.root.super.init(self, gui, elData, parent)
-- end



-- INTERNAL REPLACE  root:_draw( )
function Cs.root:_draw()
	if self._hidden then  return  end

	local x, y, w, h = xywh(self)

	if not self._gui.debug then
		triggerIncludingAnimations(self, "beforedraw", x, y, w, h)
	end

	drawLayoutBackground(self)
	self:_drawDebug(0, 0, 1, 0)

	for _, child in ipairs(self) do
		child:_draw()
	end

	if not self._gui.debug then
		triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
	end
end



-- REPLACE  root:setDimensions( width, height )
-- REPLACE  root:setWidth( width )
-- REPLACE  root:setHeight( height )
function Cs.root:setDimensions(w, h)
	!ARGS"2 w,h:number"
	Cs.root.super.setDimensions(self, math.max(w, 0), math.max(h, 0))
end
function Cs.root:setWidth(w)
	!ARGS"2 w:number"
	Cs.root.super.setWidth(self, math.max(w, 0))
end
function Cs.root:setHeight(h)
	!ARGS"2 h:number"
	Cs.root.super.setHeight(self, math.max(h, 0))
end



-- INTERNAL REPLACE  root:_updateLayoutSize( )
function Cs.root:_updateLayoutSize()
	self._layoutWidth       = self._width
	self._layoutHeight      = self._height
	self._layoutInnerWidth  = self._layoutWidth  - 2*self._padding
	self._layoutInnerHeight = self._layoutHeight - 2*self._padding
	updateContainerChildLayoutSizes(self)
end

-- INTERNAL REPLACE  root:_expandLayout( expandWidth|nil, expandHeight|nil )
-- expandWidth and expandHeight are ignored as the root always has a fixed non-expanding size.
function Cs.root:_expandLayout(expandW, expandH)
	for _, child in ipairs(self) do
		if not child._hidden then  child:_expandLayout(nil, nil)  end
	end
end



--==============================================================
--= Leaf element class (abstract) ==============================
--==============================================================



Cs.leaf = newElementClass("GuiLeaf", Cs.element, {}, {
	-- Parameters.
	_align = "center", -- "left" | "right" | "center"

	_bold  = false,
	_large = false,
	_small = false,

	_mnemonics = false,

	_text = "",

	_textColor = nil,
	--

	_mnemonicBytePosition = nil,
	_textWidth            = 0, _textHeight = 0,
	_unprocessedText      = "",
}, {
	-- void
})

function Cs.leaf:init(gui, elData, parent)
	Cs.leaf.super.init(self, gui, elData, parent)

	retrieve(self, elData, "_align")
	retrieve(self, elData, "_bold","_small","_large")
	retrieve(self, elData, "_mnemonics")
	-- retrieve(self, elData, "_text")
	retrieve(self, elData, "_textColor")

	if elData.text ~= nil then
		self:setText(elData.text)
	end
end



-- align = leaf:getAlign( )
function Cs.leaf:getAlign()
	return self._align
end

-- leaf:setAlign( align )
function Cs.leaf:setAlign(align)
	self._align = align -- Note: We shouldn't have to update the layout after changing the alignment.
end



-- font = leaf:getFont( )
function Cs.leaf:getFont()
	local k = (self._large and "_fontLarge")
	       or (self._small and "_fontSmall")
	       or (self._bold  and "_fontBold" )
	       or                  "_font"

	local font = self._gui[k] or getDefaultFont()

	-- if self:isType"input" then
	-- 	self._field:setFont(font) -- @Robustness: Do this in appropriate places. (Maybe not here...)
	-- end

	return font
end

-- Tell LÖVE to use the font.
-- fontBeingUsed = leaf:useFont( )
function Cs.leaf:useFont()
	local font = self:getFont()
	$LG.setFont(font)
	return font
end



-- offsetX, offsetY, width = leaf:getMnemonicOffset( )
-- Returns nil if there's no mnemonic.
function Cs.leaf:getMnemonicOffset()
	if not self._mnemonicBytePosition then  return nil  end

	local font = self:getFont()
	local text = self._text

	-- @Incomplete: Handle kerning.
	local    i1 = self._mnemonicBytePosition
	local _, i2 = text:find(!("^"..UTF8_CHAR_PATTERN), i1)
	local x1    = font:getWidth(text:sub(1, i1-1)) -- @Speed @Memory
	local x2    = font:getWidth(text:sub(1, i2  ))

	return x1, font:getBaseline(), math.max(x2-x1, 1)
end



-- text = leaf:getText( )
function Cs.leaf:getText()
	return self._text
end

-- text = leaf:getUnprocessedText( )
-- Also see gui:setTextPreprocessor().
function Cs.leaf:getUnprocessedText()
	return self._unprocessedText
end

-- leaf:setText( text )
function Cs.leaf:setText(unprocessedText)
	unprocessedText = tostring(unprocessedText == nil and "" or unprocessedText)

	local text = preprocessText(self._gui, unprocessedText, self, self._mnemonics)
	if self._text == text then  return  end

	-- Check text for mnemonics (using "&").
	self._mnemonicBytePosition = nil

	if self._mnemonics then
		local matchCount    = 0
		local mnemonicCount = 0

		local cleanText = text:gsub("()&(.)", function(pos, c)
			if c ~= "&" then
				if mnemonicCount == 0 then
					self._mnemonicBytePosition = pos - matchCount
				end
				mnemonicCount = mnemonicCount + 1
			end
			matchCount = matchCount + 1
			return c
		end)

		if mnemonicCount > 1 then
			printerr(2, "Multiple mnemonics in '%s'.", text)
		end

		text = cleanText
	end

	self._text            = text
	self._unprocessedText = unprocessedText

	local oldW      = self._textWidth
	self._textWidth = self:getFont():getWidth(text)

	if self._textWidth ~= oldW then
		scheduleLayoutUpdateIfDisplayed(self)
	end
end

-- leaf:drawText( x, y )
function Cs.leaf:drawText(x, y)
	$LG.print(self._text, x, y)
end

-- leaf:drawAlignedText( areaX, areaY, areaWidth [, align=self:getAlign() ] )
function Cs.leaf:drawAlignedText(x, y, w, align)
	align = align or self._align
	if align == "right" then
		x = x + w - self._textWidth
	elseif align == "center" then
		x = x + math.floor((w-self._textWidth)/2)
	end
	self:drawText(x, y)
end



-- colorTable|nil = leaf:getTextColor( )
function Cs.leaf:getTextColor()
	return self._textColor
end

-- leaf:setTextColor( colorTable|nil )
function Cs.leaf:setTextColor(color)
	self._textColor = color
end

-- bool = leaf:hasTextColor( )
function Cs.leaf:hasTextColor()
	return (self._textColor ~= nil)
end

-- Tell LÖVE to use the text color.
-- hasTextColor = leaf:useTextColor( [ alphaMultiplier=1 ] )
function Cs.leaf:useTextColor(opacity)
	local color = self._textColor
	useColor((color or COLOR_WHITE), opacity)
	return (color ~= nil)
end



-- bool = leaf:isBold( )
-- bool = leaf:isLarge( )
-- bool = leaf:isSmall( )
function Cs.leaf:isBold(text)
	return self._bold
end
function Cs.leaf:isLarge(text)
	return self._large
end
function Cs.leaf:isSmall(text)
	return self._small
end

-- leaf:setBold ( bool )
-- leaf:setLarge( bool )
-- leaf:setSmall( bool )
function Cs.leaf:setBold(bold)
	if self._bold == bold then  return  end
	self._bold = bold
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.leaf:setLarge(large)
	if self._large == large then  return  end
	self._large = large
	scheduleLayoutUpdateIfDisplayed(self)
end
function Cs.leaf:setSmall(small)
	if self._small == small then
		return
	end
	self._small = small
	scheduleLayoutUpdateIfDisplayed(self)
end



-- REPLACE  bool = leaf:isSolid( )
function Cs.leaf:isSolid()
	return true
end



-- OVERRIDE  leaf:reprocessTexts( )
function Cs.leaf:reprocessTexts()
	Cs.leaf.super.reprocessTexts(self)
	self:setText(self._unprocessedText)
end



--==============================================================
--= Canvas element class =======================================
--==============================================================



Cs.canvas = newElementClass("GuiCanvas", Cs.leaf, {}, {
	-- Parameters.
	_canvasBackgroundColor = nil,
}, {
	"draw", -- function( canvasElement, event, drawAreaWidth, drawAreaHeight )
})

function Cs.canvas:init(gui, elData, parent)
	Cs.canvas.super.init(self, gui, elData, parent)

	retrieve(self, elData, "_canvasBackgroundColor")
end



-- INTERNAL REPLACE  canvas:_draw( )
function Cs.canvas:_draw()
	if self._hidden then  return  end

	local gui = self._gui
	if gui.debug then  return self:_drawDebug(1, 0, 0)  end

	local x, y, w, h = xywh(self)

	triggerIncludingAnimations(self, "beforedraw", x, y, w, h)
	drawLayoutBackground(self)

	-- Draw canvas.
	-- We don't call themeRender() for canvases as they should only draw things through the "draw" event.
	local cw = (self._width  >= 0) and self._width  or w
	local ch = (self._height >= 0) and self._height or h

	if cw > 0 and ch > 0 then
		$LG.push("all")

		local cx, cy  = x+math.floor((w-cw)/2), y+math.floor((h-ch)/2)
		local bgColor = self._canvasBackgroundColor
		if bgColor then
			setColor(bgColor)
			$LG.rectangle("fill", cx, cy, cw, ch)
		end

		setScissor(gui, cx, cy, cw, ch)
		$LG.translate(cx, cy)
		setColor(1, 1, 1)

		triggerIncludingAnimations(self, "draw", cw, ch)
		self:unsetScissor()

		setScissor(gui, nil)
		$LG.pop()
	end

	triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
end



-- colorTable|nil = canvas:getCanvasBackgroundColor( )
function Cs.canvas:getCanvasBackgroundColor()
	return self._canvasBackgroundColor
end

-- canvas:setCanvasBackgroundColor( colorTable|nil )
function Cs.canvas:setCanvasBackgroundColor(color)
	self._canvasBackgroundColor = color
end



-- INTERNAL REPLACE  handled, grabMouseFocus = canvas:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.canvas:_mousepressed(mx, my, mbutton, pressCount)
	return true, true
end



-- INTERNAL REPLACE  canvas:_updateLayoutSize( )
function Cs.canvas:_updateLayoutSize()
	-- We don't call themeGetSize() for canvases as they always have their own private "theme".
	local w = math.max(self._width , 0)
	local h = math.max(self._height, 0)

	self._layoutWidth,      self._layoutHeight      = w, h
	self._layoutInnerWidth, self._layoutInnerHeight = w, h
end



--==============================================================
--= Image element class ========================================
--==============================================================



Cs.image = newElementClass("GuiImage", Cs.leaf, {"imageInclude"}, {
	-- void
}, {
	-- void
})

function Cs.image:init(gui, elData, parent)
	Cs.image.super.init(self, gui, elData, parent)
	initImageInclude(self, elData)
end



-- INTERNAL OVERRIDE  image:_update( deltaTime )
function Cs.image:_update(dt)
	Cs.image.super._update(self, dt)
	local sprite = self._sprite
	if sprite then  updateSprite(sprite, dt)  end
end



-- INTERNAL REPLACE  image:_draw( )
function Cs.image:_draw()
	if self._hidden then  return  end
	if self._gui.debug then  return self:_drawDebug(1, 0, 0)  end

	local x, y, w, h = xywh(self)

	triggerIncludingAnimations(self, "beforedraw", x, y, w, h)

	drawLayoutBackground(self)

	local image, quad, iw, ih = nil, nil, 0, 0
	if self._sprite then
		image, quad, iw, ih = getCurrentViewOfSprite(self._sprite)
	end
	themeRender(self, "image", iw*self._imageScaleX, ih*self._imageScaleY)

	triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
end



-- INTERNAL REPLACE  image:_updateLayoutSize( )
function Cs.image:_updateLayoutSize()
	local w, h
	if self._width < 0 or self._height < 0 then
		local iw, ih = self:getImageDimensions()
		w, h         = themeGetSize(self, "image", iw*self._imageScaleX, ih*self._imageScaleX)
	end

	w = (self._width  >= 0) and self._width  or math.max(w, self._minWidth )
	h = (self._height >= 0) and self._height or math.max(h, self._minHeight)

	self._layoutWidth     , self._layoutHeight      = w, h
	self._layoutInnerWidth, self._layoutInnerHeight = w, h
end



--==============================================================
--= Text element class =========================================
--==============================================================



Cs.text = newElementClass("GuiText", Cs.leaf, {}, {
	-- Parameters.
	_wrapText      = false,
	_textWrapLimit = -1, -- Negative means no limit.
}, {
	-- void
})

function Cs.text:init(gui, elData, parent)
	Cs.text.super.init(self, gui, elData, parent)

	retrieve(self, elData, "_wrapText","_textWrapLimit")
end



-- INTERNAL REPLACE  text:_draw( )
function Cs.text:_draw()
	if self._hidden    then  return  end
	if self._gui.debug then  return self:_drawDebug(1, 0, 0)  end

	local x, y, w, h = xywh(self)

	triggerIncludingAnimations(self, "beforedraw", x, y, w, h)

	drawLayoutBackground(self)

	local textIndent = themeGet(self._gui, "textIndentation")
	themeRender(self, "text", textIndent, self._textWidth, self._textHeight)

	triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
end



-- INTERNAL REPLACE  text:_updateLayoutSize( )
function Cs.text:_updateLayoutSize()
	local wrapLimit = self._textWrapLimit
	if wrapLimit < 0 then  wrapLimit = 1/0  end

	if wrapLimit == 1/0 and self._wrapText then
		local innerSpaceSum = 0

		for _, parent in self:parents() do
			innerSpaceSum = innerSpaceSum + parent:getInnerSpaceX()

			-- At most this will be the root, as the root always has a defined size.
			if parent._width >= 0 then
				wrapLimit = parent._width - innerSpaceSum - 2*themeGet(self._gui, "textIndentation")

				if wrapLimit <= 0 then
					-- Maybe the root's size is 0x0?
					wrapLimit = 1/0
				end

				break
			end
		end
	end

	local textW    , textH            = getTextDimensions(self:getFont(), self._text, wrapLimit)
	self._textWidth, self._textHeight = textW, textH

	local w, h
	if self._width < 0 or self._height < 0 then
		local textIndent = themeGet(self._gui, "textIndentation")
		w, h             = themeGetSize(self, "text", textIndent, textW, textH)
	end

	w = (self._width  >= 0) and self._width  or math.max(w, self._minWidth )
	h = (self._height >= 0) and self._height or math.max(h, self._minHeight)

	self._layoutWidth     , self._layoutHeight      = w, h
	self._layoutInnerWidth, self._layoutInnerHeight = w, h
end



-- REPLACE  text:drawText( x, y )
function Cs.text:drawText(x, y)
	if self._wrapText or self._textWrapLimit >= 0 then
		$LG.printf(self._text, x, y, self._textWidth, self._align)
	else
		$LG.print(self._text, x, y)
	end
end



--==============================================================
--= Widget element class (abstract) ============================
--==============================================================



Cs.widget = newElementClass("GuiWidget", Cs.leaf, {}, {
	-- Parameters.
	_active   = true, -- If the widget can be interacted with or is grayed out.
	_priority = 0,    -- Navigation priority.
}, {
	"navigate" , -- suppress = function( widgetElement, event )
	"navupdate", --            function( widgetElement, event, deltaTime )
})

function Cs.widget:init(gui, elData, parent)
	Cs.widget.super.init(self, gui, elData, parent)

	retrieve(self, elData, "_active")
	retrieve(self, elData, "_priority")
end



-- priority = widget:getPriority( )
function Cs.widget:getPriority()
	return self._priority
end

-- widget:setPriority( priority )
function Cs.widget:setPriority(priority)
	self._priority = priority
end



-- bool = widget:isActive( )
function Cs.widget:isActive()
	return self._active
end

-- stateChanged = widget:setActive( bool )
function Cs.widget:setActive(active)
	if self._active == active then  return false  end
	self._active = active
	return true
end



--==============================================================
--= Button element class =======================================
--==============================================================



Cs.button = newElementClass("GuiButton", Cs.widget, {"imageInclude"}, {
	-- Parameters.
	_pressable = true,
	_canToggle = false,
	_close     = false,

	_toggled = false,

	_text2 = "",

	_imagePadding = 0,

	_toggledSprite   = nil,
	_untoggledSprite = nil,

	_arrow = nil, -- @Cleanup: We're not using this internally. Should it be removed in favor of element.data?
	--

	_isPressed = false,

	_textWidth1 = 0,
	_textWidth2 = 0,

	_unprocessedText2 = "",
}, {
	"press" , -- function( buttonElement, event )
	"toggle", -- function( buttonElement, event )
})

function Cs.button:init(gui, elData, parent)
	Cs.button.super.init(self, gui, elData, parent)
	initImageInclude(self, elData)

	retrieve(self, elData, "_arrow")
	retrieve(self, elData, "_canToggle")
	retrieve(self, elData, "_close")
	retrieve(self, elData, "_imagePadding")
	retrieve(self, elData, "_pressable")
	-- retrieve(self, elData, "_text2")
	retrieve(self, elData, "_toggled")
	retrieve(self, elData, "_toggledSprite","_untoggledSprite")

	if elData.sprite then
		-- void
	elseif self._toggledSprite and self._toggled then
		self:setSprite(self._toggledSprite)
	elseif self._untoggledSprite and not self._toggled then
		self:setSprite(self._untoggledSprite)
	end

	if elData.text2 ~= nil then
		self:setText2(elData.text2)
	end
end



-- INTERNAL OVERRIDE  button:_update( deltaTime )
function Cs.button:_update(dt)
	Cs.button.super._update(self, dt)
	local sprite = self._sprite
	if sprite then  updateSprite(sprite, dt)  end
end



-- INTERNAL REPLACE  button:_draw( )
function Cs.button:_draw()
	if self._hidden then  return  end
	if self._gui.debug then  return self:_drawDebug(0, 180, 0)  end

	local x, y, w, h = xywh(self)

	triggerIncludingAnimations(self, "beforedraw", x, y, w, h)
	drawLayoutBackground(self)

	local image, quad, iw, ih = nil, nil, 0, 0
	if self._sprite then
		image, quad, iw, ih = getCurrentViewOfSprite(self._sprite)
	end
	themeRender(
		self, "button", self._textWidth1, self._textWidth2, self._textHeight,
		iw*self._imageScaleX+2*self._imagePadding, ih*self._imageScaleY+2*self._imagePadding
	)

	triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
end



-- arrow|nil = button:getArrow( )
function Cs.button:getArrow()
	return self._arrow
end



-- text2 = button:getText2( )
function Cs.button:getText2()
	return self._text2
end

-- text = button:getUnprocessedText2( )
function Cs.button:getUnprocessedText2()
	return self._unprocessedText2
end

-- OVERRIDE  button:setText( text )
function Cs.button:setText(text)
	local oldText = self._text
	local oldW = self._textWidth

	Cs.button.super.setText(self, text)
	text = nil -- Don't use this anymore!

	if self._text == oldText then
		return
	end

	self._textWidth1 = self._textWidth
	self._textWidth = self._textWidth1+self._textWidth2

	if self._textWidth ~= oldW then
		scheduleLayoutUpdateIfDisplayed(self)
	end
end

-- button:setText2( text )
function Cs.button:setText2(unprocessedText)
	unprocessedText = tostring(unprocessedText == nil and "" or unprocessedText)

	local text = preprocessText(self._gui, unprocessedText, self, false)
	if self._text2 == text then  return  end

	self._text2            = text
	self._unprocessedText2 = unprocessedText

	local oldW       = self._textWidth
	self._textWidth2 = self:getFont():getWidth(text)
	self._textWidth  = self._textWidth1+self._textWidth2

	if self._textWidth ~= oldW then
		scheduleLayoutUpdateIfDisplayed(self)
	end
end

-- button:drawText2( x, y )
function Cs.button:drawText2(x, y)
	$LG.print(self._text2, x, y)
end

-- button:drawAlignedText2( areaX, areaY, areaWidth [, align=self:getAlign() ] )
function Cs.button:drawAlignedText2(x, y, w, align)
	align = align or self._align
	if align == "right" then
		x = x + w - self._textWidth2
	elseif align == "center" then
		x = x + math.floor((w-self._textWidth2)/2)
	end
	self:drawText(x, y)
end



-- bool = button:isPressable( )
function Cs.button:isPressable()
	return self._pressable
end

-- button:setPressable( bool )
function Cs.button:setPressable(pressable)
	self._pressable = pressable
end



-- bool = button:isToggled( )
function Cs.button:isToggled()
	return self._toggled
end

-- button:setToggled( bool )
function Cs.button:setToggled(toggled)
	if self._toggled == toggled then  return  end

	self._toggled = toggled

	if toggled and self._toggledSprite then
		self:setSprite(self._toggledSprite)
	elseif not toggled and self._untoggledSprite then
		self:setSprite(self._untoggledSprite)
	end

	trigger(self, "toggle")
end



-- INTERNAL REPLACE  handled, grabMouseFocus = button:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.button:_mousepressed(mx, my, mbutton, pressCount)
	if mbutton == 1 then
		if not self._active then  return true, false  end

		self._isPressed = true
		return true, true
	end

	return false, false
end

-- -- INTERNAL REPLACE  button:_mousemoved( mouseX, mouseY )
-- function Cs.button:_mousemoved(mx, my)
-- end

-- INTERNAL REPLACE  button:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.button:_mousereleased(mx, my, mbutton, pressCount)
	if mbutton == 1 then
		self._isPressed = false
		if self:isHovered() then  self:press()  end
	end
end



-- INTERNAL REPLACE  handled = button:_ok( )
function Cs.button:_ok()
	self:press()
	return true
end



-- success = button:press( [ ignoreActiveState=false ] )
function Cs.button:press(ignoreActiveState)
	if not ignoreActiveState and not (self._active and self._pressable) then
		return false
	end

	-- Press/toggle the button
	local preparedSound = prepareSound(self, "press")

	if self._canToggle then
		local toggled = not self._toggled
		self._toggled = toggled -- We need to toggle before the press event in case the callback uses the value.

		if toggled and self._toggledSprite then
			self:setSprite(self._toggledSprite)
		elseif not toggled and self._untoggledSprite then
			self:setSprite(self._untoggledSprite)
		end
	end

	self._gui._ignoreKeyboardInputThisFrame = true

	trigger(self, "press")
	if self._canToggle then  trigger(self, "toggle")  end

	self:triggerBubbling("pressed", self)

	-- Close closest closable
	local closedAnything = false

	if self._close then
		if self:canClose() then
			closedAnything = self:close()
		else
			for _, parent in self:parents() do
				if parent:canClose() then
					closedAnything = parent:close()
					break
				end
			end
		end
	end
	if not closedAnything then
		preparedSound() -- 'close' has its own sound.
	end

	return true
end

-- bool = button:isPressed( )
function Cs.button:isPressed()
	return self._isPressed
end



-- OVERRIDE  button:reprocessTexts( )
function Cs.button:reprocessTexts()
	Cs.button.super.reprocessTexts(self)
	self:setText2(self._unprocessedText2)
end



-- INTERNAL REPLACE  button:_updateLayoutSize( )
function Cs.button:_updateLayoutSize()
	local font       = self:getFont()
	self._textWidth1 = font:getWidth(self._text)
	self._textWidth2 = font:getWidth(self._text2)
	self._textWidth  = self._textWidth1 + self._textWidth2 -- This value is pretty useless...
	self._textHeight = font:getHeight()

	local w, h
	if self._width < 0 or self._height < 0 then
		local iw, ih = self:getImageDimensions()
		w, h = themeGetSize(
			self, "button", self._textWidth1, self._textWidth2, self._textHeight,
			iw*self._imageScaleX+2*self._imagePadding, ih*self._imageScaleX+2*self._imagePadding
		)
	end

	w = (self._width  >= 0) and self._width  or math.max(w, self._minWidth )
	h = (self._height >= 0) and self._height or math.max(h, self._minHeight)

	self._layoutWidth     , self._layoutHeight      = w, h
	self._layoutInnerWidth, self._layoutInnerHeight = w, h
end



--==============================================================
--= Input element class ========================================
--==============================================================



Cs.input = newElementClass("GuiInput", Cs.widget, {}, {
	-- Parameters.
	--[[OVERRIDE]] _mouseCursor = "ibeam",

	--[[REPLACE]] _minWidth = 10,

	_placeholder = "",

	_mask = "",

	_spin = 0, -- Non-zero enables number value spinning.

	_spinMin = -1/0,
	_spinMax = 1/0,
	--

	_field = nil,

	_savedKeyRepeat = false,
	_savedValue     = "",
}, {
	"change"     , -- function( inputElement, event )
	"submit"     , -- function( inputElement, event )
	"valuechange", -- function( inputElement, event )
})

function Cs.input:init(gui, elData, parent)
	Cs.input.super.init(self, gui, elData, parent)

	-- retrieve(self, elData, "_password") -- This is saved in the field instead.
	retrieve(self, elData, "_mask")
	retrieve(self, elData, "_placeholder")
	retrieve(self, elData, "_spin")
	retrieve(self, elData, "_spinMin","_spinMax")

	self._field = InputField((elData.value and tostring(elData.value) or ""), (elData.password and "password" or "normal"))
	self._field:setFont(self:getFont())
	self._field:setFontFilteringActive(true)
end



-- INTERNAL OVERRIDE  input:_update( deltaTime )
function Cs.input:_update(dt)
	Cs.input.super._update(self, dt)
	self._field:update(dt)
end



-- INTERNAL REPLACE  input:_draw( )
function Cs.input:_draw()
	if self._hidden    then  return  end
	if self._gui.debug then  return self:_drawDebug(0, 180, 0)  end

	local inputIndent     = themeGet(self._gui, "inputIndentation")
	local x, y, w, h      = xywh(self)
	local curOffset       = self:getCursorOffset()
	local selOffset, selW = self:getSelectionOffset()

	triggerIncludingAnimations(self, "beforedraw", x, y, w, h)

	drawLayoutBackground(self)
	themeRender(self, "input", inputIndent, self:getFont():getHeight(), curOffset, selOffset, selW)

	triggerIncludingAnimations(self, "afterdraw", x, y, w, h)
end



-- input:focus( )
function Cs.input:focus()
	local gui = self._gui
	if gui._keyboardFocus == self then  return  end

	self._savedValue     = self:getValue()
	self._savedKeyRepeat = love.keyboard.hasKeyRepeat()

	gui:navigateTo(gui._navigationTarget and self or nil)
	gui._lockNavigation = true

	setKeyboardFocus(gui, self)

	love.keyboard.setKeyRepeat(true)
	self._field:resetBlinking()

	self:playSound("focus")
	self:triggerBubbling("focused", self)
end

-- success = input:blur( )
function Cs.input:blur()
	local gui = self._gui
	if gui._keyboardFocus ~= self then  return false  end

	blurKeyboardFocus(gui)
	gui._lockNavigation = false

	love.keyboard.setKeyRepeat(self._savedKeyRepeat)

	self._field:setScroll(0, 0)

	local v = self:getValue()
	if v ~= self._savedValue then
		trigger(self, "change", v)
	end

	self:triggerBubbling("blurred", self)
	return true
end

-- bool = input:isFocused( )
function Cs.input:isFocused()
	return self:isKeyboardFocus()
end



-- inputField = input:getField( )
-- Inputs use the InputField library for many things. This method gives direct access to
-- the internal InputField instance. (See https://github.com/ReFreezed/InputField)
function Cs.input:getField()
	return self._field
end



-- value = input:getValue( )
function Cs.input:getValue()
	return self._field:getText()
end

-- input:setValue( value )
function Cs.input:setValue(value)
	return self._field:setText(value)
end

-- value = input:getVisibleValue( )
-- Returns *** for passwords.
function Cs.input:getVisibleValue()
	return self._field:getVisibleText()
end

-- input:drawValue( x, y )
function Cs.input:drawValue(x0, y0)
	for _, line, x, y in self._field:eachVisibleLine() do -- Ought to be a single line.
		$LG.print(line, x0+x, y0+y)
	end
end

-- input:drawPlaceholder( x, y )
function Cs.input:drawPlaceholder(x, y)
	$LG.print(self._placeholder, x, y)
end



-- bool = input:isPasswordActive( )
function Cs.input:isPasswordActive()
	return self._field:isPassword()
end

-- input:setPasswordActive( bool )
function Cs.input:setPasswordActive(active)
	self._field:setType(active and "password" or "normal")
end



-- INTERNAL REPLACE  handled, grabKeyboardFocus = input:_keypressed( key, scancode, isRepeat )
function Cs.input:_keypressed(key, scancode, isRepeat)
	if not self:isKeyboardFocus() then  return false, false  end

	if key == "escape" then
		if not isRepeat then
			if self:getValue() ~= self._savedValue then
				self._field:setText(self._savedValue)
				trigger(self, "valuechange")
			end
			self:blur()
			self:playSound("inputrevert")
		end

	elseif key == "return" or key == "kpenter" then
		if not isRepeat then
			self:blur()
			self:playSound("inputsubmit")
			trigger(self, "submit")
		end

	elseif self._spin ~= 0 and (key == "up" or key == "down") then
		local oldValue = self:getValue()
		local n        = tonumber(oldValue) or 0

		if key == "up" then
			n = n + self._spin
		elseif key == "down" then
			n = n - self._spin
		end
		n = math.min(math.max(n, self._spinMin), self._spinMax)

		local newValue = tostring(n)
		if newValue ~= oldValue then
			self:setValue(newValue)
			self._field:selectAll()
			trigger(self, "valuechange")
		end

	else
		local oldValue = self:getValue()
		local handled  = self._field:keypressed(key, isRepeat)

		local mask     = self._mask
		local newValue = self:getValue()
		if handled and mask ~= "" and newValue ~= oldValue and not newValue:find(mask) then
			self:setValue(oldValue)
		elseif handled and newValue ~= oldValue then
			trigger(self, "valuechange")
		end
	end

	return true, false
end

-- -- INTERNAL REPLACE  input:_keyreleased( key, scancode )
-- function Cs.input:_keyreleased(key, scancode)
-- end

-- INTERNAL REPLACE  handled = input:_textinput( text )
function Cs.input:_textinput(text)
	if not self:isKeyboardFocus() then  return false  end

	local oldValue = self:getValue()
	local handled  = self._field:textinput(text)

	local mask     = self._mask
	local newValue = self:getValue()
	if handled and mask ~= "" and newValue ~= oldValue and not newValue:find(mask) then
		newValue = oldValue
		self:setValue(newValue)
	elseif handled and newValue ~= oldValue then
		trigger(self, "valuechange")
	end

	return true
end



-- INTERNAL REPLACE  handled, grabMouseFocus = input:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.input:_mousepressed(mx, my, mbutton, pressCount)
	if not self._active then
		return true, false
	end

	self:focus()

	if mbutton == 1 then
		self._field:mousepressed(mx-self._layoutX-themeGet(self._gui, "inputIndentation"), 0, mbutton, pressCount)
		return true, true
	else
		return true, false
	end
end

-- INTERNAL REPLACE  input:_mousemoved( mouseX, mouseY )
function Cs.input:_mousemoved(mx, my)
	self._field:mousemoved(mx-self._layoutX-themeGet(self._gui, "inputIndentation"), 0)
end

-- INTERNAL REPLACE  input:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.input:_mousereleased(mx, my, mbutton, pressCount)
	self._field:mousereleased(mx-self._layoutX-themeGet(self._gui, "inputIndentation"), 0, mbutton)
end



-- INTERNAL REPLACE  handled = input:_ok( )
function Cs.input:_ok()
	self._gui._ignoreKeyboardInputThisFrame = true
	if not self:isFocused() then
		self:focus()
	else
		self:blur()
	end
	return true
end



-- OVERRIDE  input:setActive( bool )
function Cs.input:setActive(active)
	if not active then  self:blur()  end
	Cs.input.super.setActive(self, active)
end



-- INTERNAL REPLACE  input:_updateLayoutSize( )
function Cs.input:_updateLayoutSize()
	local inputIndent = themeGet(self._gui, "inputIndentation")

	local w, h
	if self._width < 0 or self._height < 0 then
		w, h = themeGetSize(self, "input", inputIndent, self:getFont():getHeight())
	end

	w = (self._width  >= 0) and self._width  or math.max(w, self._minWidth )
	h = (self._height >= 0) and self._height or math.max(h, self._minHeight)

	self._layoutWidth,      self._layoutHeight      = w              , h
	self._layoutInnerWidth, self._layoutInnerHeight = w-2*inputIndent, h
end

-- INTERNAL OVERRIDE  input:_expandLayout( expandWidth|nil, expandHeight|nil )
function Cs.input:_expandLayout(expandW, expandH)
	Cs.input.super._expandLayout(self, expandW, expandH)

	local inputIndent = themeGet(self._gui, "inputIndentation")

	self._layoutInnerWidth  = self._layoutWidth-2*inputIndent
	self._layoutInnerHeight = self._layoutHeight

	self._field:setWidth(self._layoutInnerWidth)
end



-- offset, width = input:getSelectionOffset( )
function Cs.input:getSelectionOffset()
	for i, x, y, w, h in self._field:eachSelectionOptimized() do
		return x, w
	end
	return 0, 0 -- We should never get here!
end

-- offset = input:getCursorOffset( )
function Cs.input:getCursorOffset()
	return (self._field:getCursorLayout())
end



-- phase = input:getBlinkPhase( )
function Cs.input:getBlinkPhase()
	return self._field:getBlinkPhase()
end



--==============================================================
--= Default theme ==============================================
--==============================================================

do
local Gui    = _M
defaultTheme = (function()  @insert "src/defaultTheme.luapart"  end)()
end



--==============================================================
--==============================================================
--==============================================================

return setmetatable(_M, {
	__call = function(_M, ...)
		return (Gui(...))
	end,
})

--==============================================================
--=
--=  MIT License
--=
--=  Copyright © 2017-2022 Marcus 'ReFreezed' Thunström
--=
--=  Permission is hereby granted, free of charge, to any person obtaining a copy
--=  of this software and associated documentation files (the "Software"), to deal
--=  in the Software without restriction, including without limitation the rights
--=  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--=  copies of the Software, and to permit persons to whom the Software is
--=  furnished to do so, subject to the following conditions:
--=
--=  The above copyright notice and this permission notice shall be included in all
--=  copies or substantial portions of the Software.
--=
--=  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--=  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--=  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--=  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--=  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--=  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
--=  SOFTWARE.
--=
--==============================================================
