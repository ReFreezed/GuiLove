--[[============================================================
--=
--=  GuiLove v0.2 beta for LÖVE 0.10.2+
--=  - Written by Marcus 'ReFreezed' Thunström
--=  - MIT License (See the bottom of this file)
--=
--=  This file is generated from the source at:
--=  https://github.com/ReFreezed/GuiLove
--=
--==============================================================



	Basic usage
	----------------------------------------------------------------

	function love.load()
		local Gui = require("Gui")
		gui       = Gui()

		local tree = {"root", width=love.graphics.getWidth(), height=love.graphics.getHeight(),
			{"vbar", id="myContainer", width=200,
				{"text", text="I'm just a text."},
				{"input", value="foo bar"},
				{"button", id="myButton", text="Press Me!"},
			},
		}
		gui:load(tree)

		local myButton   = gui:find("myButton")
		local pressCount = 0

		myButton:on("press", function(myButton, event)
			pressCount = pressCount + 1

			local myContainer = gui:find("myContainer")
			local text        = "Pressed button " .. pressCount .. " " .. (pressCount == 1 and "time" or "times") .. "!"
			myContainer:insert{ "text", text=text }
		end)
	end

	function love.keypressed(key, scancode, isRepeat)
		gui:keypressed(key, scancode, isRepeat)
	end
	function love.keyreleased(key, scancode)
		gui:keyreleased(key, scancode)
	end
	function love.textinput(text)
		gui:textinput(text)
	end

	function love.mousepressed(mx, my, mbutton, isTouch, pressCount)
		gui:mousepressed(mx, my, mbutton, pressCount)
	end
	function love.mousemoved(mx, my, dx, dy, isTouch)
		gui:mousemoved(mx, my)
	end
	function love.mousereleased(mx, my, mbutton, isTouch, pressCount)
		gui:mousereleased(mx, my, mbutton, pressCount)
	end
	function love.wheelmoved(dx, dy)
		gui:wheelmoved(dx, dy)
	end

	function love.update(dt)
		gui:update(dt)
	end
	function love.draw()
		gui:draw()
	end



	Gui methods
	----------------------------------------------------------------

	keypressed, keyreleased, textinput
	mousepressed, mousemoved, mousereleased, wheelmoved
	update
	draw

	areStandardKeysActive, setStandardKeysActive
	blur
	defineStyle
	find, findAll, findActive, findToggled, match, matchAll
	getDefaultSound, setDefaultSound
	getElementAt
	getFont, setFont, getTooltipFont, setTooltipFont
	getHoveredElement
	getNavigationTarget, navigateTo, navigateToNext, navigateToPrevious, navigateToFirst, navigate, canNavigateTo
	getRoot
	getScissorCoordsConverter, setScissorCoordsConverter
	getScrollSmoothness, setScrollSmoothness
	getScrollSpeed, setScrollSpeed
	getSoundPlayer, setSoundPlayer
	getSpriteLoader, setSpriteLoader
	getTarget, getTargetCallback, setTargetCallback
	getTextPreprocessor, setTextPreprocessor, reprocessTexts
	getTheme, setTheme
	getTime, getTimeSinceNavigation
	getTooltipDelay, setTooltipDelay
	isBusy, isKeyboardBusy, isMouseBusy
	isCullingActive, setCullingActive
	isIgnoringKeyboardInput
	isInputCaptured, getInputCapturingElement
	isInteractionLocked
	isMouseGrabbed, setMouseIsGrabbed
	load
	ok, back
	updateLayout, getLayoutUpdateTime



	Element types, methods and events
	----------------------------------------------------------------

	(element)
	- animate
	- close, canClose
	- drawTooltip
	- exists
	- getAnchor, setAnchor, getAnchorX, setAnchorX, getAnchorY, setAnchorY
	- getCallback, setCallback, on, off, trigger, triggerBubbling
	- getClosest
	- getClosestInDirection, getNext, getPrevious
	- getData, setData, swapData
	- getDimensions, setDimensions, getWidth, setWidth, getHeight, setHeight
	- getGui
	- getGuiTime
	- getId, setId, hasId
	- getIndex, getDepth
	- getLayout
	- getLayoutDimensions, getLayoutWidth, getLayoutHeight
	- getLayoutPosition, getLayoutX, getLayoutY, getLayoutCenterPosition
	- getMaxDimensions, setMaxDimensions, getMaxWidth, setMaxWidth, getMaxHeight, setMaxHeight
	- getMinDimensions, setMinDimensions, getMinWidth, setMinWidth, getMinHeight, setMinHeight
	- getMouseCursor, getResultingMouseCursor, setMouseCursor
	- getMousePosition, getMouseX, getMouseY
	- getOrigin, setOrigin, getOriginX, setOriginX, getOriginY, setOriginY
	- getParent, getAllParents, hasParent, getParentWithId, hasParentWithId, parents, parentsr, lineageUp
	- getPathDescription
	- getPosition, setPosition, getX, setX, getY, setY
	- getPositionOnScreen, getXOnScreen, getYOnScreen, getLayoutOnScreen
	- getRelativeDimensions, getRelativeWidth, getRelativeHeight, setRelativeDimensions, setRelativeWidth, setRelativeHeight
	- getResultingTooltipFont, useTooltipFont
	- getRoot, getNavigationRoot
	- getSibling
	- getSound, getResultingSound, setSound
	- getSpacing, getSpacingLeft, getSpacingRight, getSpacingTop, getSpacingBottom, setSpacing
	- getStyle
	- getTimeSinceBecomingVisible
	- getTooltip, setTooltip
	- getWeight, setWeight
	- hasFixedWidth, hasFixedHeight, hasDynamicWidth, hasDynamicHeight, hasRelativeWidth, hasRelativeHeight
	- hasTag, addTag, removeTag, removeAllTags, setTag
	- isAt
	- isDisplayed, getClosestHiddenElement, getFarthestHiddenElement
	- isFirst, isLast
	- isHidden, isVisible, setHidden, setVisible, show, hide, toggleHidden
	- isHovered
	- isMouseFocus, isKeyboardFocus
	- isNavigationTarget
	- isSolid
	- isType
	- playSound
	- refresh
	- remove
	- reprocessTexts
	- scrollIntoView
	- setScissor, unsetScissor
	- showMenu
	- updateLayout
	- Event: beforedraw, afterdraw
	- Event: close, closed
	- Event: focused, blurred
	- Event: init
	- Event: keypressed
	- Event: layout
	- Event: mousepressed, mousemoved, mousereleased
	- Event: navigated
	- Event: pressed
	- Event: refresh
	- Event: show, hide
	- Event: textinput
	- Event: update
	- Event: wheelmoved

	container
	- canScrollAny, canScrollX, canScrollY
	- find, findAll, findType, findActive, findToggled, match, matchAll
	- get, children
	- getChildAreaDimensions, getChildAreaWidth, getChildAreaHeight
	- getChildWithData
	- getElementAt
	- getInnerSpace, getInnerSpaceX, getInnerSpaceY
	- getPadding, getPaddingLeft, getPaddingRight, getPaddingTop, getPaddingBottom, setPadding
	- getScroll, getScrollX, getScrollY, setScroll, setScrollX, setScrollY, scroll
	- getScrollHandleX, getScrollHandleY
	- getScrollLimit, getScrollLimitX, getScrollLimitY
	- getToggledChild, setToggledChild
	- getVisibleChild, getVisibleChildNumber, getVisibleChildCount, setVisibleChild
	- getVisualScroll, getVisualScrollX, getVisualScrollY
	- indexOf
	- insert, removeAt, empty
	- isScrollbarXHovered, isScrollbarYHovered, isScrollbarXHandleHovered, isScrollbarYHandleHovered
	- isScrollingX, isScrollingY
	- setChildrenActive
	- setChildrenHidden
	- sort
	- traverse, traverseType, traverseVisible

		(bar)

			hbar

			vbar

		root
		- setDimensions

	(leaf)
	- drawText, drawAlignedText
	- getAlign, setAlign
	- getFont, getResultingFont, setFont, useFont
	- getMnemonicOffset
	- getText, getUnprocessedText, setText
	- getTextColor, setTextColor, hasTextColor, useTextColor

		canvas
		- getCanvasBackgroundColor, setCanvasBackgroundColor
		- Event: draw

		image
		- Includes: imageInclude

		text

		(widget)
		- getPriority, setPriority
		- isActive, setActive
		- Event: navigate
		- Event: navupdate

			button
			- Includes: imageInclude
			- drawText2, drawAlignedText2
			- getArrow
			- getText2, getUnprocessedText2, setText2
			- isPressable, setPressable
			- isToggled, setToggled
			- press, isPressed
			- Event: press
			- Event: toggle

			input
			- drawValue, drawPlaceholder, drawValueOrPlaceholder, drawSelections
			- focus, blur, isFocused
			- getBlinkPhase
			- getField
			- getFieldType, setFieldType
			- getValue, setValue, getVisibleValue
			- getValueLayout, getCursorLayout
			- Event: change
			- Event: submit
			- Event: valuechange



	Includes
	----------------------------------------------------------------

	imageInclude
	- drawImage
	- getImageBackgroundColor, setImageBackgroundColor, hasImageBackgroundColor, useImageBackgroundColor
	- getImageColor, setImageColor, hasImageColor, useImageColor
	- getImageDimensions, setImageSize, maximizeImageSize
	- getImageScale, getImageScaleX, getImageScaleY, setImageScale, setImageScaleX, setImageScaleY
	- getSprite, setSprite, hasSprite



	Utilities
	----------------------------------------------------------------

	clamp, clamp01, clamp11
	create9SliceQuads
	draw9SliceScaled, draw9SliceRepeated
	getDefaultFont
	lerp, lerpColor
	newMonochromeImage, newImageUsingPalette
	parseTargetAndEvent
	round
	setColor



--============================================================]]



!local DEFAULT_SCROLL_SPEED      = 3.5
!local DEFAULT_SCROLL_SMOOTHNESS = 60

!local DEFAULT_TOOLTIP_DELAY = 0.15

!local TAU               = 2*math.pi
!local UTF8_CHAR_PATTERN = "[%z\1-\127\194-\244][\128-\191]*" -- utf8.charpattern
!local MOUSE_POS_UNKNOWN = -999999

!local LG = `love.graphics`
!local LM = `love.mouse`



local setColor = $LG.setColor

if love.getVersion() < 11 then
	local _setColor = setColor
	function setColor(r, g, b, a)
		_setColor(r*255, g*255, b*255, (a and a*255))
	end
end

local newClass   = (function()  @insert "src/class.lua"       end)()
local InputField = (function()  @insert "src/InputField.lua"  end)()



local COLOR_WHITE             = {1,1,1,1}
local COLOR_TRANSPARENT_WHITE = {1,1,1,0}

local LCTRL = (love.system.getOS() == "OS X") and "lgui" or "lctrl"
local RCTRL = (love.system.getOS() == "OS X") and "rgui" or "rctrl"

local _M = { -- The module.
	_VERSION = "0.2.0",
}

local Gui = newClass("Gui", {
	VALUE_MASK_INT    =  "^%-?%d+$",       -- Integer.  @Revise these masks.
	VALUE_MASK_UINT   =  "^%d+$",          -- Unsigned integer.
	VALUE_MASK_FLOAT  =  "^%-?%d+%.?%d*$", -- Floating point number.
	VALUE_MASK_UFLOAT =  "^%d+%.?%d*$",    -- Unsigned floating point number.

	_allAnimations      = nil,
	_animationLockCount = 0,

	_font        = nil, -- May be overridden by individual leaves.
	_fontTooltip = nil,

	_defaultSounds = nil,
	_soundPlayer   = nil, -- soundPlayer = function( sound )

	_scrollSoundSuppressionLevel = 0,

	_scissorCoordsConverter = nil,
	_elementScissorIsSet    = false,

	_mouseX                 = !(MOUSE_POS_UNKNOWN),
	_mouseY                 = !(MOUSE_POS_UNKNOWN),
	_mouseFocus             = nil,
	_mouseFocusButtonStates = nil,
	_mouseIsGrabbed         = false,
	_currentMouseCursor     = nil,

	_keyboardFocus                = nil,
	_ignoreKeyboardInputThisFrame = false,

	_standardKeysAreActive        = false,
	_standardKeysAreActiveInMenus = true,

	_navigationTarget    = nil,
	_timeSinceNavigation = 0.0,
	_lockNavigation      = false, -- True when an input has keyboard focus.

	_scrollSpeedX     = !(DEFAULT_SCROLL_SPEED),
	_scrollSpeedY     = !(DEFAULT_SCROLL_SPEED),
	_scrollSmoothness = !(DEFAULT_SCROLL_SMOOTHNESS),

	_time        = 0.0,
	_tooltipTime = 0.0,

	_tooltipDelay = !(DEFAULT_TOOLTIP_DELAY),

	_theme  = nil,
	_styles = nil,

	_root           = nil,
	_hoveredElement = nil,

	_lastAutomaticId = 0,

	_layoutNeedsUpdate = false,
	_isUpdatingLayout  = false,
	_layoutUpdateTime  = 0.00,

	_textPreprocessor = nil, -- newText       = function( text, element, mnemonicsAreEnabled )
	_spriteLoader     = nil, -- image, frames = function( spriteName )

	_culling = true, -- Affects scrollables and root.

	_heres = nil,

	debug = false,
})

local Cs = {} -- gui element Classes.
local Is = {} -- gui element Includes.

local validSoundKeys = {
	-- Generic.
	["close" ] = true, -- Usually containers, but any element can be a closable.
	["focus" ] = true, -- Only used by Inputs so far.
	["press" ] = true, -- Buttons.
	["toggle"] = true, -- Buttons. Overrides "press".
	["scroll"] = true, -- Containers.

	-- Element specific.
	["inputsubmit"] = true,
	["inputrevert"] = true,
}

local defaultTheme

--{STATICS}



--==============================================================
--= Local functions ============================================
--==============================================================

local F = string.format



-- printf( formatString, ... )
local function printf(s, ...)
	print(F(s, ...))
end

-- printerr( depth, formatString, ... )
-- warn( depth, formatString, ... )
local function printerr(depth, s, ...)
	local time    = require"socket".gettime()
	local timeStr = os.date("%H:%M:%S", time)
	local msStr   = F("%.3f", time%1):sub(2)
	io.stderr:write(debug.traceback(F("[%s%s] Error: "..s, timeStr, msStr, ...), 1+depth), "\n")
end
local function warn(depth, s, ...)
	local time    = require"socket".gettime()
	local timeStr = os.date("%H:%M:%S", time)
	local msStr   = F("%.3f", time%1):sub(2)
	io.stderr:write(debug.traceback(F("[%s%s] Warning: "..s, timeStr, msStr, ...), 1+depth), "\n")
end



-- errorf( [ level=1, ] formatString, ... )
local function errorf(i, s, ...)
	if type(i) == "number" then
		error(F(s, ...), 1+i)
	else
		error(F(i, s, ...), 2)
	end
end

local function argerror(errLevel, argN, argName, v, ...)
	errorf(
		1+errLevel,
		"Bad argument #%d (%s) to '%s'. (Expected %s, got %s)",
		argN,
		argName,
		debug.getinfo(errLevel, "n").name or "?",
		table.concat({...}, " or "),
		type(v)
	)
end

!(
local LUA_TYPES = {["boolean"]=true, ["function"]=true, ["nil"]=true, ["number"]=true, ["string"]=true, ["table"]=true, ["thread"]=true, ["userdata"]=true}

local function ARGS(levelAndArgs)
	local errLevel, argsStr = levelAndArgs:match"^(%S+) (%S.*)$"
	if not argsStr then  error("Bad levelAndArgs format: "..levelAndArgs, 2)  end

	local lineSep = "\n" .. ("\t"):rep(#getOutputSoFarOnLine())

	local optionalPos = argsStr:find("?", 1, true) or #argsStr
	local argN        = 1
	local argsWritten = 0

	for pos, argNames, types in argsStr:gmatch"()([%w_,]+):([%w_,*]+)" do
		if types == "*" then
			argN = argN + #argNames:gsub("[^,]+", "") + 1

		else
			if pos > optionalPos then  types = types..",nil"  end

			for argName in argNames:gmatch"[%w_]+" do
				local conditions
				if types:find(",", 1, true) then
					conditions = {}
					for typeName in types:gmatch"[%w_]+" do
						table.insert(conditions, string.format("type(%s)==%q", argName, typeName))
					end
					conditions = string.format("not(%s)", table.concat(conditions, " or "))
				else
					conditions = string.format("type(%s)~=%q", argName, types)
				end

				conditions = (conditions
					:gsub('type%(([%w_]+)%)([~=]=)"nil"', "%1%2nil")
					:gsub('type%(([%w_]+)%)([~=]=)"(%w+)"', function(var, eq, typeName)
						if not LUA_TYPES[typeName] then
							return string.format("%s(type(%s)=='userdata'and(%s):typeOf%q)", (eq=="==" and "" or "not"), var, var, typeName)
						end
					end)
				)

				__LUA(string.format(
					"%sif %s then argerror(%s,%d,%q,%s,%s) end",
					(argsWritten == 0) and "" or lineSep,
					conditions,
					errLevel,
					argN,
					argName,
					argName,
					types:gsub("[%w_]+", '"%0"'),
				nil))

				argN        = argN        + 1
				argsWritten = argsWritten + 1
			end
		end
	end
end
)



-- class = newElementClass( abstract, className, parentClass|nil, includes, classTable, events )
local function newElementClass(abstract, className, parentClass, includes, classTable, events)
	classTable._abstract = abstract
	local class          = parentClass and parentClass:extend(className, classTable) or newClass(className, classTable)

	-- Include includes.
	for _, includeName in ipairs(includes) do
		for k, v in pairs(Is[includeName]) do
			@@ASSERT(class[k] == nil, k) -- An include should only add new stuff to classes, not override anything.
			class[k] = v
		end
	end

	-- Register events.
	for i, event in ipairs(class._events) do
		table.insert(events, i, event)
	end
	for i, event in ipairs(events) do
		events[event] = true
	end
	class._events = events

	return class
end



local function applyStyle(elData, styleData)
	for i, childStyleData in ipairs(styleData) do
		if elData[i] == nil then
			error("Cannot apply style. (Missing children.)")
		end
		applyStyle(elData[i], childStyleData)
	end
	for k, v in pairs(styleData) do
		if elData[k] == nil then  elData[k] = v  end
	end
end



local function checkValidSoundKey(soundK, errLevel)
	if soundK == nil or validSoundKeys[soundK] then  return  end

	local keys = {}
	for soundK in pairs(validSoundKeys) do
		table.insert(keys, soundK)
	end
	table.sort(keys)

	errorf(1+errLevel, "Bad sound key '%s'. (Must be any of '%s'.)", soundK, table.concat(keys, "', '"))
end



-- @Memory: Don't use this, yo!
-- iterator, coroutine = newIteratorCoroutine( callback, argument1, ... )
local newIteratorCoroutine
do
	-- ... = coroutineIterator( coroutine )
	local function coroutineIterator(co)
		return select(2, assert(coroutine.resume(co)))
	end
	local function initiator(cb, ...)
		coroutine.yield()
		return cb(...)
	end
	function newIteratorCoroutine(cb, ...)
		local co = coroutine.create(initiator)
		coroutine.resume(co, cb, ...)
		return coroutineIterator, co
	end
end



-- x, y, width, height = xywhOnScreen( element ) -- @Cleanup: Use getLayoutOnScreen().
local function xywhOnScreen(el)
	local x, y = el:getPositionOnScreen()
	return x, y, el._layoutWidth, el._layoutHeight
end



-- drawImageScaled( image,quad , x,y, scaleX,scaleY )
-- drawImageScaled( image,nil  , x,y, scaleX,scaleY )
-- drawImageScaled( nil  ,image, x,y, scaleX,scaleY )
local function drawImageScaled(image,quadOrImage, x,y, sx,sy)
	if image and quadOrImage then
		$LG.draw(image,quadOrImage, x,y, 0, sx,sy)
	else
		$LG.draw((image or quadOrImage), x,y, 0, sx,sy)
	end
end

local tempQuad = love.graphics.newQuad(0,0, 1,1, 1,1)

-- drawImageLimited( image,quad , x,y, width,height, maxX,maxY )
-- drawImageLimited( image,nil  , x,y, width,height, maxX,maxY )
-- drawImageLimited( nil  ,image, x,y, width,height, maxX,maxY )
local function drawImageLimited(image,quadOrImage, x,y, w,h, maxX,maxY)
	if x+w < maxX and y+h < maxY then
		if image and quadOrImage then
			$LG.draw(image,quadOrImage, x,y)
		else
			$LG.draw((image or quadOrImage), x,y)
		end

	else
		local qx,qy, qw,qh, iw,ih

		if image and quadOrImage then
			iw, ih       = image:getDimensions()
			qx,qy, qw,qh = quadOrImage:getViewport()
		else
			image        = image or quadOrImage
			iw, ih       = image:getDimensions()
			qx,qy, qw,qh = 0,0, iw,ih
		end

		qw = math.min(qw, maxX-x)
		qh = math.min(qh, maxY-y)

		tempQuad:setViewport(qx,qy, qw,qh, iw,ih)
		$LG.draw(image,tempQuad, x,y)
	end
end



-- width, height = getTextDimensions( font, text, wrapLimit )
local function getTextDimensions(font, text, wrapLimit)
	local w, lines = font:getWrap(text, wrapLimit)
	local h        = font:getHeight()
	return w, h + math.floor(h*font:getLineHeight()) * (math.max(#lines, 1)-1)
end



-- elementType = getTypeFromElementData( elementData )
local function getTypeFromElementData(elData)
	if not elData.type and type(elData[1]) == "string" then
		elData.type = table.remove(elData, 1)
	end
	return elData.type
end



-- index = indexOf( array, value )
-- index = indexOf( container, element )
local function indexOf(arr, v)
	for i, item in ipairs(arr) do
		if item == v then  return i  end
	end
	return nil
end



-- for index, item in ipairsr( table )
local ipairsr
do
	local function iprev(arr, i)
		i       = i - 1
		local v = arr[i]
		if v ~= nil then  return i, v  end
	end
	function ipairsr(arr)
		return iprev, arr, #arr+1
	end
end



local function lerp(v1, v2, t)
	return v1 + (v2-v1) * t
end

local function damp(current, target, lambda, dt)
	-- http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
	return lerp(current, target, 1-math.exp(-lambda*dt))
end



-- matches = matchAll( string, pattern )
local function matchAll(s, pat)
	local matches, i = {}, 0
	for match in s:gmatch(pat) do
		i = i+1
		matches[i] = match
	end
	return matches
end



-- sprite = newSprite( image, quad|frames|nil, errorLevel )
-- frames = { frame1, ... }
-- frame  = { duration=duration, quad=quad }
local function newSprite(image, framesOrQuad, errLevel)
	!ARGS"1+errLevel image:Image framesOrQuad:Quad,table,nil"
	local frames

	if not framesOrQuad then
		local iw, ih = image:getDimensions()
		frames = {{duration=1/0, quad=$LG.newQuad(0, 0, iw, ih, iw, ih)}}

	elseif type(framesOrQuad) == "userdata" then
		frames = {{duration=1/0, quad=framesOrQuad}}

	else
		frames = framesOrQuad
		if not frames[1] then
			error("The frames table is empty. We need at least one frame!", 1+errLevel)
		end
		for i, frame in ipairs(frames) do
			if not frame.duration then  errorf(1+errLevel, "Frame %d is missing a duration.", i)  end
			if not frame.quad     then  errorf(1+errLevel, "Frame %d is missing a quad."    , i)  end
		end
	end

	local duration = 0
	for _, frame in ipairs(frames) do
		duration = duration + frame.duration
	end

	local _, _, iw, ih = frames[1].quad:getViewport()

	local sprite = {
		image        = image,

		frames       = frames,

		width        = iw,
		height       = ih,

		length       = #frames,
		duration     = duration,

		currentFrame = 1,
		currentTime  = 0.0,
	}

	return sprite
end

-- -- clone = cloneSprite( sprite, errorLevel )
-- local function cloneSprite(sprite, errLevel)
-- 	return (newSprite(sprite.image, sprite.frames, 1+errLevel))
-- end

-- image, quad, width, height = getCurrentViewOfSprite( sprite )
local function getCurrentViewOfSprite(sprite)
	local quad = sprite.frames[sprite.currentFrame].quad
	local _, _, w, h = quad:getViewport()
	return sprite.image, quad, w, h
end

-- updateSprite( sprite, deltaTime )
local function updateSprite(sprite, dt)
	if sprite.length == 1 then  return  end

	local frames = sprite.frames

	local i      = sprite.currentFrame
	local time   = sprite.currentTime + dt

	while time >= frames[i].duration do
		time = time - frames[i].duration
		i    = i % sprite.length + 1
	end

	sprite.currentFrame = i
	sprite.currentTime  = time
end



-- selectorPath = parseSelector( selector )
-- selector     = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Returns nil if the selector is empty or invalid.
local parseSelector
do
	local selPathCache = {}

	function parseSelector(selector)
		local selPath = selPathCache[selector]
		if selPath then  return selPath  end

		selPath = {}

		for section in selector:gmatch"[^ ]+" do
			local selPathSection = {}
			local i = 1
			while true do

				local c = section:sub(i, i)
				if c == "" then
					break
				end

				local selPathSegment

				-- ID
				if c == "#" then
					local id
					id, i = section:match("^([^#.]+)()", i+1)
					if not id then
						printerr(1, "Bad format in selector at '%s'.", section:sub(i))
						return nil
					end
					selPathSegment = {type="id", value=id}

				-- Tag
				elseif c == "." then
					local tag
					tag, i = section:match("^([^#.]+)()", i+1)
					if not tag then
						printerr(1, "Bad format in selector at '%s'.", section:sub(i))
						return nil
					end
					selPathSegment = {type="tag", value=tag}

				-- Element type
				else
					local elType
					elType, i = section:match("^([^#.]+)()", i)
					if not elType then
						printerr(1, "Bad format in selector at '%s'.", section:sub(i))
						return nil
					elseif not Cs[elType] then
						printerr(1, "Unknown element type '%s' in selector.", elType)
						return nil
					end
					selPathSegment = {type="type", value=elType}

				end
				table.insert(selPathSection, selPathSegment)
			end
			table.insert(selPath, selPathSection)
		end

		if not selPath[1] then
			return nil -- The selector was either empty or filled with just spaces.
		end

		selPathCache[selector] = selPath

		return selPath
	end
end

-- result = isElementMatchingSelectorPath( element, selectorPath [, breakElement ] )
-- The path match checking loop breaks before reaching 'breakElement'.
local isElementMatchingSelectorPath
do
	local function isMatchingSection(el, selPathSection)
		for _, selPathSegment in ipairs(selPathSection) do
			-- ID
			if selPathSegment.type == "id" then
				if el._id ~= selPathSegment.value then  return false  end

			-- Tag
			elseif selPathSegment.type == "tag" then
				if not el:hasTag(selPathSegment.value) then  return false  end

			-- Element type
			else--if selPathSegment.type == "type" then
				if not el:isType(selPathSegment.value) then  return false  end
			end
		end

		return true
	end

	function isElementMatchingSelectorPath(el, selPath, breakElement)
		local i = #selPath

		local selPathSection = selPath[i]
		if not selPathSection then
			return false -- An empty path means nothing can match!
		end

		if el == breakElement then
			return false -- We got to the break point before matching the whole path.
		end
		if isMatchingSection(el, selPathSection) then
			i = i-1
			selPathSection = selPath[i]
			if not selPathSection then
				return true -- The whole path (with only one section) matched.
			end
		else
			return false -- The last section must match the specified element, but didn't.
		end

		for _, parent in el:parents() do
			if parent == breakElement then
				return false -- We got to the break point before matching the whole path.
			end
			if isMatchingSection(parent, selPathSection) then
				i = i-1
				selPathSection = selPath[i]
				if not selPathSection then
					return true -- The whole path matched.
				end
			end
		end

		return false -- We went through all parents without matching the whole path.
	end
end



--
-- playSoundFunction = prepareSound( element, soundKey )
--
-- Prepare a sound for being played. Useful if it's possible the element will
-- be removed in an event. Returns nil if no sound will be played.
--
local function prepareSound(el, soundK)
	local gui         = el._gui
	local soundPlayer = gui and gui._soundPlayer
	local sound       = soundPlayer and el:getResultingSound(soundK)

	return (sound ~= nil) and function()soundPlayer(sound)end or nil
end



-- text = preprocessText( gui, text, el, hasMnemonics )
local function preprocessText(gui, unprocessedText, el, hasMnemonics)
	if unprocessedText == "" then  return ""  end

	local preprocessor = gui._textPreprocessor
	if not preprocessor then  return unprocessedText  end

	local text = preprocessor(unprocessedText, el, hasMnemonics)
	if text == nil then  return unprocessedText  end

	return tostring(text)
end



local function printHere(el0)
	local ids = {}
	local el  = el0

	repeat
		if not el._automaticId then  table.insert(ids, 1, el._id)  end
		el = el._parent
	until not el

	ids[1] = ids[1] or el0:getPathDescription()
	print("[Gui] HERE:  "..table.concat(ids, "."))
	-- ids[1] = ids[1] or "~"
	-- printf("[Gui] HERE:  %s  (%s)", table.concat(ids, "."), el0:getPathDescription())
end

local function printHeres(gui)
	local heres = gui._heres
	for i, el in ipairs(heres) do
		printHere(el)
		heres[i] = nil
	end
end



-- class = requireElementClass( elementType, errorLevel )
local function requireElementClass(elType, level)
	return Cs[elType] or errorf(1+level, "Bad element type '%s'.", elType)
end



!(
-- @@retrieve( element, elementData, property1, ... )
local function retrieve(el, elData, ...)
	for i = 1, select("#", ...) do
		local k     = select(i, ...)
		local kData = k:sub(2)
		__LUA("if ",elData,".",kData," ~= nil then ",el,".",k," = ",elData,".",kData," end ")
	end
end
)



local function reverseArray(arr)
	local lenPlusOne = #arr + 1

	for i1 = 1, #arr/2 do
		local i2         = lenPlusOne - i1
		arr[i1], arr[i2] = arr[i2], arr[i1]
	end
end



-- integer = round( number )
local function round(n)
	return math.floor(n+0.5)
end



local function setMouseFocus(gui, mbutton, el)
	if gui._mouseFocus and el ~= gui._mouseFocus then
		printerr(1, "Changing mouse focus without blurring the old focus first.")
		gui._mouseFocusButtonStates[1] = false
		gui._mouseFocusButtonStates[2] = false
		gui._mouseFocusButtonStates[3] = false
	end

	gui._mouseFocus                      = el
	gui._mouseFocusButtonStates[mbutton] = true
	$LM.setGrabbed(true)
end

-- blurMouseFocus( gui, mbutton=all )
local function blurMouseFocus(gui, mbutton)
	if mbutton then
		gui._mouseFocusButtonStates[mbutton] = false
	else
		gui._mouseFocusButtonStates[1] = false
		gui._mouseFocusButtonStates[2] = false
		gui._mouseFocusButtonStates[3] = false
	end

	if not (gui._mouseFocusButtonStates[1] or gui._mouseFocusButtonStates[2] or gui._mouseFocusButtonStates[3]) then
		gui._mouseFocus = nil
		$LM.setGrabbed(gui._mouseIsGrabbed)
	end
end



local function setKeyboardFocus(gui, el)
	gui._keyboardFocus = el
end

local function blurKeyboardFocus(gui)
	gui._keyboardFocus = nil
end



-- setScissor( gui, x, y, width, height ) -- Push scissor.
-- setScissor( gui, nil ) -- Pop scissor.
-- Must be called twice - first with arguments, then without!
local function setScissor(gui, x, y, w, h)
	if not x then
		$LG.pop()
		return
	end

	local convert = gui._scissorCoordsConverter
	if convert then
		x, y, w, h = convert(x, y, w, h)
	end

	$LG.push("all")
	$LG.intersectScissor(x, y, math.max(w, 0), math.max(h, 0))
end

-- Note: Does not push or pop state like setScissor()!
local function intersectScissor(gui, x, y, w, h)
	local convert = gui._scissorCoordsConverter
	if convert then
		x, y, w, h = convert(x, y, w, h)
	end
	$LG.intersectScissor(x, y, w, h)
end



-- value1, ... = themeCallBack( gui, sectionKey, what, argument1, ... )
local function themeCallBack(gui, k, what, ...)
	local section = gui._theme and gui._theme[k]
	local cb      = (section and section[what] or defaultTheme[k][what]) or errorf(2, "Missing default theme callback for '%s.%s'.", k, what)
	return cb(...)
end

-- value = themeGet( gui, key )
local function themeGet(gui, k)
	local v = gui._theme and gui._theme[k]
	if v == nil then
		return defaultTheme[k]
	end
	return v
end

-- themeRenderOnScreen( element, what, x, y, w, h, extraArgument1, ... )
local function themeRenderOnScreen(el, what, x, y, w, h, ...)
	if w <= 0 or h <= 0 then  return  end

	$LG.push("all")
	$LG.translate(x, y)

	themeCallBack(el._gui, "draw", what, el, w, h, ...)
	el:unsetScissor() -- In case the theme set one but didn't unset it.

	$LG.pop()
end

-- themeRenderArea( element, what, areaX, areaY, areaWidth, areaHeight, extraArgument1, ... )
local function themeRenderArea(el, what, areaX, areaY, areaW, areaH, ...)
	local x = round(el:getXOnScreen()+areaX)
	local y = round(el:getYOnScreen()+areaY)
	return themeRenderOnScreen(el, what, x, y, areaW, areaH, ...)
end

-- themeRender( element, what, extraArgument1, ... )
local function themeRender(el, what, ...)
	return themeRenderArea(el, what, 0, 0, el._layoutWidth, el._layoutHeight, ...)
end

-- width, height = themeGetSize( element, what, extraArgument1, ... )
local function themeGetSize(el, what, ...)
	local w, h = themeCallBack(el._gui, "size", what, el, ...)
	if not (type(w) == "number" and type(h) == "number") then
		errorf(2, "Theme (or default theme) did not return width and height for '%s', instead we got: %s, %s", what, tostring(w), tostring(h))
	end
	return w, h
end



local function drawLayoutBackground(el)
	if el._background == "" then  return  end

	if el._gui.debug then
		setColor(.27, .27, .27, .86)
		$LG.rectangle("fill", xywhOnScreen(el))
	else
		themeRender(el, "background", el._background)
	end
end



-- value = trigger( element, event, value1, ... )
local function trigger(el, event, ...)
	local cb = el._callbacks and el._callbacks[event]
	if not cb then  return nil  end

	return (cb(el, event, ...))
end

-- value = triggerIncludingAnimations( element, event, value, ... )
local function triggerIncludingAnimations(el, event, ...)
	if el._animations then
		local time = el._gui._time

		for _, anim in ipairs(el._animations) do
			local cb = anim.callbacks[event]
			if cb then  cb(el, event, (time-anim.startTime)/anim.duration, ...)  end
		end
	end

	return (trigger(el, event, ...))
end



local function updateHoveredElement(gui)
	local el = (gui._mouseX ~= !(MOUSE_POS_UNKNOWN)) and gui:getElementAt(gui._mouseX, gui._mouseY, false) or nil
	if gui._hoveredElement == el then  return  end

	local oldEl         = gui._hoveredElement
	gui._hoveredElement = el

	if not (el and oldEl and el._tooltip ~= "" and oldEl._tooltip ~= "" and gui._tooltipTime >= gui._tooltipDelay) then
		-- @UX: Don't reset tooltip time instantly - add a delay.
		gui._tooltipTime = 0
	end
end

-- Removes current navigation target if it isn't a valid target anymore.
local function validateNavigationTarget(gui)
	local nav = gui._navigationTarget
	if nav and not gui:canNavigateTo(nav) then
		gui:navigateTo(nil)
	end
end



-- didUpdate = updateLayout( element )
local function updateLayout(el)
	-- Guard against accidental recursion (specifically the 'layout' event
	-- callback triggering an update... though maybe the 'layout' event is a
	-- bad idea to begin with... need to mention this in the docs).
	local gui = el._gui
	if gui._isUpdatingLayout then  return false  end -- The returned value is confusing here as we didn't update, but someone else is in the middle of it!

	local root = el:getRoot() -- @Temp
	-- local container = el -- @Incomplete @Speed: Maybe make any element able to update it's layout. (See comment below.)
	if root._hidden then
		gui._layoutNeedsUpdate = false
		return false
	end

	if gui.debug then
		print("Gui: Updating layout.")
	end
	gui._isUpdatingLayout = true

	local getTime = (love.timer and love.timer.getTime) or (pcall(require, "socket") and require"socket".gettime) or os.clock
	local time    = getTime()

	root:_calculateNaturalSize()

	--
	-- Note: This currently, most likely only works correctly if 'container'
	-- is the root. (I think we need to save the last values we use and know
	-- if the parent would change size if we changed size. All the extra work
	-- may be expensive and not worth it in the end. 2022-03-28)
	--
	root._layoutWidth  = root._width
	root._layoutHeight = root._height
	root:_expandAndPositionChildren()

	gui._layoutUpdateTime  = getTime() - time -- We don't include the time the layout event takes.
	gui._layoutNeedsUpdate = false

	root:visitVisible(@@LAMBDA(triggerIncludingAnimations, function(innerEl)
		triggerIncludingAnimations(innerEl, "layout")
	end))

	updateHoveredElement(gui)

	gui._isUpdatingLayout = false
	if gui.debug then
		print("Gui: Finished updating layout.")
	end
	return true
end

-- didUpdate = updateLayoutIfNeeded( gui )
local function updateLayoutIfNeeded(gui)
	if not gui._layoutNeedsUpdate then  return false  end
	if gui._isUpdatingLayout      then  return false  end
	gui._layoutNeedsUpdate = false

	local root = gui._root
	if not root then  return false  end

	return (updateLayout(root))
end

local function scheduleLayoutUpdateIfDisplayed(el)
	local gui = el._gui
	if gui._layoutNeedsUpdate then  return  end
	if gui._isUpdatingLayout  then  return  end

	gui._layoutNeedsUpdate = el:isDisplayed()
	if gui.debug and gui._layoutNeedsUpdate then
		print("Gui: Scheduling layout update.")
	end
end



local function setVisualScroll(container, scrollX, scrollY)
	local dx = scrollX - container._visualScrollX
	local dy = scrollY - container._visualScrollY

	local didScroll = false

	if dx ~= 0 then
		container._visualScrollX = container._visualScrollX + dx
		didScroll                = true
	end

	if dy ~= 0 then
		container._visualScrollY = container._visualScrollY + dy
		didScroll                = true
	end

	if not didScroll then  return  end

	for el in container:traverse() do
		el._layoutOffsetX = el._layoutOffsetX + dx
		el._layoutOffsetY = el._layoutOffsetY + dy
	end

	updateHoveredElement(container._gui)
end



-- useColor( color [, alphaMultiplier=1 ] )
local function useColor(color, opacity)
	local r, g, b, a = unpack(color)
	if opacity then
		a = (a or 1) * opacity
	end
	setColor(r, g, b, a)
end



local function clamp(v, vMin, vMax)
	return math.max(math.min(v, vMax), vMin)
end

local function clamp01(v)
	return math.max(math.min(v, 1), 0)
end

local function clamp11(v)
	return math.max(math.min(v, 1), -1)
end



----------------------------------------------------------------
-- Layout functions.
----------------------------------------------------------------



local function calculateContainerChildNaturalSizes(container)
	for _, child in ipairs(container) do
		if not child._hidden then
			child:_calculateNaturalSize()
		end
	end
end



-- <see_return_statement> = barGetNaturalSizeValues( bar )
local function barGetNaturalSizeValues(bar)
	--[[ Examples how homogeneous+weight affect sizes:
	--------------------------------

	input  [A][B][CCCC]
	weight 1  1  2

	minw=3
	maxw=6

	output [A][B][CCCC]

	minw=3
	maxw=6

	A=1*minw
	B=1*minw
	C=2*minw

	--------------------------------

	input  [A][B][CCCC]
	weight 2  1  1

	minw=3
	maxw=6

	output [A~~~~~~~~~][B~~~][CCCC]

	minw=6
	maxw=12

	A=2*minw
	B=1*minw
	C=1*minw

	------------------------------]]

	local staticW, dynamicW, highestW, highestDynamicW = 0, 0, 0, 0 -- Note: highestDynamic* is weighted.
	local staticH, dynamicH, highestH, highestDynamicH = 0, 0, 0, 0

	local currentSpaceX = 0
	local currentSpaceY = 0
	local sumSpaceX     = 0
	local sumSpaceY     = 0
	local first         = true

	local totalWeight = 0

	local homogeneous = bar._homogeneous
	local max         = math.max

	for _, child in ipairs(bar) do
		if not (child._hidden or child._floating) then
			-- Dimensions.
			highestW = max(highestW, child._layoutWidth)
			highestH = max(highestH, child._layoutHeight)

			if child._weight == 0 then
				staticW = staticW + child._layoutWidth
				staticH = staticH + child._layoutHeight
			else
				if child:hasFixedWidth() and not homogeneous then
					staticW = staticW + child._width
				else
					dynamicW        = dynamicW + child._layoutWidth -- Includes relative size.
					highestDynamicW = max(highestDynamicW, child._layoutWidth/child._weight)
				end
				if child:hasFixedHeight() and not homogeneous then
					staticH = staticH + child._height
				else
					dynamicH        = dynamicH + child._layoutHeight -- Includes relative size.
					highestDynamicH = max(highestDynamicH, child._layoutHeight/child._weight)
				end
			end

			-- Spacing.
			if not first then
				currentSpaceX = max(currentSpaceX, child._spacingLeft)
				currentSpaceY = max(currentSpaceY, child._spacingTop )
			end
			sumSpaceX     = sumSpaceX + currentSpaceX
			sumSpaceY     = sumSpaceY + currentSpaceY
			currentSpaceX = child._spacingRight
			currentSpaceY = child._spacingBottom
			first         = false

			-- Weight.
			totalWeight = totalWeight + child._weight
		end
	end

	return staticW, dynamicW, highestW, highestDynamicW, sumSpaceX,
	       staticH, dynamicH, highestH, highestDynamicH, sumSpaceY,
	       totalWeight
end



local function updateContainerNaturalSize(container, contentW, contentH)
	local w = container._width -- May be negative, which means dynamic (i.e. hasDynamic*() should return true).
	local h = container._height

	container._contentWidth  = container:hasFixedWidth () and w-container:getInnerSpaceX() or contentW
	container._contentHeight = container:hasFixedHeight() and h-container:getInnerSpaceY() or contentH

	if container:hasDynamicWidth() then
		w = math.max(container._contentWidth+container:getInnerSpaceX(), container._minWidth)
		if container._maxWidth >= 0 then  w = math.min(w, container._maxWidth)  end
	end
	if container:hasDynamicHeight() then
		h = math.max(container._contentHeight+container:getInnerSpaceY(), container._minHeight)
		if container._maxHeight >= 0 then  h = math.min(h, container._maxHeight)  end
	end

	container._layoutWidth  = w
	container._layoutHeight = h
end

local function applySizeLimits(el, w, h)
	w = math.max(w, el._minWidth )
	h = math.max(h, el._minHeight)

	if el._maxWidth  >= 0 then  w = math.min(w, el._maxWidth )  end
	if el._maxHeight >= 0 then  h = math.min(h, el._maxHeight)  end

	return w, h
end

local function expandAndPositionFloatingElement(el, expansionW, expansionH)
	el._layoutWidth, el._layoutHeight = applySizeLimits(el
		, el:hasRelativeWidth()  and expansionW*el._relativeWidth  or el._layoutWidth
		, el:hasRelativeHeight() and expansionH*el._relativeHeight or el._layoutHeight
	)

	local parent = el._parent

	if parent then
		el._layoutX = round(0
			+ parent._layoutX
			+ parent._paddingLeft
			+ el._originX * (parent._layoutWidth - parent:getInnerSpaceX())
			+ el._x
			- el._anchorX * el._layoutWidth
		)
		el._layoutY = round(0
			+ parent._layoutY
			+ parent._paddingTop
			+ el._originY * (parent._layoutHeight - parent:getInnerSpaceY())
			+ el._y
			- el._anchorY * el._layoutHeight
		)
	end

	el:_expandAndPositionChildren()
end



--==============================================================
--= Library functions ==========================================
--==============================================================



-- quads = Gui.create9SliceQuads( image, leftColumnSize, topRowSize [, rightColumnSize=leftColumnSize, bottomRowSize=topRowSize ] )
-- quads = {
--     topLeftQuad,    topCenterQuad,    topRightQuad,
--     middleLeftQuad, middleCenterQuad, middleRightQuad,
--     bottomLeftQuad, bottomCenterQuad, bottomRightQuad,
-- }
function _M.create9SliceQuads(image, l, t, r, b)
	r = r or l
	b = b or t
	local iw, ih = image:getDimensions()
	return {
		$LG.newQuad(   0,    0,      l,      t, iw, ih),
		$LG.newQuad(   l,    0, iw-l-r,      t, iw, ih),
		$LG.newQuad(iw-r,    0,      r,      t, iw, ih),
		$LG.newQuad(   0,    t,      l, ih-t-b, iw, ih),
		$LG.newQuad(   l,    t, iw-l-r, ih-t-b, iw, ih),
		$LG.newQuad(iw-r,    t,      r, ih-t-b, iw, ih),
		$LG.newQuad(   0, ih-b,      l,      b, iw, ih),
		$LG.newQuad(   l, ih-b, iw-l-r,      b, iw, ih),
		$LG.newQuad(iw-r, ih-b,      r,      b, iw, ih),
	}
end



-- Gui.draw9SliceScaled(
--     x, y, width, height,
--     topLeftImage,    topCenterImage,    topRightImage,
--     middleLeftImage, middleCenterImage, middleRightImage,
--     bottomLeftImage, bottomCenterImage, bottomRightImage
-- )
-- Gui.draw9SliceScaled(
--     x, y, width, height, image,
--     topLeftQuad,    topCenterQuad,    topRightQuad,
--     middleLeftQuad, middleCenterQuad, middleRightQuad,
--     bottomLeftQuad, bottomCenterQuad, bottomRightQuad
-- )
function _M.draw9SliceScaled(x, y, w, h, image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32, obj33)
	if not obj33 then
		image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32, obj33 = nil,
		image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32
	end

	local t, l, r, b, sx, sy
	if image then
		local _, objW, objH
		_, _, l, objH = obj21:getViewport()
		_, _, r       = obj23:getViewport()
		_, _, objW, t = obj12:getViewport()
		_, _, _,    b = obj32:getViewport()
		sx = (w-l-r) / objW
		sy = (h-t-b) / objH
	else
		l  = obj21:getWidth()
		r  = obj23:getWidth()
		t  = obj12:getHeight()
		b  = obj32:getHeight()
		sx = (w-l-r) / obj12:getWidth()
		sy = (h-t-b) / obj21:getHeight()
	end

	$LG.push()
	$LG.translate(x, y)

	-- Fill.
	drawImageScaled(image, obj22, l, t, sx, sy)

	-- Sides.
	drawImageScaled(image, obj12,   l,   0, sx,  1)
	drawImageScaled(image, obj23, w-r,   t,  1, sy)
	drawImageScaled(image, obj32,   l, h-b, sx,  1)
	drawImageScaled(image, obj21,   0,   t,  1, sy)

	-- Corners.
	drawImageScaled(image, obj11,   0,   0,  1,  1)
	drawImageScaled(image, obj13, w-r,   0,  1,  1)
	drawImageScaled(image, obj31,   0, h-b,  1,  1)
	drawImageScaled(image, obj33, w-r, h-b,  1,  1)

	$LG.pop()
end

-- Gui.draw9SliceRepeated(
--     x, y, width, height,
--     topLeftImage,    topCenterImage,    topRightImage,
--     middleLeftImage, middleCenterImage, middleRightImage,
--     bottomLeftImage, bottomCenterImage, bottomRightImage
-- )
-- Gui.draw9SliceRepeated(
--     x, y, width, height, image,
--     topLeftQuad,    topCenterQuad,    topRightQuad,
--     middleLeftQuad, middleCenterQuad, middleRightQuad,
--     bottomLeftQuad, bottomCenterQuad, bottomRightQuad
-- )
function _M.draw9SliceRepeated(x, y, w, h, image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32, obj33)
	if not obj33 then
		image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32, obj33 = nil,
		image, obj11, obj12, obj13, obj21, obj22, obj23, obj31, obj32
	end

	local t, l, r, b, segW, segH
	if image then
		local _
		_, _, l   , t    = obj11:getViewport()
		_, _, r   , b    = obj33:getViewport()
		_, _, segW, segH = obj22:getViewport()
	else
		l   , t    = obj11:getDimensions()
		r   , b    = obj33:getDimensions()
		segW, segH = obj22:getDimensions()
	end

	$LG.push()
	$LG.translate(x, y)

	-- Fill.
	local maxX = w - r
	local maxY = h - b

	local segY = t
	while segY < maxY do
		local segX = l
		while segX < maxX do
			drawImageLimited(image,obj22, segX,segY, segW,segH, maxX,maxY)
			segX = segX + segW
		end
		segY = segY + segH
	end

	-- Sides: top and bottom.
	local segX = l
	while segX < maxX do
		drawImageLimited(image,obj12, segX,0  , segW,0, maxX,1/0)
		drawImageLimited(image,obj32, segX,h-t, segW,0, maxX,1/0)
		segX = segX + segW
	end

	-- Sides: left and right.
	local segY = t
	while segY < maxX do
		drawImageLimited(image,obj21, 0  ,segY, 0,segH, 1/0,maxY)
		drawImageLimited(image,obj23, w-l,segY, 0,segH, 1/0,maxY)
		segY = segY + segH
	end

	-- Corners.
	drawImageScaled(image, obj11,   0,   0, 1, 1)
	drawImageScaled(image, obj13, w-r,   0, 1, 1)
	drawImageScaled(image, obj31,   0, h-b, 1, 1)
	drawImageScaled(image, obj33, w-r, h-b, 1, 1)

	$LG.pop()
end



--
-- image     = Gui.newMonochromeImage( pixelRows [, red=1, green=1, blue=1 ] )
-- pixelRows = { pixelRow1, ... }
-- pixelRow: String with single-digit hexadecimal numbers representing alpha values. Invalid characters count as 0 (transparent).
--
-- Example:
--     blurryDiagonalLine = Gui.newMonochromeImage{
--         " 5F",
--         "5F5",
--         "F5 ",
--     }
--
function _M.newMonochromeImage(pixelRows, r, g, b)
	r = r or 1
	g = g or 1
	b = b or 1

	local imageData = love.image.newImageData(#pixelRows[1], #pixelRows)

	for row, pixelRow in ipairs(pixelRows) do
		for col = 1, #pixelRow do
			local pixel = tonumber(pixelRow:sub(col, col), 16) or 0
			imageData:setPixel(col-1, row-1, r, g, b, pixel/15) -- @Speed
		end
	end

	return $LG.newImage(imageData)
end

--
-- image     = Gui.newImageUsingPalette( pixelRows, palette )
-- pixelRows = { pixelRow1, ... }
-- pixelRow: String with single-character palette indices. Invalid indices count as transparent pixels.
-- palette   = { ["index"]=color... }
-- color     = { red, green, blue [, alpha=1 ] }
--
-- Example:
--     doubleWideRainbow = Gui.newImageUsingPalette(
--         {
--             "rygcbp",
--             "rygcbp",
--         },
--         {
--             ["r"] = {1,0,0}, -- red
--             ["y"] = {1,1,0}, -- yellow
--             ["g"] = {0,1,0}, -- green
--             ["c"] = {0,1,1}, -- cyan
--             ["b"] = {0,0,1}, -- blue
--             ["p"] = {1,0,1}, -- purple
--         }
--     )
--
function _M.newImageUsingPalette(pixelRows, palette)
	local imageData = love.image.newImageData(#pixelRows[1], #pixelRows)

	for row, pixelRow in ipairs(pixelRows) do
		for col = 1, #pixelRow do
			local pixel      = (palette[pixelRow:sub(col, col)] or COLOR_TRANSPARENT_WHITE)
			local r, g, b, a = unpack(pixel)
			imageData:setPixel(col-1, row-1, r, g, b, (a or 1)) -- @Speed
		end
	end

	return $LG.newImage(imageData)
end



-- target, event  = Gui.parseTargetAndEvent( targetAndEvent )
-- targetAndEvent = "ID.subID.anotherSubID.event" -- Sequence of dot-separated IDs followed by a dot and an event name.
-- Returns nil and a message on error.
function _M.parseTargetAndEvent(targetAndEvent)
	local target, event = targetAndEvent:match"^(.-)%.?([^.]+)$" -- @Revise
	if not target then
		return nil, F("Bad targetAndEvent format '%s'.", targetAndEvent)
	end
	return target, event
end



-- value = Gui.lerp( value1, value2, t )
-- Linear interpolation.
_M.lerp = lerp

-- r, g, b    = Gui.lerpColor( r1,g1,b1,    r2,g2,b2,    t )
-- r, g, b, a = Gui.lerpColor( r1,g1,b1,a1, r2,g2,b2,a2, t )
-- Linear interpolation for color components.
function _M.lerpColor(r1,g1,b1,a1, r2,g2,b2,a2, t)
	if a2 then
		return lerp(r1, r2, t), lerp(g1, g2, t), lerp(b1, b2, t), lerp(a1, a2, t)
	else
		r2,g2,b2, t = a1, r2,g2,b2
		return lerp(r1, r2, t), lerp(g1, g2, t), lerp(b1, b2, t)
	end
end



-- Gui.setColor( red, green, blue [, alpha=1 ] )
-- Set the current color in LÖVE. Color component values are within
-- the range of 0 to 1 (even in LÖVE versions prior to 11.0).
_M.setColor = setColor



-- value = Gui.clamp( value, min, max )
-- Clamp a value between two other values.
_M.clamp = clamp

-- value = Gui.clamp01( value )
-- Clamp a value between 0 and 1.
_M.clamp01 = clamp01

-- value = Gui.clamp11( value )
-- Clamp a value between -1 and +1.
_M.clamp11 = clamp11



local defaultFont = nil

-- font = Gui.getDefaultFont()
function _M.getDefaultFont()
	defaultFont = defaultFont or $LG.newFont(12)
	return defaultFont
end



--==============================================================
--= GUI class ==================================================
--==============================================================



-- Gui( )
function Gui.init(gui)
	gui._allAnimations = {}
	gui._defaultSounds = {}
	gui._heres         = {}

	gui._soundPlayer = love.audio.play

	gui._mouseFocusButtonStates = {false, false, false} -- We only handle mouse button 1-3.

	gui._styles = {
		["_MENU"] = {},
	}
end



-- gui:update( deltaTime )
function Gui.update(gui, dt)
	local time               = gui._time + dt
	gui._time                = time
	gui._tooltipTime         = gui._tooltipTime + dt
	gui._timeSinceNavigation = gui._timeSinceNavigation + dt

	local allAnims = gui._allAnimations

	if allAnims[1] then
		for iInAllAnims, anim in ipairsr(allAnims) do
			local el = anim.element

			if time >= anim.endTime then
				local cb = anim.callbacks["update"]
				if cb then  cb(el, "update", 1)  end -- Make sure 'update' gets progress=1.

				cb = anim.callbacks["done"]
				if cb then  cb(el, "done")  end

				local anims = el._animations       or error("Internal error: Element has an animation but has no animation table.")
				local i     = indexOf(anims, anim) or error("Internal error: Element is part of an animation that is not in its animation table.")

				table.remove(allAnims, iInAllAnims)
				table.remove(anims   , i          )

				if anim.lockInteraction then
					gui._animationLockCount = gui._animationLockCount-1
				end

			else
				local cb = anim.callbacks["update"]
				if cb then
					cb(el, "update", (time-anim.startTime)/anim.duration)
				end
			end
		end

		if gui._animationLockCount == 0 then
			updateHoveredElement(gui)
		end
	end

	if gui._root then
		gui._root:_update(dt)

		if gui._root:isVisible() then
			trigger(gui._root, "update", dt)

			gui._root:visitVisible(@@LAMBDA(trigger, dt, function(el)
				trigger(el, "update", dt)
			end))
		end
	end

	-- The navigation target has a special additional update event.
	local nav = gui._navigationTarget
	if nav then  trigger(nav, "navupdate", dt)  end

	-- Check if mouse is inside window.
	if gui._mouseX ~= !(MOUSE_POS_UNKNOWN) and not love.window.hasMouseFocus() then
		gui:mousemoved(!(MOUSE_POS_UNKNOWN), !(MOUSE_POS_UNKNOWN))
	end

	--
	-- Update mouse cursor.
	--
	local el  = gui._mouseFocus or gui._hoveredElement
	local cur = el and el:getResultingMouseCursor()

	if gui._currentMouseCursor ~= cur then
		gui._currentMouseCursor = cur
		$LM.setCursor(cur)
	end

	gui._ignoreKeyboardInputThisFrame = false
end



-- gui:draw( )
function Gui.draw(gui)
	if gui._root and not gui._root._hidden then
		updateLayoutIfNeeded(gui)

		--
		-- Prepare navigation target. @Speed
		--
		local childToDrawNavTargetAfter = gui._navigationTarget

		if childToDrawNavTargetAfter then  while childToDrawNavTargetAfter._parent do
			local parent = childToDrawNavTargetAfter._parent

			-- Draw at the current floating element. (All children of non-bar containers are floating.)
			if not parent:is(Cs.bar) then
				break

			else
				-- Draw before the next floating sibling if there are any. Hopefully the user
				-- has placed all significant floating elements high up in the tree and not
				-- inside non-floating wrappers!
				for i = childToDrawNavTargetAfter:getIndex()+1, #parent do
					if parent[i]._floating then
						childToDrawNavTargetAfter = parent[i-1]
						break
					end
				end

				-- Confine to scrollable area.
				if parent:canScrollAny() then
					childToDrawNavTargetAfter = parent[#parent]
					break
				end
			end

			childToDrawNavTargetAfter = parent
		end end

		--
		-- Draw stuff.
		--
		local cullX1, cullY1, cullX2, cullY2
		if gui._culling then
			local rootX, rootY, rootW, rootH = gui._root:getLayout()
			cullX1 = rootX
			cullY1 = rootY
			cullX2 = rootX + rootW
			cullY2 = rootY + rootH
		else
			cullX1 = -1/0
			cullY1 = -1/0
			cullX2 = 1/0
			cullY2 = 1/0
		end

		gui._root:_draw(cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)

		if gui._hoveredElement and not gui._mouseFocus then
			gui._hoveredElement:_drawTooltip()
		else
			gui._tooltipTime = 0 -- @Cleanup: We currently reset this in two places.
		end
	end
end



-- handled = gui:keypressed( key, scancode, isRepeat )
function Gui.keypressed(gui, key, scancode, isRepeat)
	!ARGS"2 key,scancode:string isRepeat:boolean"

	if gui._ignoreKeyboardInputThisFrame then  return true  end
	if gui._animationLockCount > 0       then  return true  end

	local focus = gui._keyboardFocus or gui._mouseFocus
	local el    = focus or gui._hoveredElement or gui._navigationTarget or gui:getInputCapturingElement(true) or gui._root

	if el then
		if focus then
			if trigger(focus,     "keypressed", key, scancode, isRepeat) then  return true  end -- The focus has exclusive rights to the event. No bubbling!
		else
			if el:triggerBubbling("keypressed", key, scancode, isRepeat) then  return true  end
		end

		local handled, grabKbFocus = el:_keypressed(key, scancode, isRepeat) -- @Cleanup: I don't think grabKbFocus is ever true.

		if handled then
			if grabKbFocus then  setKeyboardFocus(gui, el)  end
			return true
		end
	end

	if focus then  return true  end

	if gui._standardKeysAreActive then
		if key == "right" then
			gui:navigate(0)
			return true
		elseif key == "down" then
			gui:navigate(!(TAU/4))
			return true
		elseif key == "left" then
			gui:navigate(!(TAU/2))
			return true
		elseif key == "up" then
			gui:navigate(!(-TAU/4))
			return true

		elseif key == "tab" then
			if love.keyboard.isDown("lshift","rshift") then
				gui:navigateToPrevious()
			else
				gui:navigateToNext()
			end
			return true

		elseif key == "return" or key == "kpenter" then
			if gui:ok() then  return true  end

		elseif key == "escape" then
			if gui:back() then  return true  end
		end
	end

	local root = gui._root

	if root and not root._hidden then
		local elToClose = nil

		for _, el in ipairs(root:_collectVisibleUntilInputCapture(@@STATIC{})) do
			if key == "escape" and el:canClose() then
				elToClose = el
				break
			elseif el._captureInput then
				return true
			elseif el._captureGuiInput then
				break
			end
		end

		if elToClose then
			elToClose:close()
			return true
		end
	end

	return false
end

-- handled = gui:keyreleased( key, scancode )
function Gui.keyreleased(gui, key, scancode)
	!ARGS"2 key,scancode:string"

	if gui._keyboardFocus then
		gui._keyboardFocus:_keyreleased(key, scancode)
		return true
	end

	return false
end

-- handled = gui:textinput( text )
function Gui.textinput(gui, text)
	!ARGS"2 text:string"

	if gui._animationLockCount > 0 then  return true  end

	local focus = gui._keyboardFocus or gui._mouseFocus
	local el    = focus or gui._hoveredElement

	if gui._ignoreKeyboardInputThisFrame then
		return el ~= nil
	end

	el = el or gui._navigationTarget -- Can this be on the 'el' declaration line?

	if el then
		if not focus and el:triggerBubbling("textinput", text) then  return true  end

		if el:_textinput(text) then  return true  end
	end

	if focus then  return true  end

	local root = gui._root

	if root and not root._hidden then
		for _, el in ipairs(root:_collectVisibleUntilInputCapture(@@STATIC{})) do
			if el._captureInput    then  return true  end
			if el._captureGuiInput then  break        end
		end
	end

	return false
end



-- handled = gui:mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Gui.mousepressed(gui, mx, my, mbutton, pressCount)
	!ARGS"2 mx,my,mbutton,pressCount:number"
	if mbutton > 3 then  return false  end

	gui._mouseX = mx
	gui._mouseY = my

	if gui._animationLockCount > 0 then  return true  end

	if gui._mouseFocusButtonStates[mbutton] then
		-- The mouse button got pressed twice or more with no release inbetween.
		-- Should be an error, but it's not really an issue.
		return true
	end

	updateLayoutIfNeeded(gui) -- Updates hovered element.

	local mouseFocus = gui._mouseFocus
	local currentEl  = mouseFocus or gui._hoveredElement

	if gui._keyboardFocus and currentEl ~= gui._keyboardFocus then
		gui._keyboardFocus:blur() -- We assume this is a GuiInput. @Volatile
	end

	while currentEl do
		-- Trigger any custom mousepressed event handler.
		-- Returning true from the handler suppresses the default behavior.
		local screenX, screenY = currentEl:getPositionOnScreen()
		if currentEl:trigger("mousepressed", mx-screenX, my-screenY, mbutton, pressCount) then
			return true
		end

		-- Trigger the internal mousepressed event handler.
		local handled, grabMouseFocus = currentEl:_mousepressed(mx, my, mbutton, pressCount)
		if handled then
			if grabMouseFocus then  setMouseFocus(gui, mbutton, currentEl)  end
			return true
		end

		if mouseFocus or currentEl._captureInput or currentEl._captureGuiInput or currentEl:isSolid() then
			return true
		end

		currentEl = currentEl._parent
	end

	return false
end

-- handled = gui:mousemoved( mouseX, mouseY )
function Gui.mousemoved(gui, mx, my)
	!ARGS"2 mx,my:number"

	gui._mouseX = mx
	gui._mouseY = my

	if gui._animationLockCount > 0 then  return true  end

	if not updateLayoutIfNeeded(gui) then
		updateHoveredElement(gui) -- Make sure hovered element updates whenever mouse moves.
	end

	local focus = gui._mouseFocus
	if not focus then  return false  end

	local el = (mx and focus or gui._hoveredElement)
	if el then
		el:_mousemoved(mx, my)
		trigger(el, "mousemoved", mx-el:getXOnScreen(), my-el:getYOnScreen())
	end

	return true
end

-- handled = gui:mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Gui.mousereleased(gui, mx, my, mbutton, pressCount)
	!ARGS"2 mx,my,mbutton,pressCount:number"
	if mbutton > 3 then  return false  end

	gui._mouseX = mx
	gui._mouseY = my

	local focus = gui._mouseFocus
	if not (focus and gui._mouseFocusButtonStates[mbutton]) then
		return false
	end

	blurMouseFocus(gui, mbutton)
	updateLayoutIfNeeded(gui) -- Updates hovered element.

	local el = focus or gui._hoveredElement
	if el then
		el:_mousereleased(mx, my, mbutton, pressCount)
	end

	if el then
		trigger(el, "mousereleased", mx-el:getXOnScreen(), my-el:getYOnScreen(), mbutton, pressCount)
	end

	return true
end

-- handled = gui:wheelmoved( dx, dy )
function Gui.wheelmoved(gui, dx, dy)
	!ARGS"2 dx,dy:number"

	if gui._animationLockCount > 0 then  return true  end

	local isScroll = (dx ~= 0 or dy ~= 0)

	-- Shift key swaps X and Y scrolling.
	local dx0 = dx
	local dy0 = dy
	if love.keyboard.isDown("lshift","rshift") then
		dx, dy = dy, dx
	end

	local focus = gui._mouseFocus
	if not focus then
		updateLayoutIfNeeded(gui) -- Updates hovered element.
	end

	-- Focus (non-bubbling event)
	-- OR hovered element (bubbling event).
	local el         = focus or gui._hoveredElement
	local anyIsSolid = false

	while el do
		if isScroll then
			-- Trigger any custom wheelmoved event handler.
			-- Returning true from the handler suppresses the default behavior.
			if el:trigger("wheelmoved", dx, dy) then  return true  end

			if el:_wheelmoved(dx, dy, dx0, dy0) then  return true  end
		end

		if focus then  return focus:isSolid()  end

		anyIsSolid = anyIsSolid or el:isSolid()
		el         = el._parent
	end

	return anyIsSolid
end



--==============================================================



-- bool = gui:areStandardKeysActive( )
-- bool = gui:areStandardKeysActiveInMenus( )
function Gui.areStandardKeysActive(gui)
	return gui._standardKeysAreActive
end
function Gui.areStandardKeysActiveInMenus(gui)
	return gui._standardKeysAreActiveInMenus
end

-- gui:setStandardKeysActive( bool )
-- gui:setStandardKeysActiveInMenus( bool )
function Gui.setStandardKeysActive(gui, active)
	gui._standardKeysAreActive = active
end
function Gui.setStandardKeysActiveInMenus(gui, active)
	gui._standardKeysAreActiveInMenus = active
end



-- gui:blur( )
function Gui.blur(gui)
	if gui._mouseFocus then
		for mbutton, state in ipairs(gui._mouseFocusButtonStates) do
			if state then
				gui:mousereleased(gui._mouseX, gui._mouseY, mbutton, 1--[[ @Polish: Keep track of pressCount. ]])
			end
		end
	end

	blurMouseFocus(gui, nil)

	if gui._keyboardFocus then
		gui._keyboardFocus:blur() -- We assume this is a GuiInput. @Volatile
	end
end



--
-- gui:defineStyle( styleName, styleData )
-- styleData = { parameter1=value, ..., [1]=child1StyleData, ... }
--
-- Examples:
--     gui:defineStyle("centered", {originX=.5, originY=.5, anchorX=.5, anchorY=.5})
--     gui:defineStyle("dialogHeader", {background="header",
--         [2] = {minWidth=200, textColor={1,1,1,.86}}, -- Style data for the second child.
--     })
--
-- @Incomplete: A way to specify style for a child (or grandchild?) by ID.
--
function Gui.defineStyle(gui, styleName, styleData)
	!ARGS"2 styleName:string styleData:table"
	gui._styles[styleName] = styleData
end



-- element = gui:find( id )
function Gui.find(gui, id)
	local root = gui._root
	return root and (root._id == id and root or root:find(id))
end

-- elements = gui:findAll( id )
function Gui.findAll(gui, id)
	local root = gui._root
	if not root then  return {}  end

	local els = root:findAll(id)
	if root._id == id then
		table.insert(els, 1, root)
	end

	return els
end

-- element = gui:findActive( )
function Gui.findActive(gui)
	local root = gui._root
	return root and root:findActive()
end

-- element = gui:findToggled( )
function Gui.findToggled(gui)
	local root = gui._root
	return root and root:findToggled()
end

-- Match an element using a CSS-like selector.
-- element  = gui:match( selector )
-- selector = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Gui.match(gui, selector)
	local root = gui._root
	if not root then  return nil  end
	return (root:match(selector, true))
end

-- Match elements using a CSS-like selector.
-- elements = gui:matchAll( selector )
-- selector = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Gui.matchAll(gui, selector)
	local root = gui._root
	if not root then  return {}  end
	return (root:matchAll(selector, true))
end



-- sound = gui:getDefaultSound( soundKey )
function Gui.getDefaultSound(gui, soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	return gui._defaultSounds[soundK]
end

-- gui:setDefaultSound( soundKey, sound )
-- gui:setDefaultSound( soundKey, nil ) -- Remove default sound.
-- Note: 'sound' is the value sent to the GUI sound player callback.
function Gui.setDefaultSound(gui, soundK, sound)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	gui._defaultSounds[soundK] = sound
end



-- element = gui:getElementAt( x, y [, includeNonSolid=false ] )
function Gui.getElementAt(gui, x, y, nonSolid)
	local root = gui._root
	if root and not root._hidden then
		return root:getElementAt(x, y, nonSolid)
	end
	return nil
end



-- font|nil = gui:getFont( )
-- font|nil = gui:getTooltipFont( )
function Gui.getFont       (gui)  return gui._font         end
function Gui.getTooltipFont(gui)  return gui._fontTooltip  end

-- gui:setFont( font|nil )
-- gui:setTooltipFont( font|nil )
-- A nil font will result in a default font being used.
function Gui.setFont(gui, font)
	!ARGS"2 font:Font,nil"
	if gui._font == font then  return  end
	gui._font              = font
	gui._layoutNeedsUpdate = true
end
function Gui.setTooltipFont(gui, font)
	!ARGS"2 font:Font,nil"
	gui._fontTooltip = font -- No need to update layout for tooltips currently. :CacheTooltipValues
end



-- element = gui:getHoveredElement( )
function Gui.getHoveredElement(gui)
	return gui._hoveredElement
end



do
	local function setNavigationTarget(gui, widget)
		if gui._navigationTarget == widget then  return false  end -- No change.

		gui._navigationTarget    = widget
		gui._timeSinceNavigation = 0

		if widget then  widget:scrollIntoView(false)  end

		;(widget or gui._root):triggerBubbling("navigated", widget)

		return true -- Change happened!
	end

	-- widget = gui:getNavigationTarget( )
	function Gui.getNavigationTarget(gui)
		return gui._navigationTarget
	end

	-- success = gui:navigateTo( widget )
	function Gui.navigateTo(gui, widget)
		if gui._navigationTarget == widget then  return true   end
		if gui._lockNavigation             then  return false  end
		if not gui:canNavigateTo(widget)   then  return false  end
		setNavigationTarget(gui, widget)
		return true
	end

	do
		local function navigateToNextOrPrevious(gui, id, allowNone, usePrev)
			local root = gui._root
			if not root or root._hidden then  return nil  end

			local nav = gui._navigationTarget
			if not nav and not usePrev then  return gui:navigateToFirst()  end

			local foundNav   = false
			local lastWidget = nil

			for _, el in ipairs((nav and nav:getNavigationRoot() or root):_collectVisibleUntilInputCapture(@@STATIC{})) do
				-- Note: Remember that we're traversing backwards.
				local elIsValid = el:is(Cs.widget) and (not id or el._id == id)

				if elIsValid and usePrev and foundNav then
					setNavigationTarget(gui, el)
					return el
				end

				foundNav = (foundNav or el == nav)

				if not usePrev and foundNav then
					if lastWidget or allowNone then
						setNavigationTarget(gui, lastWidget)
						return lastWidget
					end
					return nav
				end

				if elIsValid then  lastWidget = el  end
			end

			if not allowNone then  return nav  end

			setNavigationTarget(gui, nil)
			return nil
		end

		-- element = gui:navigateToNext( [ id=any, allowNone=false ] )
		-- Note: Calls gui:navigateToFirst() if there's no current navigation target.
		function Gui.navigateToNext(gui, id, allowNone)
			return (navigateToNextOrPrevious(gui, id, allowNone, false))
		end

		-- element = gui:navigateToPrevious( [ id=any, allowNone=false ] )
		function Gui.navigateToPrevious(gui, id, allowNone)
			return (navigateToNextOrPrevious(gui, id, allowNone, true))
		end
	end

	-- element = gui:navigateToFirst( )
	function Gui.navigateToFirst(gui)
		if gui._lockNavigation then  return nil  end

		local root = gui._root
		if not root or root._hidden then  return nil  end

		local first = nil

		for _, el in ipairs(root:_collectVisibleUntilInputCapture(@@STATIC{})) do
			if el:is(Cs.widget) and not (first and first._priority > el._priority) then
				first = el
			end
		end

		setNavigationTarget(gui, first)
		return first
	end

	-- landingElement = gui:navigate( angle )
	function Gui.navigate(gui, angle)
		if gui._lockNavigation then  return nil  end

		local root = gui._root
		if not root or root._hidden then  return nil  end

		local nav = gui._navigationTarget
		if not nav then  return gui:navigateToFirst()  end

		if trigger(nav, "navigate", angle) then
			return gui._navigationTarget -- Suppress default behavior.
		end

		local closestEl = nav:getClosestInDirection(angle)
		if closestEl then
			setNavigationTarget(gui, closestEl)
		end

		return closestEl or nav
	end

	-- bool = gui:canNavigateTo( element|nil )
	-- Note: Does not check if navigation is locked.
	function Gui.canNavigateTo(gui, widget)
		if widget == nil            then  return true   end -- Navigation target can always be nothing.
		if not widget:is(Cs.widget) then  return false  end
		if not widget:isDisplayed() then  return false  end

		local root = gui._root
		if not root or root._hidden then  return false  end

		for _, el in ipairs(root:_collectVisibleUntilInputCapture(@@STATIC{})) do
			if el == widget then
				return true
			elseif el._captureInput or el._captureGuiInput then
				return false
			end
		end

		error("Somehow the element is a displayed active widget but not among the visible elements under the root.")
	end
end



-- root = gui:getRoot( )
function Gui.getRoot(gui)
	return gui._root
end



-- converter|nil = gui:getScissorCoordsConverter( )
function Gui.getScissorCoordsConverter(gui)
	return gui._scissorCoordsConverter
end

--
-- gui:setScissorCoordsConverter( converter|nil )
-- x, y, width, height = converter( x, y, width, height )
--
-- If the graphics transform is changed outside the GUI system then a scissor
-- coordinate converter is needed for scissoring to work properly.
--
function Gui.setScissorCoordsConverter(gui, converter)
	gui._scissorCoordsConverter = converter
end



-- speedX, speedY = gui:getScrollSpeed( )
function Gui.getScrollSpeed(gui)
	return gui._scrollSpeedX, gui._scrollSpeedY
end

-- gui:setScrollSpeed( speedX [, speedY=speedX ] )
-- Note: The scroll speed is relative to the GUI's font size (gui:getFont() or Gui.getDefaultFont()).
function Gui.setScrollSpeed(gui, speedX, speedY)
	!ARGS"2 speedX:number ? speedY:number"
	gui._scrollSpeedX = speedX
	gui._scrollSpeedY = speedY or speedX
end



-- smoothness = gui:getScrollSmoothness( )
function Gui.getScrollSmoothness(gui)
	return gui._scrollSmoothness
end

-- gui:setScrollSmoothness( smoothness )
-- 0 disables smoothness.
function Gui.setScrollSmoothness(gui, smoothness)
	!ARGS"2 smoothness:number"
	gui._scrollSmoothness = math.max(smoothness, 0)
end



-- soundPlayer = gui:getSoundPlayer( )
function Gui.getSoundPlayer(gui)
	return gui._soundPlayer
end

-- gui:setSoundPlayer( soundPlayer|nil )
-- soundPlayer = function( sound )
function Gui.setSoundPlayer(gui, soundPlayer)
	gui._soundPlayer = soundPlayer
end



-- spriteLoader = gui:getSpriteLoader( )
function Gui.getSpriteLoader(gui)
	return gui._spriteLoader
end

-- gui:setSpriteLoader( spriteLoader|nil )
-- image, frames = spriteLoader( spriteName )
-- frames        = { frame1, ... }
-- frame         = { duration=duration, quad=quad }
function Gui.setSpriteLoader(gui, spriteLoader)
	gui._spriteLoader = spriteLoader
end



-- targetElement = gui:getTarget( target )
-- target        = "ID.subID.anotherSubID" -- Sequence of dot-separated IDs.
-- Returns nil and a message on error.
function Gui.getTarget(gui, target)
	local el = gui._root
	if not el then  return nil, "There is no root element."  end

	local ids = matchAll(target, "[^.]+") -- @Memory

	for i = 1, #ids do
		if not el:is(Cs.container) then
			return false, F("'%s' is not a container.", el._id)
		end

		el = el:find(ids[i])
		if not el then
			return nil, F("'%s' does not exist in '%s'.", ids[i], (ids[i-1] or "root"))
		end
	end

	return el
end

-- callback       = gui:getTargetCallback( targetAndEvent )
-- targetAndEvent = "ID.subID.anotherSubID.event" -- Sequence of dot-separated IDs followed by a dot and an event name.
-- Returns nil and a message on error.
-- Returns nil (and no message) if there's no callback.
function Gui.getTargetCallback(gui, targetAndEvent)
	local target, eventOrErr = _M.parseTargetAndEvent(targetAndEvent)
	if not target then  return nil, eventOrErr  end

	local el, err = gui:getTarget(target)
	if not el then  return nil, err  end

	return el:getCallback(eventOrErr)
end

-- targetElement  = gui:setTargetCallback( targetAndEvent, callback|nil )
-- targetAndEvent = "ID.subID.anotherSubID.event" -- Sequence of dot-separated IDs followed by a dot and an event name.
-- Returns nil and a message on error.
function Gui.setTargetCallback(gui, targetAndEvent, cb)
	local target, eventOrErr = _M.parseTargetAndEvent(targetAndEvent)
	if not target then  return nil, eventOrErr  end

	local el, err = gui:getTarget(target)
	if not el then  return nil, err  end

	el:on(eventOrErr, cb)
	return el
end



-- textPreprocessor|nil = gui:getTextPreprocessor( )
function Gui.getTextPreprocessor(gui)
	return gui._textPreprocessor
end

-- gui:setTextPreprocessor( textPreprocessor|nil )
-- newText = textPreprocessor( text, element, mnemonicsAreEnabled )
function Gui.setTextPreprocessor(gui, func)
	!ARGS"2 func:function,nil"
	if gui._textPreprocessor == func then  return  end
	gui._textPreprocessor = func
	gui:reprocessTexts() -- @Speed: Maybe add a system for scheduling reprocessing of texts. (Probably not necessary.)
end

-- gui:reprocessTexts( )
-- Manually re-preprocess texts. Useful if e.g. the program's language has changed.
function Gui.reprocessTexts(gui)
	if gui._root then
		gui._root:reprocessTexts()
	end
end



-- theme|nil = gui:getTheme( )
function Gui.getTheme(gui)
	return gui._theme
end

-- gui:setTheme( theme|nil )
function Gui.setTheme(gui, theme)
	!ARGS"2 theme:table,nil"
	if gui._theme == theme then  return  end
	gui._theme             = theme
	gui._layoutNeedsUpdate = true
end



-- delay = gui:getTooltipDelay( )
function Gui.getTooltipDelay(gui)
	return gui._tooltipDelay
end

-- gui:setTooltipDelay( delay )
function Gui.setTooltipDelay(gui, delay)
	!ARGS"2 delay:number"
	gui._tooltipDelay = delay
end



-- time = gui:getTime( )
function Gui.getTime(gui)
	return gui._time
end

-- time = gui:getTimeSinceNavigation( )
function Gui.getTimeSinceNavigation(gui)
	return gui._timeSinceNavigation
end



-- bool = gui:isBusy( )
function Gui.isBusy(gui)
	return gui:isKeyboardBusy() or gui:isMouseBusy()
end

-- bool = gui:isKeyboardBusy( )
function Gui.isKeyboardBusy(gui)
	return gui._keyboardFocus ~= nil
end

-- bool = gui:isMouseBusy( )
function Gui.isMouseBusy(gui)
	return gui._mouseFocus ~= nil
end



-- bool = gui:isIgnoringKeyboardInput( )
function Gui.isIgnoringKeyboardInput(gui)
	return gui._ignoreKeyboardInputThisFrame
end



-- bool = gui:isInputCaptured( [ includeGuiInput=false ] )
function Gui.isInputCaptured(gui, includeGuiInput) -- @Cleanup: Remove in favor of getInputCapturingElement.
	local root = gui._root
	if not root or root._hidden then  return false  end

	for _, el in ipairs(root:collectVisible(@@STATIC{})) do
		if el._captureInput or (includeGuiInput and el._captureGuiInput) then
			return true
		end
	end

	return false
end

-- element|nil = gui:getInputCapturingElement( [ includeGuiInput=false ] )
function Gui.getInputCapturingElement(gui, includeGuiInput)
	local root = gui._root
	if not root or root._hidden then  return false  end

	for _, el in ipairs(root:collectVisible(@@STATIC{})) do
		if el._captureInput or (includeGuiInput and el._captureGuiInput) then
			return el
		end
	end

	return nil
end



-- bool = gui:isInteractionLocked( )
function Gui.isInteractionLocked(gui)
	return gui._animationLockCount > 0
end



-- bool = gui:isMouseGrabbed( )
function Gui.isMouseGrabbed(gui)
	return gui._mouseIsGrabbed
end

-- gui:setMouseIsGrabbed( bool )
function Gui.setMouseIsGrabbed(gui, grabbed)
	gui._mouseIsGrabbed = grabbed
end



-- gui:load( elementData )
-- elementData = { type=elementType, parameter1=value, ..., [1]=child1Data, ... }
-- elementData = {      elementType, parameter1=value, ..., [1]=child1Data, ... }
function Gui.load(gui, elData)
	if getTypeFromElementData(elData) ~= "root" then
		errorf(2, "Gui root element must be of type 'root'.")
	end

	local root = Cs.root(gui, elData, nil)
	gui._root  = root

	printHeres(gui)

	local themeInit = themeGet(gui, "init")
	themeInit(root)
	for el in root:traverse() do
		themeInit(el)
	end

	gui._layoutNeedsUpdate = true
end



-- handled = gui:ok( )
-- Trigger 'ok' action.
function Gui.ok(gui)
	local nav = gui._navigationTarget
	if nav and nav._active then  return nav:_ok()  end
	return false
end

-- handled = gui:back( )
-- Trigger 'back' action.
function Gui.back(gui)
	local root = gui._root
	if not root or root._hidden then  return false  end

	-- Close closable (like Escape does).
	local elToClose = nil

	for _, el in ipairs(root:_collectVisibleUntilInputCapture(@@STATIC{})) do
		if el:canClose() then
			elToClose = el
			break
		end
	end

	if elToClose then
		elToClose:close()
		return true
	end

	return false
end



-- gui:updateLayout( )
-- Force a layout update. (Should never be needed as it's done automatically.)
function Gui.updateLayout(gui)
	local root = gui._root
	if root and not root._hidden then
		updateLayout(root)
	end
end

-- realTime = gui:getLayoutUpdateTime( )
-- Returns the time it took to update the layout the last time, or 0 if no update has occurred yet.
function Gui.getLayoutUpdateTime(gui)
	return gui._layoutUpdateTime
end



-- bool = gui:isCullingActive( )
function Gui.isCullingActive(gui)
	return gui._culling
end

-- gui:setCullingActive( bool )
function Gui.setCullingActive(gui, culling)
	gui._culling = culling
end



--==============================================================
--= Image include ==============================================
--==============================================================



Is.imageInclude = {
	-- Parameters.
	_imageBackgroundColor = nil,
	_imageColor           = nil,

	_imageScaleX = 1.0,
	_imageScaleY = 1.0,

	_sprite = nil,
	--

	_spriteName = nil,
}

local function initImageInclude(imageInc, elData)
	@@retrieve(imageInc, elData, _imageBackgroundColor)
	@@retrieve(imageInc, elData, _imageColor)
	-- @@retrieve(imageInc, elData, _imageScaleX,_imageScaleY)
	-- @@retrieve(imageInc, elData, _sprite)

	imageInc._imageScaleX = elData.imageScaleX or elData.imageScale
	imageInc._imageScaleY = elData.imageScaleY or elData.imageScale

	imageInc:setSprite(elData.sprite)
end



-- imageIncludeElement:drawImage( x, y )
function Is.imageInclude.drawImage(imageInc, x, y)
	if not imageInc._sprite then  return  end

	local image, quad = getCurrentViewOfSprite(imageInc._sprite)
	local padding     = imageInc:is(Cs.button) and imageInc._imagePadding or 0

	$LG.draw(image, quad, x+padding, y+padding, 0, imageInc._imageScaleX, imageInc._imageScaleY)
end



-- colorTable|nil = imageIncludeElement:getImageBackgroundColor( )
function Is.imageInclude.getImageBackgroundColor(imageInc)
	return imageInc._imageBackgroundColor
end

-- imageIncludeElement:setImageBackgroundColor( colorTable|nil )
function Is.imageInclude.setImageBackgroundColor(imageInc, color)
	imageInc._imageBackgroundColor = color
end

-- bool = imageIncludeElement:hasImageBackgroundColor( )
function Is.imageInclude.hasImageBackgroundColor(imageInc)
	return imageInc._imageBackgroundColor ~= nil
end

-- hasImageBackgroundColor = imageIncludeElement:useImageBackgroundColor( [ alphaMultiplier=1 ] )
-- Tell LÖVE to use the imageInclude's resulting image background color.
function Is.imageInclude.useImageBackgroundColor(imageInc, opacity)
	local color = imageInc._imageBackgroundColor
	useColor((color or COLOR_TRANSPARENT_WHITE), opacity)
	return color ~= nil
end



-- colorTable|nil = imageIncludeElement:getImageColor( )
function Is.imageInclude.getImageColor(imageInc)
	return imageInc._imageColor
end

-- imageIncludeElement:setImageColor( colorTable|nil )
function Is.imageInclude.setImageColor(imageInc, color)
	imageInc._imageColor = color
end

-- bool = imageIncludeElement:hasImageColor( )
function Is.imageInclude.hasImageColor(imageInc)
	return imageInc._imageColor ~= nil
end

-- hasImageColor = imageIncludeElement:useImageColor( [ alphaMultiplier=1 ] )
-- Tell LÖVE to use the imageInclude's resulting image color.
function Is.imageInclude.useImageColor(imageInc, opacity)
	local color = imageInc._imageColor
	useColor((color or COLOR_WHITE), opacity)
	return color ~= nil
end



-- width, height = imageIncludeElement:getImageDimensions( )
function Is.imageInclude.getImageDimensions(imageInc)
	local sprite = imageInc._sprite
	if not sprite then  return 0, 0  end
	return sprite.width, sprite.height
end

-- Sets the scale of the image by specifying a size. Does nothing if there's no image.
-- imageIncludeElement:setImageSize( width, height )
function Is.imageInclude.setImageSize(imageInc, w, h)
	local sprite = imageInc._sprite
	if not sprite then  return  end
	imageInc:setImageScale(w/sprite.width, h/sprite.height)
end

-- Scales the image so it fills the element. Does nothing if there's no image or if no dimensions are set.
-- imageIncludeElement:maximizeImageSize( [ extraWidth=0, extraHeight=0 ] )
function Is.imageInclude.maximizeImageSize(imageInc, extraW, extraH)
	local sprite = imageInc._sprite
	if not sprite then  return  end

	local paddingSum = imageInc:is(Cs.button) and 2*imageInc._imagePadding or 0

	local scaleX = imageInc:hasFixedWidth () and ((imageInc._width  - paddingSum + (extraH or 0)) / sprite.width ) or imageInc._imageScaleX
	local scaleY = imageInc:hasFixedHeight() and ((imageInc._height - paddingSum + (extraW or 0)) / sprite.height) or imageInc._imageScaleY
	imageInc:setImageScale(scaleX, scaleY)
end



-- scaleX, scaleY = imageIncludeElement:getImageScale( )
-- scale = imageIncludeElement:getImageScaleX( )
-- scale = imageIncludeElement:getImageScaleY( )
function Is.imageInclude.getImageScale(imageInc)
	return imageInc._imageScaleX, imageInc._imageScaleY
end
function Is.imageInclude.getImageScaleX(imageInc)
	return imageInc._imageScaleX
end
function Is.imageInclude.getImageScaleY(imageInc)
	return imageInc._imageScaleY
end

-- imageIncludeElement:setImageScale( scaleX [, scaleY=scaleX ] )
-- imageIncludeElement:setImageScaleX( scale )
-- imageIncludeElement:setImageScaleY( scale )
function Is.imageInclude.setImageScale(imageInc, sx, sy)
	!ARGS"2 sx:number ? sy:number"

	sy = sy or sx
	if imageInc._imageScaleX == sx and imageInc._imageScaleY == sy then  return  end

	imageInc._imageScaleX = sx
	imageInc._imageScaleY = sy
	if imageInc._sprite then  scheduleLayoutUpdateIfDisplayed(imageInc)  end
end
function Is.imageInclude.setImageScaleX(imageInc, sx)
	!ARGS"2 sx:number"
	if imageInc._imageScaleX == sx then  return  end

	imageInc:setImageScale(sx, imageInc._imageScaleY)
	if imageInc._sprite then  scheduleLayoutUpdateIfDisplayed(imageInc)  end
end
function Is.imageInclude.setImageScaleY(imageInc, sy)
	!ARGS"2 sy:number"
	if imageInc._imageScaleY == sy then  return  end

	imageInc:setImageScale(imageInc._imageScaleY, sy)
	if imageInc._sprite then  scheduleLayoutUpdateIfDisplayed(imageInc)  end
end



-- spriteName|nil = imageIncludeElement:getSprite( )
function Is.imageInclude.getSprite(imageInc)
	return imageInc._spriteName
end

-- imageIncludeElement:setSprite( image [, quad ] )
-- imageIncludeElement:setSprite( image, frames )
-- imageIncludeElement:setSprite( spriteName )
-- imageIncludeElement:setSprite( nil ) -- Remove sprite.
-- frames = { frame1, ... }
-- frame  = { duration=duration, quad=quad }
function Is.imageInclude.setSprite(imageInc, imageOrName, framesOrQuad)
	!ARGS"2 imageOrName:Image,string,nil"

	local image      = nil
	local spriteName = ""

	if type(imageOrName) == "string" then
		spriteName = imageOrName
		if spriteName ~= "" and spriteName == imageInc._spriteName then  return  end

		local spriteLoader = imageInc._gui._spriteLoader
		if not spriteLoader then
			printerr(2, "There is no sprite loader to convert the sprite name %q to a sprite.", spriteName)
			return
		end

		image, framesOrQuad = spriteLoader(spriteName)
		if not image then
			printerr(2, "The sprite loader did not return a required image for sprite name %q.", spriteName)
			return
		end

	elseif imageOrName then
		!ARGS"2 imageOrName:* framesOrQuad:Quad,table,nil"
		image = imageOrName
	end

	local oldIw = imageInc._sprite and imageInc._sprite.width  or 0
	local oldIh = imageInc._sprite and imageInc._sprite.height or 0

	imageInc._sprite     = image and newSprite(image, framesOrQuad, 2)
	imageInc._spriteName = spriteName

	local iw = imageInc._sprite and imageInc._sprite.width  or 0
	local ih = imageInc._sprite and imageInc._sprite.height or 0

	if not (iw == oldIw and ih == oldIh) then
		scheduleLayoutUpdateIfDisplayed(imageInc)
	end
end

-- bool = imageIncludeElement:hasSprite( )
function Is.imageInclude.hasSprite(imageInc)
	return imageInc._sprite ~= nil
end



--==============================================================
--= Element class (abstract) ===================================
--==============================================================



Cs.element = newElementClass(true, "GuiElement", nil, {}, {
	--[[STATIC]] _events = {--[[ event1, [event1]=true, ... ]]},

	-- Parameters.
	_id   = "",
	_data = nil,

	_hidden   = false,
	_floating = false, -- Disables natural positioning in certain parents (e.g. bars).
	_closable = false,

	_captureInput    = false, -- All input.
	_captureGuiInput = false, -- All input affecting GUI.

	_width          = -1, -- Negative means dynamic (unless relative size is set).
	_height         = -1,
	_relativeWidth  = -1, -- Negative means dynamic (unless fixed size is set).
	_relativeHeight = -1,

	_weight = 0, -- Weight of the element during expansion by the parent container. 0 means no expansion.

	_minWidth  = 0,
	_minHeight = 0,
	_maxWidth  = -1, -- Negative means no max limit.
	_maxHeight = -1,

	_x = 0, -- Offset from the origin.
	_y = 0,

	_originX = 0.0, -- Where in the parent to base x and y off.
	_originY = 0.0,

	_anchorX = 0.0, -- Where in self to base off x and y.
	_anchorY = 0.0,

	_spacingLeft   = 0, -- Falls back to 'spacingHorizontal' and 'spacing'.
	_spacingRight  = 0, -- Falls back to 'spacingHorizontal' and 'spacing'.
	_spacingTop    = 0, -- Falls back to 'spacingVertical' and 'spacing'.
	_spacingBottom = 0, -- Falls back to 'spacingVertical' and 'spacing'.

	_background = "",
	_style      = "",
	_tags       = nil,

	_mouseCursor = nil, -- cursor|systemCursorType|nil
	_sounds      = nil,

	_tooltip            = "",
	_unprocessedTooltip = "",
	--

	_automaticId = false,

	_timeBecomingVisible = 0.00,

	_callbacks  = nil,
	_animations = nil,

	_gui    = nil,
	_parent = nil,

	_layoutOffsetX          = 0.0, -- Sum of parents' scrolling.
	_layoutOffsetY          = 0.0,
	_layoutImmediateOffsetX = 0, -- Sum of parents' scrolling, excluding smooth scrolling.
	_layoutImmediateOffsetY = 0,

	_layoutWidth  = 0,
	_layoutHeight = 0,

	_layoutX = 0,
	_layoutY = 0,

	data = nil, -- Alias for _data.
}, {
	"beforedraw"   , --            function( element, event, x, y, w, h )
	"afterdraw"    , --            function( element, event, x, y, w, h )

	"close"        , -- suppress = function( element, event )
	"closed"       , --            function( element, event )

	"focused"      , --            function( element, event )
	"blurred"      , --            function( element, event )

	"init"         , --            function( element, event )

	"keypressed"   , -- suppress = function( element, event, key, scancode, isRepeat )

	"layout"       , --            function( element, event )

	"mousepressed" , --            function( element, event, mx, my, mbutton, pressCount )
	"mousemoved"   , --            function( element, event, mx, my )
	"mousereleased", --            function( element, event, mx, my, mbutton, pressCount )

	"navigated"    , --            function( element, event )

	"pressed"      , --            function( element, event )

	"refresh"      , --            function( element, event )

	"show"         , --            function( element, event )
	"hide"         , --            function( element, event )

	"textinput"    , -- suppress = function( element, event, text )

	"update"       , --            function( element, event, deltaTime )

	"wheelmoved"   , -- suppress = function( element, event, dx, dy )
})

function Cs.element.init(el, gui, elData, parent)
	if el._abstract then
		errorf("Cannot instantiate abstract class '%s'.", el.__name)
	end

	el._gui    = gui or error("Missing gui object argument.")
	el._parent = parent

	local styleName = elData.style

	if styleName then
		local styleData = gui._styles[styleName] or errorf("No style with name '%s' exist.", styleName)
		applyStyle(elData, styleData)
		el._style = styleName
	end

	@@retrieve(el, elData, _anchorX, _anchorY)
	@@retrieve(el, elData, _background)
	@@retrieve(el, elData, _captureInput, _captureGuiInput)
	@@retrieve(el, elData, _closable)
	-- @@retrieve(el, elData, _data)
	@@retrieve(el, elData, _floating)
	@@retrieve(el, elData, _hidden)
	@@retrieve(el, elData, _id)
	@@retrieve(el, elData, _maxWidth, _maxHeight)
	-- @@retrieve(el, elData, _minWidth, _minHeight)
	-- @@retrieve(el, elData, _mouseCursor)
	@@retrieve(el, elData, _originX, _originY)
	@@retrieve(el, elData, _relativeWidth, _relativeHeight)
	-- @@retrieve(el, elData, _sounds)
	-- @@retrieve(el, elData, _spacingLeft, _spacingRight, _spacingTop, _spacingBottom)
	-- @@retrieve(el, elData, _style)
	-- @@retrieve(el, elData, _tags)
	-- @@retrieve(el, elData, _tooltip)
	-- @@retrieve(el, elData, _weight)
	-- @@retrieve(el, elData, _width, _height)
	@@retrieve(el, elData, _x, _y)

	el._timeBecomingVisible = gui._time

	if elData.width     ~= nil then  el:setWidth    (elData.width    )  end
	if elData.height    ~= nil then  el:setHeight   (elData.height   )  end
	if elData.minWidth  ~= nil then  el:setMinWidth (elData.minWidth )  end
	if elData.minHeight ~= nil then  el:setMinHeight(elData.minHeight)  end

	el._spacingLeft   = elData.spacingLeft   or elData.spacingHorizontal or elData.spacing
	el._spacingRight  = elData.spacingRight  or elData.spacingHorizontal or elData.spacing
	el._spacingTop    = elData.spacingTop    or elData.spacingVertical   or elData.spacing
	el._spacingBottom = elData.spacingBottom or elData.spacingVertical   or elData.spacing

	if elData.weight ~= nil then  el:setWeight(elData.weight)  end

	-- Set data table.
	@@ASSERT(elData.data == nil or type(elData.data) == "table")
	el._data = elData.data or {}
	el.data  = el._data -- element.data is exposed for easy access.

	-- Make sure the element has an ID.
	if el._id == "" then
		local numId          = gui._lastAutomaticId + 1
		gui._lastAutomaticId = numId
		el._id               = "__" .. numId
		el._automaticId      = true
	end

	-- Set sounds table.
	if elData.sounds ~= nil then
		for soundK, sound in pairs(elData.sounds) do
			checkValidSoundKey(soundK, 2)
			el._sounds         = el._sounds or {}
			el._sounds[soundK] = sound
		end
	end

	-- Add tags.
	if elData.tags ~= nil then
		for _, tag in ipairs(elData.tags) do
			el._tags      = el._tags or {}
			el._tags[tag] = true
		end
	end

	if elData.mouseCursor ~= nil then  el:setMouseCursor(elData.mouseCursor)  end
	if elData.tooltip     ~= nil then  el:setTooltip(elData.tooltip)          end

	-- Set initial offset.
	if parent then
		el._layoutImmediateOffsetX = parent._layoutImmediateOffsetX + parent._scrollX
		el._layoutImmediateOffsetY = parent._layoutImmediateOffsetY + parent._scrollY
		el._layoutOffsetX          = parent._layoutOffsetX          + parent._visualScrollX
		el._layoutOffsetY          = parent._layoutOffsetY          + parent._visualScrollY
	end

	-- The 'here' debug attribute prints the path to the element.
	if elData.here then  table.insert(gui._heres, el)  end

	if elData.debug then  gui.debug = true  end
end



-- INTERNAL  element:_update( deltaTime )
function Cs.element._update(el, dt)
	-- void
end



-- INTERNAL  element:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.element._draw(el, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	local x, y, w, h = xywhOnScreen(el)

	if not el._gui.debug then
		triggerIncludingAnimations(el, "beforedraw", x, y, w, h)
	end

	drawLayoutBackground(el)

	if not el._gui.debug then
		triggerIncludingAnimations(el, "afterdraw", x, y, w, h)
	end
end

-- INTERNAL  element:_drawDebug( red, green, blue [, backgroundOpacity=1 ] )
function Cs.element._drawDebug(el, r, g, b, bgOpacity)
	local gui = el._gui
	if not gui.debug then  return  end

	local isContainer = el:is(Cs.container)
	local x, y, w, h  = xywhOnScreen(el)
	local paddingL    = isContainer and el._paddingLeft or 0
	local paddingT    = isContainer and el._paddingTop  or 0
	local lw          = clamp(paddingL, 1, paddingT) -- @Polish: Better border width.

	local sbW = themeGet(gui, "scrollbarWidth")

	if el:isKeyboardFocus() then
		r, g, b = 1, 1, 0
	elseif el:isNavigationTarget() then
		r, g, b = 1, 1, 1
	end

	$LG.push("all")

	$LG.translate(x, y)

	-- Background and center line.
	setColor(r, g, b, .24*(bgOpacity or 1))
	$LG.rectangle("fill", 0, 0, w, h)
	$LG.line(paddingL, paddingT, w/2, h/2)

	-- Border.
	$LG.setLineWidth(lw)
	setColor(r, g, b, .4)
	$LG.rectangle("line", lw/2, lw/2, w-lw, h-lw)
	if isContainer then
		if el:canScrollY() then  $LG.rectangle("fill", w-lw-sbW, lw, sbW, h-2*lw)  end
		if el:canScrollX() then  $LG.rectangle("fill", lw, h-lw-sbW, w-w*lw, sbW)  end
	end
	$LG.setLineWidth(1)
	setColor(r, g, b, .6)
	$LG.rectangle("line", 0.5, 0.5, w-1, h-1)

	-- Info.
	r = lerp(r, 1, .5)
	g = lerp(g, 1, .5)
	b = lerp(b, 1, .5)
	$LG.setFont(gui._font or _M.getDefaultFont())
	setColor(r, g, b, .8)
	if el._automaticId then
		$LG.print(F("%d.%d"   , el:getDepth(), (el:getIndex() or 0)        ), 2, 1)
	else
		$LG.print(F("%d.%d:%s", el:getDepth(), (el:getIndex() or 0), el._id), 2, 1)
	end

	$LG.pop()
end

-- INTERNAL  element:_drawTooltip( )
function Cs.element._drawTooltip(el)
	local gui  = el._gui
	local text = el._tooltip

	if text == "" or gui._tooltipTime < gui._tooltipDelay then  return  end

	local root = gui._root
	local font = el:getResultingTooltipFont()

	local textW, textH = getTextDimensions(font, text, 1/0)

	local w, h = themeGetSize(el, "tooltip", textW, textH) -- @Speed: Get tooltip size when tooltip text changes. :CacheTooltipValues

	local x = clamp(el._layoutX+el._layoutImmediateOffsetX, 0, root._width-w)
	local y = el._layoutY + el._layoutHeight + el._layoutImmediateOffsetY

	if y+h > root._height then
		y = math.max(y-h-el._layoutHeight, 0)
	end

	themeRenderOnScreen(el, "tooltip", x, y, w, h, text, textW, textH, gui._tooltipTime-gui._tooltipDelay)
end



--
-- element:animate( duration, [ lockInteraction=false, ] callbackTable )
-- callbackTable = { [event1]=callback, ... }
-- callback      = function( element, event, progress, ... ) -- Unlike in normal event callbacks there's an extra 'progress' argument before the rest of the arguments.
--
-- Example:
--     myGui:find("myButton"):animate(1, true, {
--         afterdraw = function(myButton, event, progress, x, y, w, h)
--             -- Fade in and out a green cover over the button.
--             setColor(0, 1, 0, .5+.5*math.sin(progress*math.pi))
--             love.graphics.rectangle("fill", x, y, w, h)
--         end,
--     })
--
function Cs.element.animate(el, duration, lockInteraction, callbacks)
	!ARGS"2 duration:number"

	if type(lockInteraction) == "table" then
		lockInteraction, callbacks = false, lockInteraction
	else
		!ARGS"2 duration:* lockInteraction:boolean callbacks,table"
	end

	local gui = el._gui

	local anim = {
		element         = el,
		lockInteraction = lockInteraction,
		callbacks       = callbacks,

		startTime       = gui._time,
		endTime         = gui._time+duration,
		duration        = duration,
	}

	el._animations = el._animations or {}
	table.insert(el._animations    , anim)
	table.insert(gui._allAnimations, anim)

	if lockInteraction then
		gui._animationLockCount = gui._animationLockCount+1
	end
end



-- success = element:close( )
-- Trigger 'close' action, if possible.
function Cs.element.close(el)
	if not el:canClose() then
		return false
	end

	local preparedSound = prepareSound(el, "close")
	if trigger(el, "close") then
		return false -- Suppress default behavior.
	end

	if preparedSound then
		preparedSound()
	end
	el:hide()
	el:triggerBubbling("closed", el)

	return true
end

-- result = element:canClose( )
function Cs.element.canClose(el)
	return el._closable and not el._gui._lockNavigation and el:isDisplayed()
end



-- bool = element:exists( )
function Cs.element.exists(el)
	return el._parent ~= nil or el == el._gui._root
end



-- anchorX, anchorY = element:getAnchor( )
-- anchor = element:getAnchorX( )
-- anchor = element:getAnchorY( )
function Cs.element.getAnchor(el)
	return el._anchorX, el._anchorY
end
function Cs.element.getAnchorX(el)
	return el._anchorX
end
function Cs.element.getAnchorY(el)
	return el._anchorY
end

-- element:setAnchor( anchorX, anchorY )
-- element:setAnchorX( anchor )
-- element:setAnchorY( anchor )
function Cs.element.setAnchor(el, anchorX, anchorY)
	if el._anchorX == anchorX and el._anchorY == anchorY then  return  end
	el._anchorX = anchorX
	el._anchorY = anchorY
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setAnchorX(el, anchor)
	if el._anchorX == anchor then  return  end
	el._anchorX = anchor
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setAnchorY(el, anchor)
	if el._anchorY == anchor then  return  end
	el._anchorY = anchor
	scheduleLayoutUpdateIfDisplayed(el)
end



-- callback|nil = element:getCallback( event )
function Cs.element.getCallback(el, event)
	return el._callbacks and el._callbacks[event]
end

-- element:setCallback( event, callback|nil )
function Cs.element.setCallback(el, event, cb)
	!ARGS"2 event:string cb:function,nil"

	if not el._events[event] then
		printerr(2, "Unknown event '%s'. (%s)", event, el:getPathDescription())
		return
	end

	if not (cb or el._callbacks) then  return  end

	el._callbacks        = el._callbacks or {}
	el._callbacks[event] = cb

	-- Since callbacks can only be attached to elements after the actual
	-- initialization has happened we instead trigger the init event here.
	if cb and event == "init" then
		trigger(el, "init")
	end
end

-- element:on( event, callback|nil )
-- Alias for element:setCallback().
Cs.element.on = Cs.element.setCallback

-- element:off( event )
function Cs.element.off(el, event)
	el:on(event, nil)
end

-- value = element:trigger( event [, extraArgument1, ... ] )
function Cs.element.trigger(el, event, ...)
	!ARGS"2 event:string"
	if not el._events[event] then
		printerr(2, "Unknown event '%s'. (%s)", event, el:getPathDescription())
		return nil
	end
	return (trigger(el, event, ...))
end

-- value = element:triggerBubbling( event [, extraArgument1, ... ] )
function Cs.element.triggerBubbling(el, event, ...)
	!ARGS"2 event:string"

	if not el._events[event] then
		printerr(2, "Unknown event '%s'. (%s)", event, el:getPathDescription())
		return nil
	end

	local returnV = nil
	repeat
		returnV = trigger(el, event, ...)
		el      = el._parent
	until returnV or not el

	return returnV
end



-- closestElement|nil = element:getClosest( elementType )
-- Returns closest ancestor matching elementType (including self).
function Cs.element.getClosest(el, elType)
	local class = requireElementClass(elType, 2)
	repeat
		if el:is(class) then  return el  end
		el = el._parent
	until not el
	return nil
end



do
	!local MAX_ANGLE_DIFF = TAU/4

	local function _getClosestInDirection(navRoot, class, fromX,fromY, angle, ignoreCapture, elToIgnore)
		fromX = round(fromX)
		fromY = round(fromY)

		local closestEl      = nil
		local closestDistSqr = 1/0
		local closestAngDiff = 1/0

		for _, el in ipairs(navRoot:collectVisible(@@STATIC{})) do
			if el ~= elToIgnore and el:is(class) then
				local x, y = el:getPositionOnScreen()
				x          = math.min(math.max(fromX, x+.01), x+el._layoutWidth -.01)
				y          = math.min(math.max(fromY, y+.01), y+el._layoutHeight-.01)

				local dx      = x - fromX
				local dy      = y - fromY
				local distSqr = dx*dx + dy*dy

				if distSqr <= closestDistSqr then
					local angDiff = math.atan2(dy, dx) - angle
					angDiff       = math.abs(math.atan2(math.sin(angDiff), math.cos(angDiff))) -- Normalize.

					if angDiff < !(MAX_ANGLE_DIFF) and (distSqr < closestDistSqr or (distSqr == closestDistSqr and angDiff < closestAngDiff)) then
						closestEl      = el
						closestDistSqr = distSqr
						closestAngDiff = angDiff
					end
				end
			end

			if not ignoreCapture and (el._captureInput or el._captureGuiInput) then
				break
			end
		end

		return closestEl
	end

	-- otherElement|nil = element:getClosestInDirection( angle [, elementType="widget", ignoreInputCaptureState=false, ignoreConfinement=false ] )
	function Cs.element.getClosestInDirection(el, angle, elType, ignoreCapture, ignoreConfinement)
		!ARGS"2 angle:number ? elType:string ignoreCapture,ignoreConfinement:boolean"

		local class = elType and requireElementClass(elType, 2) or Cs.widget

		updateLayoutIfNeeded(el._gui)

		local navRoot = ignoreConfinement and el._gui._root or el:getNavigationRoot()

		local centerX, centerY = el:getLayoutCenterPosition() -- @Cleanup: Use getPositionOnScreen().

		local fromX     = centerX + el._layoutOffsetX + .495*el._layoutWidth *math.cos(angle)
		local fromY     = centerY + el._layoutOffsetY + .495*el._layoutHeight*math.sin(angle)
		local closestEl = _getClosestInDirection(navRoot, class, fromX,fromY, angle, ignoreCapture, el)

		if not closestEl and not ignoreConfinement and navRoot._confineNavigation then
			fromX     = centerX + el._layoutOffsetX - 10000*math.cos(angle)
			fromY     = centerY + el._layoutOffsetY - 10000*math.sin(angle)
			closestEl = _getClosestInDirection(navRoot, class, fromX,fromY, angle, ignoreCapture, nil)
		end

		return closestEl
	end
end

do
	local function getNextOrPrevious(el, elType, ignoreCapture, usePrev)
		local class = elType and requireElementClass(elType, 3) or Cs.widget

		local root = el._gui._root
		if not root or root._hidden then  return nil  end

		local foundSelf = false
		local lastMatch = nil

		for _, otherEl in ipairs(el:getNavigationRoot():collectVisible(@@STATIC{})) do
			-- Note: Remember that we're traversing backwards.

			local elIsValid = otherEl:is(class)
			if elIsValid and usePrev and foundSelf then  return otherEl  end

			foundSelf = (foundSelf or otherEl == el)
			if not usePrev and foundSelf then
				return lastMatch -- May be nil.
			end

			if elIsValid then  lastMatch = otherEl  end

			if not ignoreCapture and (otherEl._captureInput or otherEl._captureGuiInput) then
				break
			end
		end

		return nil
	end

	-- otherElement = element:getNext( [ elType="widget", ignoreInputCaptureState=false ] )
	function Cs.element.getNext(el, elType, ignoreCapture)
		return (getNextOrPrevious(el, elType, ignoreCapture, false))
	end

	-- otherElement = element:getPrevious( [ elType="widget", ignoreInputCaptureState=false ] )
	function Cs.element.getPrevious(el, elType, ignoreCapture)
		return (getNextOrPrevious(el, elType, ignoreCapture, true))
	end
end



-- value = element:getData( key )
-- Note: element:getData(k) is the same as element.data[k]
function Cs.element.getData(el, k)
	-- @Memory: We probably don't need _data to always be set, but we'd probably
	-- have to remove the element.data property and change some other things.
	return el._data[k]
end

-- element:setData( key, value )
-- Note: element:setData(key, value) is the same as element.data[key]=value
function Cs.element.setData(el, k, v)
	el._data[k] = v
end

-- oldDataTable = element:swapData( newDataTable )
function Cs.element.swapData(el, data)
	!ARGS"2 data:table"
	local oldData = el._data
	el._data      = data
	el.data       = data
	return oldData
end



-- width, height = element:getDimensions( )
-- width  = element:getWidth( )
-- height = element:getHeight( )
function Cs.element.getDimensions(el)
	return el._width, el._height
end
function Cs.element.getWidth(el)
	return el._width
end
function Cs.element.getHeight(el)
	return el._height
end

-- element:setDimensions( width, height )
-- element:setWidth( width )
-- element:setHeight( height )
-- Negative values means dynamic size.
function Cs.element.setDimensions(el, w, h)
	!ARGS"2 w,h:number"
	if el._width == w and el._height == h then  return  end
	el._width  = w
	el._height = h
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setWidth(el, w)
	!ARGS"2 w:number"
	if el._width == w then  return  end
	el._width = w
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setHeight(el, h)
	!ARGS"2 h:number"
	if el._height == h then  return  end
	el._height = h
	scheduleLayoutUpdateIfDisplayed(el)
end



-- width, height = element:getRelativeDimensions( )
-- width  = element:getRelativeWidth( )
-- height = element:getRelativeHeight( )
function Cs.element.getRelativeDimensions(el)
	return el._relativeWidth, el._relativeHeight
end
function Cs.element.getRelativeWidth(el)
	return el._relativeWidth
end
function Cs.element.getRelativeHeight(el)
	return el._relativeHeight
end

-- element:setRelativeDimensions( width, height )
-- element:setRelativeWidth( width )
-- element:setRelativeHeight( height )
-- Negative values disable relative size.
function Cs.element.setRelativeDimensions(el, w, h)
	!ARGS"2 w,h:number"
	if el._relativeWidth == w and el._relativeHeight == h then  return  end
	el._relativeWidth  = w
	el._relativeHeight = h
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setRelativeWidth(el, w)
	!ARGS"2 w:number"
	if el._relativeWidth == w then  return  end
	el._relativeWidth = w
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setRelativeHeight(el, h)
	!ARGS"2 h:number"
	if el._relativeHeight == h then  return  end
	el._relativeHeight = h
	scheduleLayoutUpdateIfDisplayed(el)
end



-- width, height = element:getMinDimensions( )
-- width  = element:getMinWidth( )
-- height = element:getMinHeight( )
function Cs.element.getMinDimensions(el)
	return el._minWidth, el._minHeight
end
function Cs.element.getMinWidth(el)
	return el._minWidth
end
function Cs.element.getMinHeight(el)
	return el._minHeight
end

-- element:setMinDimensions( width, height )
-- element:setMinWidth( width )
-- element:setMinHeight( height )
function Cs.element.setMinDimensions(el, w, h)
	!ARGS"2 w,h:number"
	w = math.max(w, 0)
	h = math.max(h, 0)
	if el._minWidth == w and el._minHeight == h then  return  end
	el._minWidth  = w
	el._minHeight = h
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setMinWidth(el, w)
	!ARGS"2 w:number"
	w = math.max(w, 0)
	if el._minWidth == w then  return  end
	el._minWidth = w
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setMinHeight(el, h)
	!ARGS"2 h:number"
	h = math.max(h, 0)
	if el._minHeight == h then  return  end
	el._minHeight = h
	scheduleLayoutUpdateIfDisplayed(el)
end



-- width, height = element:getMaxDimensions( )
-- width  = element:getMaxWidth( )
-- height = element:getMaxHeight( )
function Cs.element.getMaxDimensions(el)
	return el._maxWidth, el._maxHeight
end
function Cs.element.getMaxWidth(el)
	return el._maxWidth
end
function Cs.element.getMaxHeight(el)
	return el._maxHeight
end

-- element:setMaxDimensions( width, height )
-- element:setMaxWidth( width )
-- element:setMaxHeight( height )
-- Negative values remove restrictions.
function Cs.element.setMaxDimensions(el, w, h)
	!ARGS"2 w,h:number"
	if el._maxWidth == w and el._maxHeight == h then  return  end
	el._maxWidth  = w
	el._maxHeight = h
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setMaxWidth(el, w)
	!ARGS"2 w:number"
	if el._maxWidth == w then  return  end
	el._maxWidth = w
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setMaxHeight(el, h)
	!ARGS"2 h:number"
	if el._maxHeight == h then  return  end
	el._maxHeight = h
	scheduleLayoutUpdateIfDisplayed(el)
end



-- weight = element:getWeight( )
function Cs.element.getWeight(el)
	return el._weight
end

-- element:setWeight( weight )
function Cs.element.setWeight(el, weight)
	!ARGS"2 weight:number"
	weight = math.max(weight, 0)
	if el._weight == weight then  return  end
	el._weight = weight
	scheduleLayoutUpdateIfDisplayed(el)
end



-- bool = element:hasFixedWidth( )
-- bool = element:hasFixedHeight( )
-- bool = element:hasDynamicWidth( )
-- bool = element:hasDynamicHeight( )
function Cs.element.hasFixedWidth   (el)  return el._width  >= 0  end
function Cs.element.hasFixedHeight  (el)  return el._height >= 0  end
function Cs.element.hasDynamicWidth (el)  return el._width  <  0  end
function Cs.element.hasDynamicHeight(el)  return el._height <  0  end

-- bool = element:hasRelativeWidth( )
-- bool = element:hasRelativeHeight( )
function Cs.element.hasRelativeWidth (el)  return el._width  < 0 and el._relativeWidth  >= 0  end
function Cs.element.hasRelativeHeight(el)  return el._height < 0 and el._relativeHeight >= 0  end



-- spacingLeft, spacingRight, spacingTop, spacingBottom = element:getSpacing( )
-- spacing = element:getSpacingLeft( )
-- spacing = element:getSpacingRight( )
-- spacing = element:getSpacingTop( )
-- spacing = element:getSpacingBottom( )
function Cs.element.getSpacing(el)
	return el._spacingLeft, el._spacingRight, el._spacingTop, el._spacingBottom
end
function Cs.element.getSpacingLeft  (el)  return el._spacingLeft    end
function Cs.element.getSpacingRight (el)  return el._spacingRight   end
function Cs.element.getSpacingTop   (el)  return el._spacingTop     end
function Cs.element.getSpacingBottom(el)  return el._spacingBottom  end

-- element:setSpacing( spacing )
-- element:setSpacing( spacingHorizontal, spacingVertical )
-- element:setSpacing( spacingLeft, spacingRight, spacingTop, spacingBottom )
-- element:setSpacingLeft( spacing )
-- element:setSpacingRight( spacing )
-- element:setSpacingTop( spacing )
-- element:setSpacingBottom( spacing )
function Cs.element.setSpacing(el, spacingL, spacingR, spacingT, spacingB)
	!ARGS"2 spacingL:number"

	if not spacingR then
		spacingL, spacingR, spacingT, spacingB = spacingL, spacingL, spacingL, spacingL
	elseif not spacingB then
		spacingL, spacingR, spacingT, spacingB = spacingL, spacingL, spacingR, spacingR
	end

	if
		el._spacingLeft   == spacingL and
		el._spacingRight  == spacingR and
		el._spacingTop    == spacingT and
		el._spacingBottom == spacingB
	then
		return
	end

	el._spacingLeft   = spacingL
	el._spacingRight  = spacingR
	el._spacingTop    = spacingT
	el._spacingBottom = spacingB

	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setSpacingLeft(el, spacing)
	!ARGS"2 spacing:number"
	if el._spacingLeft == spacing then  return  end
	el._spacingLeft = spacing
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setSpacingRight(el, spacing)
	!ARGS"2 spacing:number"
	if el._spacingRight == spacing then  return  end
	el._spacingRight = spacing
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setSpacingTop(el, spacing)
	!ARGS"2 spacing:number"
	if el._spacingTop == spacing then  return  end
	el._spacingTop = spacing
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setSpacingBottom(el, spacing)
	!ARGS"2 spacing:number"
	if el._spacingBottom == spacing then  return  end
	el._spacingBottom = spacing
	scheduleLayoutUpdateIfDisplayed(el)
end



-- gui = element:getGui( )
function Cs.element.getGui(el)
	return el._gui
end



-- time = element:getGuiTime( )
-- Alias for element:getGui():getTime().
function Cs.element.getGuiTime(el)
	return el._gui._time
end



-- id = element:getId( )
function Cs.element.getId(el)
	return el._id
end

-- element:setId( id )
function Cs.element.setId(el, id)
	!ARGS"2 id:string"
	if id == "" then
		local gui            = el._gui
		local numId          = gui._lastAutomaticId + 1
		gui._lastAutomaticId = numId
		el._id               = "__" .. numId
		el._automaticId      = true
	else
		el._id               = id
		el._automaticId      = false
	end
end

-- bool = element:hasId( id1, ... )
function Cs.element.hasId(el, ...)
	for i = 1, select("#", ...) do
		if el._id == select(i, ...) then  return true  end
	end
	return false
end



-- index|nil = element:getIndex( )
-- Get the child index in the parent, if there is a parent.
function Cs.element.getIndex(el)
	return el._parent and el._parent:indexOf(el)
end

-- depth = element:getDepth( )
function Cs.element.getDepth(el)
	local depth = 0

	while el._parent do
		el    = el._parent
		depth = depth + 1
	end

	return depth
end



-- x, y, width, height = element:getLayout( )
function Cs.element.getLayout(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutX, el._layoutY, el._layoutWidth, el._layoutHeight
end

-- width, height = element:getLayoutDimensions( )
-- width  = element:getLayoutWidth( )
-- height = element:getLayoutHeight( )
function Cs.element.getLayoutDimensions(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutWidth, el._layoutHeight
end
function Cs.element.getLayoutWidth(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutWidth
end
function Cs.element.getLayoutHeight(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutHeight
end

-- x, y = element:getLayoutPosition( )
-- x = element:getLayoutX( )
-- y = element:getLayoutY( )
function Cs.element.getLayoutPosition(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutX, el._layoutY
end
function Cs.element.getLayoutX(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutX
end
function Cs.element.getLayoutY(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutY
end

-- x, y = element:getLayoutCenterPosition( )
function Cs.element.getLayoutCenterPosition(el)
	updateLayoutIfNeeded(el._gui)
	return el._layoutX + .5*el._layoutWidth,
	       el._layoutY + .5*el._layoutHeight
end



-- cursor|systemCursorType|nil = element:getMouseCursor( )
function Cs.element.getMouseCursor(el)
	return el._mouseCursor
end

-- cursor|nil = element:getResultingMouseCursor( )
function Cs.element.getResultingMouseCursor(el)
	local cur = el._mouseCursor
	if type(cur) ~= "string" then  return cur  end
	return $LM.getSystemCursor(cur)
end

-- element:setMouseCursor( cursor|systemCursorType|nil )
function Cs.element.setMouseCursor(el, cur)
	!ARGS"2 cur:Cursor,string,nil"

	if type(cur) == "string" and not pcall($LM.getSystemCursor, cur) then
		errorf(2, "Invalid system cursor type '%s'.", cur)
	end

	el._mouseCursor = cur
end



-- x, y = element:getMousePosition( )
-- x = element:getMouseX( )
-- y = element:getMouseY( )
-- Get the mouse position relative the element.
-- Returns nil if the mouse position is unknown.
function Cs.element.getMousePosition(el)
	local gui = el._gui
	if gui._mouseX == !(MOUSE_POS_UNKNOWN) then  return nil  end
	local x, y = el:getPositionOnScreen()
	return gui._mouseX-x, gui._mouseY-y
end
function Cs.element.getMouseX(el)
	local x = el._gui._mouseX
	return x ~= !(MOUSE_POS_UNKNOWN) and x-el:getXOnScreen() or nil
end
function Cs.element.getMouseY(el)
	local y = el._gui._mouseY
	return y ~= !(MOUSE_POS_UNKNOWN) and y-el:getYOnScreen() or nil
end



-- originX, originY = element:getOrigin( )
-- origin = element:getOriginX( )
-- origin = element:getOriginY( )
function Cs.element.getOrigin(el)
	return el._originX, el._originY
end
function Cs.element.getOriginX(el)
	return el._originX
end
function Cs.element.getOriginY(el)
	return el._originY
end

-- element:setOrigin( originX, originY )
-- element:setOriginX( origin )
-- element:setOriginY( origin )
function Cs.element.setOrigin(el, originX, originY)
	if el._originX == originX and el._originY == originY then  return  end
	el._originX = originX
	el._originY = originY
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setOriginX(el, originX)
	if el._originX == originX then  return  end
	el._originX = originX
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setOriginY(el, originY)
	if el._originY == originY then  return  end
	el._originY = originY
	scheduleLayoutUpdateIfDisplayed(el)
end



-- container|nil = element:getParent( )
function Cs.element.getParent(el)
	return el._parent
end

-- containers = element:getAllParents( )
-- Returns an array of parents, with the closest parent first.
function Cs.element.getAllParents(el)
	local parents = {} -- @Memory
	local i       = 0

	while true do
		el = el._parent
		if not el then  return parents  end

		i          = i + 1
		parents[i] = el
	end
end

-- bool = element:hasParent( parent )
-- Note: Checks all grandparents too.
function Cs.element.hasParent(el, parent)
	while true do
		el = el._parent
		if not el       then  return false  end
		if el == parent then  return true   end
	end
	return false
end

-- container = element:getParentWithId( id )
function Cs.element.getParentWithId(el, id)
	while true do
		el = el._parent
		if not el       then  return nil  end
		if el._id == id then  return el   end
	end
	return nil
end

-- bool = element:hasParentWithId( id )
function Cs.element.hasParentWithId(el, id)
	return el:getParentWithId(id) ~= nil
end

-- for index, container in element:parents( )
-- Iterate over parents, from parent to grandparent.
function Cs.element.parents(el)
	local i = 0

	return function() -- @Memory: Don't use :parents() internally.
		el = el._parent
		if not el then  return  end

		i = i + 1
		return i, el
	end
end

-- for index, container in element:parentsr( )
-- Iterate over parents in reverse, from grandparent to parent.
function Cs.element.parentsr(el)
	return ipairsr(el:getAllParents())
end

-- for index, element in element:lineageUp( )
-- Traverse from self to the grandest parent.
function Cs.element.lineageUp(el)
	local i = 0

	return function()
		if not el then  return  end

		local current = el

		i  = i + 1
		el = el._parent

		return i, current
	end
end



local parts = {}

-- description = element:getPathDescription( )
function Cs.element.getPathDescription(el)
	for i = 1, #parts do  parts[i] = nil  end

	while true do
		-- Note that we construct the description in reverse.
		if not el._automaticId then
			table.insert(parts, ")")
			table.insert(parts, el._id)
			table.insert(parts, "(")
		end

		table.insert(parts, el.__name:sub(4)) -- Remove the "Gui" prefix from the class name.

		local i = el:getIndex()
		if i then
			table.insert(parts, ":")
			table.insert(parts, i)
		end

		el = el._parent
		if not el then  break  end

		table.insert(parts, "/")
	end

	reverseArray(parts)
	return table.concat(parts)
end



-- x, y = element:getPosition( )
-- x = element:getX( )
-- y = element:getY( )
function Cs.element.getPosition(el)
	return el._x, el._y
end
function Cs.element.getX(el)
	return el._x
end
function Cs.element.getY(el)
	return el._y
end

-- element:setPosition( x, y )
-- element:setX( x )
-- element:setY( y )
function Cs.element.setPosition(el, x, y)
	if el._x == x and el._y == y then  return  end
	el._x = x
	el._y = y
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setX(el, x)
	if el._x == x then  return  end
	el._x = x
	scheduleLayoutUpdateIfDisplayed(el)
end
function Cs.element.setY(el, y)
	if el._y == y then  return  end
	el._y = y
	scheduleLayoutUpdateIfDisplayed(el)
end



-- x, y = element:getPositionOnScreen( [ ignoreSmoothScrolling=false ] )
-- x = element:getXOnScreen( [ ignoreSmoothScrolling=false ] )
-- y = element:getYOnScreen( [ ignoreSmoothScrolling=false ] )
function Cs.element.getPositionOnScreen(el, ignoreSmoothScrolling)
	updateLayoutIfNeeded(el._gui)
	if    ignoreSmoothScrolling
	then  return el._layoutX+el._layoutImmediateOffsetX, el._layoutY+el._layoutImmediateOffsetY
	else  return el._layoutX+el._layoutOffsetX         , el._layoutY+el._layoutOffsetY  end
end
function Cs.element.getXOnScreen(el, ignoreSmoothScrolling)
	updateLayoutIfNeeded(el._gui)
	if    ignoreSmoothScrolling
	then  return el._layoutX+el._layoutImmediateOffsetX
	else  return el._layoutX+el._layoutOffsetX  end
end
function Cs.element.getYOnScreen(el, ignoreSmoothScrolling)
	updateLayoutIfNeeded(el._gui)
	if    ignoreSmoothScrolling
	then  return el._layoutY+el._layoutImmediateOffsetY
	else  return el._layoutY+el._layoutOffsetY  end
end

-- x, y = element:getLayoutOnScreen( [ ignoreSmoothScrolling=false ] )
function Cs.element.getLayoutOnScreen(el, ignoreSmoothScrolling)
	updateLayoutIfNeeded(el._gui)
	if    ignoreSmoothScrolling
	then  return el._layoutX+el._layoutImmediateOffsetX, el._layoutY+el._layoutImmediateOffsetY, el._layoutWidth, el._layoutHeight
	else  return el._layoutX+el._layoutOffsetX         , el._layoutY+el._layoutOffsetY         , el._layoutWidth, el._layoutHeight  end
end



-- root|nil = element:getRoot( )
-- Note: Returns the root the element knows of, which itself may have been
-- removed from the GUI. So this function differs slightly from gui:getRoot().
function Cs.element.getRoot(el)
	repeat
		if el.class == Cs.root then  return el  end
		el = el._parent
	until not el
	return nil -- We've been removed from the root.
end

-- container = element:getNavigationRoot( )
function Cs.element.getNavigationRoot(el)
	local container = el._parent
	if not container then  return nil  end -- Should we allow returning self if we're a container?

	while container._parent do
		if container._confineNavigation then  return container  end
		container = container._parent
	end

	return container -- We've reached the top container we know of.
end



-- sibling = element:getSibling( offset )
-- getSibling(1) returns the next sibling etc.
function Cs.element.getSibling(el, offset)
	local i = el:getIndex()
	return i and el._parent[i+offset]
end



-- sound|nil = element:getSound( soundKey )
function Cs.element.getSound(el, soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	return el._sounds and el._sounds[soundK]
end

-- sound|nil = element:getResultingSound( soundKey )
function Cs.element.getResultingSound(el, soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)

	local sound = el._sounds and el._sounds[soundK]

	if sound == nil then
		for _, parent in el:parents() do
			sound = parent._sounds and parent._sounds[soundK]
			if sound ~= nil then  break  end
		end
		if sound == nil and el._gui then
			sound = el._gui._defaultSounds[soundK]
		end
	end

	if sound == false then  sound = nil  end -- Special case: The value false intercepts the bubbling and tells that no sound should be played.

	return sound
end

-- element:setSound( soundKey, sound )
-- element:setSound( soundKey, false ) -- Prevent sound from playing, even if a default sound is set.
-- element:setSound( soundKey, nil   ) -- Remove sound.
function Cs.element.setSound(el, soundK, sound)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)
	el._sounds         = el._sounds or {}
	el._sounds[soundK] = sound
end



-- style = element:getStyle( )
function Cs.element.getStyle(el)
	return el._style
end



-- duration = element:getTimeSinceBecomingVisible( )
function Cs.element.getTimeSinceBecomingVisible(el)
	return el._gui._time - el._timeBecomingVisible
end



-- tooltip = element:getTooltip( )
function Cs.element.getTooltip(el)
	return el._tooltip
end

-- element:setTooltip( text )
function Cs.element.setTooltip(el, unprocessedText)
	unprocessedText = tostring(unprocessedText == nil and "" or unprocessedText)

	local text = preprocessText(el._gui, unprocessedText, el, false)
	if el._tooltip == text then  return  end -- @Speed: Maybe do this check for the unprocessedText?

	el._tooltip            = text
	el._unprocessedTooltip = unprocessedText
end



-- element:drawTooltip( x, y )
function Cs.element.drawTooltip(el, x, y)
	$LG.print(el._tooltip, x, y)
end



-- font = element:getResultingTooltipFont( )
function Cs.element.getResultingTooltipFont(el)
	return el._gui._fontTooltip or _M.getDefaultFont()
end

-- fontBeingUsed = element:useTooltipFont( )
-- Tell LÖVE to use the element's resulting tooltip font.
function Cs.element.useTooltipFont(el)
	local font = el:getResultingTooltipFont()
	$LG.setFont(font)
	return font
end



-- bool = element:hasTag( tag )
function Cs.element.hasTag(el, tag)
	return (el._tags and el._tags[tag]) ~= nil
end

-- element:addTag( tag )
function Cs.element.addTag(el, tag)
	el._tags      = el._tags or {}
	el._tags[tag] = true
end

-- element:removeTag( tag )
-- element:removeAllTags( )
function Cs.element.removeTag(el, tag)
	if not el._tags then  return  end
	el._tags[tag] = nil
end
function Cs.element.removeAllTags(el)
	if el._tags and next(el._tags) then
		el._tags = nil
	end
end

-- element:setTag( tag, bool )
function Cs.element.setTag(el, tag, state)
	if state then  el:addTag(tag)
	else           el:removeTag(tag)  end
end



-- bool = element:isAt( x, y )
function Cs.element.isAt(el, x, y)
	updateLayoutIfNeeded(el._gui)

	x = x - el._layoutOffsetX
	y = y - el._layoutOffsetY

	return x >= el._layoutX
	   and y >= el._layoutY
	   and x <  el._layoutX + el._layoutWidth
	   and y <  el._layoutY + el._layoutHeight
end



-- handled, grabKeyboardFocus = element:_keypressed( key, scancode, isRepeat )
function Cs.element._keypressed(el, key, scancode, isRepeat)
	return false, false
end

-- INTERNAL  element:_keyreleased( key, scancode )
function Cs.element._keyreleased(el, key, scancode)
	-- void
end

-- handled = element:_textinput( text )
function Cs.element._textinput(el, text)
	return false
end



-- handled, grabMouseFocus = element:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.element._mousepressed(el, mx, my, mbutton, pressCount)
	return false, false
end

-- INTERNAL  element:_mousemoved( mouseX, mouseY )
function Cs.element._mousemoved(el, mx, my)
	-- void
end

-- INTERNAL  element:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.element._mousereleased(el, mx, my, mbutton, pressCount)
	-- void
end

-- handled = element:_wheelmoved( deltaX, deltaY, deltaX0, deltaY0 )
function Cs.element._wheelmoved(el, dx, dy, dx0, dy0)
	return false
end



-- bool = element:isDisplayed( )
-- Returns true if the element and its parents are visible (and the element exists).
function Cs.element.isDisplayed(el)
	if not el:exists() then  return false  end
	repeat
		if el._hidden then  return false  end
		el = el._parent
	until not el
	return true
end

-- hiddenElement|nil = element:getClosestHiddenElement( )
-- hiddenElement|nil = element:getFarthestHiddenElement( )
function Cs.element.getClosestHiddenElement(el)
	repeat
		if el._hidden then  return el  end
		el = el._parent
	until not el
	return nil
end
function Cs.element.getFarthestHiddenElement(el)
	local hiddenEl = nil
	repeat
		if el._hidden then  hiddenEl = el  end
		el = el._parent
	until not el
	return hiddenEl
end



-- bool = element:isFirst( )
-- bool = element:isLast( )
function Cs.element.isFirst(el)
	return not el._parent or el:getIndex() == 1
end
function Cs.element.isLast(el)
	return not el._parent or el:getIndex() == #el._parent
end



-- bool = element:isHidden( )
-- bool = element:isVisible( )
function Cs.element.isHidden(el)
	return el._hidden
end
function Cs.element.isVisible(el)
	return not el._hidden
end

-- stateChanged = element:setHidden( bool )
function Cs.element.setHidden(el, hidden)
	!ARGS"2 hidden:boolean"
	if el._hidden == hidden then  return false  end

	local wasDisplayed = el:isDisplayed()
	el._hidden         = hidden
	local isDisplayed  = el:isDisplayed()
	local gui          = el._gui

	if wasDisplayed or isDisplayed then
		if wasDisplayed then  validateNavigationTarget(gui)  end

		gui._layoutNeedsUpdate = true

		if isDisplayed then
			local time              = gui._time
			el._timeBecomingVisible = time

			if el:is(Cs.container) then
				el:visitVisible(@@LAMBDA(time, function(el)
					el._timeBecomingVisible = time
				end))
			end
		end
	end

	trigger(el, (hidden and "hide" or "show"))
	return true
end

-- stateChanged = element:setVisible( bool )
function Cs.element.setVisible(el, visible)
	return el:setHidden(not visible)
end

-- stateChanged = element:show( )
-- stateChanged = element:hide( )
-- stateChanged = element:toggleHidden( )
function Cs.element.show(el)
	return el:setHidden(false)
end
function Cs.element.hide(el)
	return el:setHidden(true)
end
function Cs.element.toggleHidden(el)
	return el:setHidden(not el._hidden)
end



-- bool = element:isHovered( [ ignoreMouseFocus=false ] )
function Cs.element.isHovered(el, ignoreMouseFocus)
	local gui = el._gui
	updateLayoutIfNeeded(gui) -- Updates hovered element.
	return el == gui._hoveredElement and (ignoreMouseFocus or el == (gui._mouseFocus or el))
end



-- bool = element:isMouseFocus( )
-- bool = element:isKeyboardFocus( )
function Cs.element.isMouseFocus(el)
	return el == el._gui._mouseFocus
end
function Cs.element.isKeyboardFocus(el)
	return el == el._gui._keyboardFocus
end



-- bool = element:isNavigationTarget( )
function Cs.element.isNavigationTarget(el)
	return el == el._gui._navigationTarget
end



-- bool = element:isSolid( )
-- Solid elements have collision and cannot be clicked through.
function Cs.element.isSolid(el)
	return false
end



-- bool = element:isType( elementType )
function Cs.element.isType(el, elType)
	return el:is(requireElementClass(elType, 2))
end



-- element:playSound( soundKey )
function Cs.element.playSound(el, soundK)
	!ARGS"2 soundK:string"
	checkValidSoundKey(soundK, 2)

	local soundPlayer = el._gui     and el._gui._soundPlayer
	local sound       = soundPlayer and el:getResultingSound(soundK)

	if sound ~= nil then  soundPlayer(sound)  end
end



-- element:refresh( )
-- Trigger helper event "refresh".
function Cs.element.refresh(el)
	trigger(el, "refresh")
end



-- handled = element:_ok( )
function Cs.element._ok(el)
	return false
end



-- element:remove( )
-- Remove element from parent.
function Cs.element.remove(el)
	local parent = el._parent
	if parent then
		parent:removeAt(parent:indexOf(el))
	end
end



-- element:reprocessTexts( )
-- Manually re-preprocess texts. Also see gui:reprocessTexts().
function Cs.element.reprocessTexts(el)
	el:setTooltip(el._unprocessedTooltip)
end



-- element:scrollIntoView( [ scrollToDetail=false ] )
-- For input elements, scrollToDetail scrolls to the text cursor.
function Cs.element.scrollIntoView(el, scrollToDetail)
	updateLayoutIfNeeded(el._gui)

	local sbW     = themeGet(el._gui, "scrollbarWidth")
	local navSize = themeGet(el._gui, "navigationSize")

	local x1, y1 = el:getPositionOnScreen(true)
	local x2, y2 = x1+el._layoutWidth, y1+el._layoutHeight

	if scrollToDetail and el:is(Cs.input) then
		local inputEl                      = el
		local valueX, valueY               = inputEl:getValueLayout()
		local curOffsetX, curOffsetY, curH = inputEl._field:getCursorLayout()
		local inputIndent                  = themeGet(inputEl._gui, "inputIndentation")

		x1 = x1 + valueX + curOffsetX - inputIndent
		y1 = y1 + valueY + curOffsetY - inputIndent
		x2 = x1                       + 2*inputIndent
		y2 = y1 + curH                + 2*inputIndent
	end

	x1 = x1 - navSize
	y1 = y1 - navSize
	x2 = x2 + navSize
	y2 = y2 + navSize

	-- @Incomplete: navSize should probably be applied in places here below,
	-- (though it only matters if there are scrollables inside scrollables).

	repeat
		local parent = el._parent

		if parent:canScrollX() or parent:canScrollY() then
			local scrollX = parent._scrollX
			local scrollY = parent._scrollY

			if parent:canScrollX() then
				local distOutside = parent:getXOnScreen(true) - x1
				if distOutside >= 0 then
					scrollX = scrollX + distOutside
				else
					distOutside = x2 - (parent:getXOnScreen(true) + parent._layoutWidth - (parent:canScrollY() and sbW or 0))
					if distOutside > 0 then  scrollX = scrollX - distOutside  end
				end
				x1 = el:getXOnScreen(true)
				x2 = x1 + el._layoutWidth
			end

			if parent:canScrollY() then
				local distOutside = parent:getYOnScreen(true) - y1
				if distOutside >= 0 then
					scrollY = scrollY + distOutside
				else
					distOutside = y2 - (parent:getYOnScreen(true) + parent._layoutHeight - (parent:canScrollX() and sbW or 0))
					if distOutside > 0 then  scrollY = scrollY - distOutside  end
				end
				y1 = el:getYOnScreen(true)
				y2 = y1 + el._layoutHeight
			end

			parent:setScroll(scrollX, scrollY)
		end

		el, parent = parent, parent._parent
	until not parent
end



-- element:setScissor( relativeX, relativeY, width, height [, ignoreParentScrollables=false ] )
-- element:setScissor( ) -- Only applies scissors from parent scrollables.
-- Helper function for themes' drawing functions.
-- Note that each call replaces the previous scissor.
function Cs.element.setScissor(el, x, y, w, h, ignoreScrollables)
	local gui = el._gui

	el:unsetScissor()

	if x then
		setScissor(gui, el:getXOnScreen()+x, el:getYOnScreen()+y, w, h)
		gui._elementScissorIsSet = true
	end

	if not ignoreScrollables then
		local parent = el._parent

		while parent do
			if not parent then  break  end

			if parent:canScrollAny() then
				local parentX, parentY = parent:getPositionOnScreen()

				if not gui._elementScissorIsSet then
					setScissor(gui, parentX, parentY, parent:getChildAreaDimensions())
					gui._elementScissorIsSet = true
				else
					intersectScissor(el._gui, parentX, parentY, parent:getChildAreaDimensions())
				end
			end

			parent = parent._parent
		end
	end
end

-- element:unsetScissor( )
-- Remove scissor set by element:setScissor().
-- Helper function for themes' drawing functions.
function Cs.element.unsetScissor(el)
	local gui = el._gui
	if gui._elementScissorIsSet then
		setScissor(gui, nil)
		gui._elementScissorIsSet = false
	end
end



-- menuElement = element:showMenu( items [, highlightedIndex|highlightedIndices ][, offsetX=0, offsetY=0 ][, callback ] )
-- items       = { itemText1|itemInfo1, ... }
-- itemInfo    = { itemText1, itemExtraText1 }
-- callback    = function( index, itemText ) -- 'index' will be 0 if no item was chosen.
function Cs.element.showMenu(el, items, hlIndices, offsetX, offsetY, cb)
	!ARGS"2 items:table"
	-- @Cleanup

	-- showMenu( items, highlightedIndex,   offsetX, offsetY, callback )
	-- showMenu( items, highlightedIndices, offsetX, offsetY, callback )
	if (type(hlIndices) == "number" or type(hlIndices) == "table") and type(offsetX) == "number" and type(offsetY) == "number" then
		-- void

	-- showMenu( items, offsetX, offsetY, callback )
	elseif (type(hlIndices) == "number" or type(hlIndices) == "table") and type(offsetX) == "number" then
		hlIndices, offsetX, offsetY, cb = nil, hlIndices, offsetX, offsetY

	-- showMenu( items, highlightedIndex,   callback )
	-- showMenu( items, highlightedIndices, callback )
	elseif type(hlIndices) == "number" or type(hlIndices) == "table" then
		offsetX, offsetY, cb = 0, 0, offsetX

	-- showMenu( items, callback )
	else
		hlIndices, offsetX, offsetY, cb = nil, 0, 0, hlIndices
	end

	if type(cb) ~= "function" then
		error("Missing callback argument.", 2)
	end
	if type(hlIndices) == "number" then
		hlIndices = {hlIndices}
	end

	local gui  = el._gui
	local root = el:getRoot()

	updateLayoutIfNeeded(gui) -- So we get the correct self size and position here below.

	-- Create menu.

	local menu = root:insert{
		type="container", style="_MENU", relativeWidth=1, relativeHeight=1,
		closable=true, captureGuiInput=true, confineNavigation=true,
		[1] = {type="vbar", minWidth=el._layoutWidth, maxHeight=root._height},
	}

	menu:on("closed", function(button, event)
		local _cb = cb
		cb        = nil

		menu:remove()

		if _cb then  _cb(0, "")  end
	end)

	menu:on("mousepressed", function(button, event, mx, my, mbutton, pressCount)
		menu:close()
	end)

	-- Add menu items.
	local buttons = menu[1]

	for i, text in ipairs(items) do
		local text2 = nil
		if type(text) == "table" then  text, text2 = unpack(text)  end

		local isToggled = (hlIndices ~= nil and indexOf(hlIndices, i) ~= nil)
		local button    = buttons:insert{ type="button", text=text, text2=text2, align="left", toggled=isToggled }

		button:on("mousepressed", function(button, event, mx, my, mbutton, pressCount)
			if mbutton == 1 then  button:press()  end
			return true -- Prevent the menu from receiving the mousepressed event.
		end)

		button:on("press", function(button, event)
			local _cb = cb
			cb        = nil

			menu:remove()

			if _cb then  _cb(i, text)  end
		end)

		button:on("navigated", function(button, event)
			buttons:setToggledChild(button._id)
		end)
	end

	if not buttons[1] then
		warn(2, "No menu buttons.")
	end

	local searchTerm       = ""
	local searchStartIndex = 1
	local lastInputTime    = -99

	if gui._standardKeysAreActive or gui._standardKeysAreActiveInMenus then
		menu:on("keypressed", function(button, event, key, scancode, isRepeat)
			if key == "up" then
				local button     = buttons:getToggledChild()
				searchStartIndex = button and (button:getIndex()-2)%#buttons+1 or 1
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "down" then
				local button     = buttons:getToggledChild()
				searchStartIndex = button and button:getIndex()%#buttons+1 or 1
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "home" or key == "pageup" then
				searchStartIndex = 1
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "end" or key == "pagedown" then
				searchStartIndex = #buttons
				lastInputTime    = -99
				gui:navigateTo(buttons[searchStartIndex])
				return true

			elseif key == "return" or key == "kpenter" then
				local button = buttons:getToggledChild()
				if button then  button:press()  end
				return true

			elseif gui._standardKeysAreActive and (key == "left" or key == "right" or key == "tab") then
				-- Prevent _standardKeysAreActive from doing stuff in gui:keypressed().
				return true
			end
		end)
	end

	menu:on("textinput", function(button, event, text)
		if not buttons[1] then  return  end

		-- Append to old or start a new term.
		local time = gui._time
		if time-lastInputTime > 1.00 then
			searchTerm       = text:lower()
			local button     = buttons:getToggledChild()
			searchStartIndex = button and button:getIndex() or 1
		else
			searchTerm = searchTerm..text:lower()
		end
		lastInputTime = time

		-- Pressing the same letter over and over should just cycle through all items starting with that letter.
		if #searchTerm > 1 then -- @Robustness: Use UTF-8 character length - not byte length!
			local firstChar = searchTerm:match!("^"..UTF8_CHAR_PATTERN)
			local reps      = #searchTerm / #firstChar

			if reps == math.floor(reps) and searchTerm == firstChar:rep(reps) then
				local i        = searchStartIndex
				local foundAny = false

				while true do
					i            = i % #buttons + 1
					local button = buttons[i]

					if button._text:lower():find(firstChar, 1, true) == 1 then
						reps     = reps - 1
						foundAny = true

						if reps <= 0 then
							gui:navigateTo(button)
							return
						end

					elseif i == searchStartIndex and not foundAny then
						return
					end
				end

			end
		end

		-- Otherwise search for the whole term.
		for i = 1, #buttons do
			i = (searchStartIndex+i-1)%#buttons+1
			local button = buttons[i]

			if button._text:lower():find(searchTerm, 1, true) == 1 then
				gui:navigateTo(button)
				break
			end
		end
	end)

	-- Set position.

	menu:_calculateNaturalSize() -- Expanding and positioning of the whole menu isn't necessary right here.

	buttons:setPosition(
		clamp(el:getXOnScreen()+offsetX, 0, root._width -buttons._layoutWidth ),
		clamp(el:getYOnScreen()+offsetY, 0, root._height-buttons._layoutHeight)
	)

	local button = buttons:getToggledChild()
	if button then  gui:navigateTo(button)  end

	return menu
end



-- FINAL  element:updateLayout( )
-- Force a layout update. (Should never be needed as it's done automatically.)
-- Also see gui:updateLayout().
function Cs.element.updateLayout(el)
	updateLayout(el)
end

-- INTERNAL  element:_calculateNaturalSize( )
-- (Subclasses should replace this method.)
function Cs.element._calculateNaturalSize(el)
	-- void
end

-- INTERNAL  element:_expandAndPositionChildren( )
function Cs.element._expandAndPositionChildren(el)
	-- void
end



--==============================================================
--= Container element class ====================================
--==============================================================



Cs.container = newElementClass(false, "GuiContainer", Cs.element, {}, {
	-- Parameters.
	_confineNavigation = false,
	_solid             = false,

	_paddingLeft   = 0, -- Falls back to 'paddingHorizontal' and 'padding'.
	_paddingRight  = 0, -- Falls back to 'paddingHorizontal' and 'padding'.
	_paddingTop    = 0, -- Falls back to 'paddingVertical' and 'padding'.
	_paddingBottom = 0, -- Falls back to 'paddingVertical' and 'padding'.

	_canScrollX = false,
	_canScrollY = false,
	--

	_contentWidth  = 0,
	_contentHeight = 0,

	_mouseScrollDirection = "", -- "" | "x" | "y"
	_mouseScrollOffset    = 0,

	_scrollX = 0.0,
	_scrollY = 0.0,

	_visualScrollX = 0.0,
	_visualScrollY = 0.0,
}, {
	-- void
})

function Cs.container.init(container, gui, elData, parent)
	Cs.container.super.init(container, gui, elData, parent)

	@@retrieve(container, elData, _canScrollX, _canScrollY)
	@@retrieve(container, elData, _confineNavigation)
	-- @@retrieve(container, elData, _paddingLeft, _paddingRight, _paddingTop, _paddingBottom)
	@@retrieve(container, elData, _solid)

	container._paddingLeft   = elData.paddingLeft   or elData.paddingHorizontal or elData.padding
	container._paddingRight  = elData.paddingRight  or elData.paddingHorizontal or elData.padding
	container._paddingTop    = elData.paddingTop    or elData.paddingVertical   or elData.padding
	container._paddingBottom = elData.paddingBottom or elData.paddingVertical   or elData.padding

	for i, childData in ipairs(elData) do
		local class  = Cs[getTypeFromElementData(childData)] or errorf("Bad element type '%s'.", getTypeFromElementData(childData))
		local child  = class(gui, childData, container)
		container[i] = child
	end
end



-- INTERNAL OVERRIDE  container:_update( deltaTime )
function Cs.container._update(container, dt)
	Cs.container.super._update(container, dt)

	for _, child in ipairs(container) do
		child:_update(dt)
	end

	local scrollX = container._scrollX
	local scrollY = container._scrollY

	local visualScrollX = container._visualScrollX
	local visualScrollY = container._visualScrollY

	local didScroll = false

	if visualScrollX ~= scrollX then
		visualScrollX = damp(scrollX, visualScrollX, container._gui._scrollSmoothness, dt)
		if math.abs(visualScrollX-scrollX) < .5 then  visualScrollX = scrollX  end
		didScroll = true
	end
	if visualScrollY ~= scrollY then
		visualScrollY = damp(scrollY, visualScrollY, container._gui._scrollSmoothness, dt)
		if math.abs(visualScrollY-scrollY) < .5 then  visualScrollY = scrollY  end
		didScroll = true
	end

	if didScroll then
		setVisualScroll(container, visualScrollX, visualScrollY)
	end
end



local function drawChildrenAndMaybeNavigationTarget(container, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	for _, child in ipairs(container) do
		local x, y, w, h = xywhOnScreen(child)
		local drawChild  = child:is(Cs.container) or (x+w >= cullX1-1 and y+h >= cullY1-1 and x < cullX2+1 and y < cullY2+1)

		if child == childToDrawNavTargetAfter then
			if drawChild then
				child:_draw(cullX1, cullY1, cullX2, cullY2, nil)
			end
			if not container._gui.debug then
				themeRender(container._gui._navigationTarget, "navigation", container._gui._timeSinceNavigation) -- We don't really need to cull this.
			end
		else
			if drawChild then
				child:_draw(cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
			end
		end
	end
end

-- INTERNAL REPLACE  container:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.container._draw(container, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if container._hidden then  return  end

	local gui        = container._gui
	local x, y, w, h = xywhOnScreen(container)

	local childAreaW, childAreaH = container:getChildAreaDimensions()

	local sbW = themeGet(gui, "scrollbarWidth") -- @Incomplete: Get scrollbar width through themeGetSize().

	local canScrollX = container:canScrollX()
	local canScrollY = container:canScrollY()

	if not container._gui.debug then
		triggerIncludingAnimations(container, "beforedraw", x, y, w, h)
	end

	drawLayoutBackground(container)
	container:_drawDebug(0, 0, 1)

	if canScrollX or canScrollY then
		setScissor(gui, x, y, childAreaW, childAreaH) -- Should there be an option to not scissor scrollable containers? @Incomplete
		if container._gui._culling then
			cullX1 = math.max(cullX1, x)
			cullY1 = math.max(cullY1, y)
			cullX2 = math.min(cullX2, x+childAreaW)
			cullY2 = math.min(cullY2, y+childAreaH)
		end
	end
	drawChildrenAndMaybeNavigationTarget(container, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if canScrollX or canScrollY then
		setScissor(gui, nil)
	end

	if not container._gui.debug then
		-- Scrollbars.
		if canScrollX then
			local handlePos, handleLen = container:getScrollHandleX()
			themeRenderArea(container, "scrollbar", 0, h-sbW, childAreaW, sbW, "x", round(handlePos), handleLen)
		end
		if canScrollY then
			local handlePos, handleLen = container:getScrollHandleY()
			themeRenderArea(container, "scrollbar", w-sbW, 0, sbW, childAreaH, "y", round(handlePos), handleLen)
		end
		if canScrollX and canScrollY then
			themeRenderArea(container, "scrollbardeadzone", w-sbW, h-sbW, sbW, sbW)
		end

		triggerIncludingAnimations(container, "afterdraw", x, y, w, h)
	end
end



-- element|nil = container:find( id )
function Cs.container.find(container, id)
	for el in container:traverse() do
		if el._id == id then  return el  end
	end
	return nil
end

-- elements = container:findAll( id )
function Cs.container.findAll(container, id)
	local els = {}
	for el in container:traverse() do
		if el._id == id then  table.insert(els, el)  end
	end
	return els
end

-- element|nil = container:findType( elementType )
function Cs.container.findType(container, elType)
	local class = requireElementClass(elType, 2)

	for el in container:traverse() do
		if el:is(class) then  return el  end
	end

	return nil
end

-- widget|nil = container:findActive( )
function Cs.container.findActive(container)
	for el in container:traverse() do
		if el:is(Cs.widget) and el._active then  return el  end
	end
	return nil
end

-- button|nil = container:findToggled( )
function Cs.container.findToggled(container)
	for el in container:traverse() do
		if el:is(Cs.button) and el._toggled then  return el  end
	end
	return nil
end

-- element|nil = container:match( selector [, includeSelf=false ] )
-- selector    = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Match an element using a CSS-like selector.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Cs.container.match(container, selector, includeSelf)
	local selPath = parseSelector(selector)
	if not selPath then  return nil  end

	local breakElement = (not includeSelf) and container or container._parent
	if includeSelf and isElementMatchingSelectorPath(container, selPath, breakElement) then
		return container
	end

	for el in container:traverse() do
		if isElementMatchingSelectorPath(el, selPath, breakElement) then
			return el
		end
	end

	return nil
end

-- elements = container:matchAll( selector [, includeSelf=false ] )
-- selector = "elementType #id .tag" -- Sequence of space-separated element types, IDs and tags.
-- Match elements using a CSS-like selector.
-- Note: Element types include subtypes (e.g. 'bar' includes both 'vbar' and 'hbar').
function Cs.container.matchAll(container, selector, includeSelf)
	local elements = {}
	local selPath  = parseSelector(selector)

	if selPath then
		local breakElement = (not includeSelf) and container or container._parent
		if includeSelf and isElementMatchingSelectorPath(container, selPath, breakElement) then
			table.insert(elements, container)
		end

		for el in container:traverse() do
			if isElementMatchingSelectorPath(el, selPath, breakElement) then
				table.insert(elements, el)
			end
		end
	end

	return elements
end



-- spaceX, spaceY = container:getInnerSpace( )
-- space = container:getInnerSpaceX( )
-- space = container:getInnerSpaceY( )
function Cs.container.getInnerSpace(container)
	local spaceX = container._paddingLeft + container._paddingRight
	local spaceY = container._paddingTop  + container._paddingBottom
	local sbW    = themeGet(container._gui, "scrollbarWidth")
	if container:canScrollY() then  spaceX = spaceX + sbW  end
	if container:canScrollX() then  spaceY = spaceY + sbW  end
	return spaceX, spaceY
end
function Cs.container.getInnerSpaceX(container)
	local space = container._paddingLeft + container._paddingRight
	if container:canScrollY() then
		space = space + themeGet(container._gui, "scrollbarWidth")
	end
	return space
end
function Cs.container.getInnerSpaceY(container)
	local space = container._paddingTop + container._paddingBottom
	if container:canScrollX() then
		space = space + themeGet(container._gui, "scrollbarWidth")
	end
	return space
end



-- paddingLeft, paddingRight, paddingTop, paddingBottom = container:getPadding( )
-- padding = container:getPaddingLeft( )
-- padding = container:getPaddingRight( )
-- padding = container:getPaddingTop( )
-- padding = container:getPaddingBottom( )
function Cs.container.getPadding(container)
	return container._paddingLeft, container._paddingRight, container._paddingTop, container._paddingBottom
end
function Cs.container.getPaddingLeft  (container)  return container._paddingLeft    end
function Cs.container.getPaddingRight (container)  return container._paddingRight   end
function Cs.container.getPaddingTop   (container)  return container._paddingTop     end
function Cs.container.getPaddingBottom(container)  return container._paddingBottom  end

-- container:setPadding( padding )
-- container:setPadding( paddingHorizontal, paddingVertical )
-- container:setPadding( paddingLeft, paddingRight, paddingTop, paddingBottom )
-- container:setPaddingLeft( padding )
-- container:setPaddingRight( padding )
-- container:setPaddingTop( padding )
-- container:setPaddingBottom( padding )
function Cs.container.setPadding(container, paddingL, paddingR, paddingT, paddingB)
	!ARGS"2 paddingL:number"

	if not paddingR then
		paddingL, paddingR, paddingT, paddingB = paddingL, paddingL, paddingL, paddingL
	elseif not paddingB then
		paddingL, paddingR, paddingT, paddingB = paddingL, paddingL, paddingR, paddingR
	end

	if
		container._paddingLeft   == paddingL and
		container._paddingRight  == paddingR and
		container._paddingTop    == paddingT and
		container._paddingBottom == paddingB
	then
		return
	end

	container._paddingLeft   = paddingL
	container._paddingRight  = paddingR
	container._paddingTop    = paddingT
	container._paddingBottom = paddingB

	scheduleLayoutUpdateIfDisplayed(container)
end
function Cs.container.setPaddingLeft(container, padding)
	!ARGS"2 padding:number"
	if container._paddingLeft == padding then  return  end
	container._paddingLeft = padding
	scheduleLayoutUpdateIfDisplayed(container)
end
function Cs.container.setPaddingRight(container, padding)
	!ARGS"2 padding:number"
	if container._paddingRight == padding then  return  end
	container._paddingRight = padding
	scheduleLayoutUpdateIfDisplayed(container)
end
function Cs.container.setPaddingTop(container, padding)
	!ARGS"2 padding:number"
	if container._paddingTop == padding then  return  end
	container._paddingTop = padding
	scheduleLayoutUpdateIfDisplayed(container)
end
function Cs.container.setPaddingBottom(container, padding)
	!ARGS"2 padding:number"
	if container._paddingBottom == padding then  return  end
	container._paddingBottom = padding
	scheduleLayoutUpdateIfDisplayed(container)
end



-- bool = container:isScrollbarXHovered( )
-- bool = container:isScrollbarYHovered( )
function Cs.container.isScrollbarXHovered(container)
	local gui  = container._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local x1, y1 = container:getPositionOnScreen()
	local x2, y2 = x1+container:getChildAreaWidth(), y1+container._layoutHeight
	y1           = y2 - themeGet(container._gui, "scrollbarWidth")

	return x >= x1 and x < x2 and y >= y1 and y < y2
end
function Cs.container.isScrollbarYHovered(container)
	local gui  = container._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local x1, y1 = container:getPositionOnScreen()
	local x2, y2 = x1+container._layoutWidth, y1+container:getChildAreaHeight()
	x1           = x2 - themeGet(container._gui, "scrollbarWidth")

	return x >= x1 and x < x2 and y >= y1 and y < y2
end

-- bool = container:isScrollbarXHandleHovered( )
-- bool = container:isScrollbarYHandleHovered( )
function Cs.container.isScrollbarXHandleHovered(container)
	local gui  = container._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local handlePos, handleLen = container:getScrollHandleX()
	local x1, y1               = container:getPositionOnScreen()

	x1       = x1 + handlePos
	local x2 = x1 + handleLen

	local y2 = y1 + container._layoutHeight
	y1       = y2 - themeGet(container._gui, "scrollbarWidth")

	return x >= x1 and x < x2 and y >= y1 and y < y2
end
function Cs.container.isScrollbarYHandleHovered(container)
	local gui  = container._gui
	local x, y = gui._mouseX, gui._mouseY
	if x == !(MOUSE_POS_UNKNOWN) then  return false  end

	local handlePos, handleLen = container:getScrollHandleY()
	local x1, y1               = container:getPositionOnScreen()

	local x2 = x1 + container._layoutWidth
	x1       = x2 - themeGet(container._gui, "scrollbarWidth")

	y1       = y1 + handlePos
	local y2 = y1 + handleLen

	return x >= x1 and x < x2 and y >= y1 and y < y2
end



-- bool = container:isScrollingX( )
-- bool = container:isScrollingY( )
function Cs.container.isScrollingX(container)
	return container._mouseScrollDirection == "x"
end
function Cs.container.isScrollingY(container)
	return container._mouseScrollDirection == "y"
end



-- x, y = container:getScroll( )
-- x = container:getScrollX( )
-- y = container:getScrollY( )
function Cs.container.getScroll(container)
	return container._scrollX, container._scrollY
end
function Cs.container.getScrollX(container)
	return container._scrollX
end
function Cs.container.getScrollY(container)
	return container._scrollY
end

-- scrollChanged = container:setScroll( x, y [, immediate=false ] )
function Cs.container.setScroll(container, scrollX, scrollY, immediate)
	!ARGS"2 scrollX,scrollY:number"
	updateLayoutIfNeeded(container._gui)

	-- Limit scrolling.
	local limitX, limitY = container:getScrollLimit()

	scrollX  = math.min(math.max(scrollX, limitX), 0)
	scrollY  = math.min(math.max(scrollY, limitY), 0)
	local dx = scrollX - container._scrollX
	local dy = scrollY - container._scrollY

	if dx == 0 and dy == 0 then  return false  end
	--

	container._scrollX = scrollX
	container._scrollY = scrollY

	for el in container:traverse() do
		el._layoutImmediateOffsetX = el._layoutImmediateOffsetX + dx
		el._layoutImmediateOffsetY = el._layoutImmediateOffsetY + dy
	end

	if immediate then  setVisualScroll(container, scrollX, scrollY)  end

	if container._gui._scrollSoundSuppressionLevel == 0 and container:isDisplayed() then
		container:playSound("scroll") -- @Robustness: May have to add more limitations to whether the 'scroll' sound plays or not.
		updateHoveredElement(container._gui)
	end

	return true
end

-- scrollChanged = container:setScrollX( x [, immediate=false ] )
-- scrollChanged = container:setScrollY( y [, immediate=false ] )
function Cs.container.setScrollX(container, scrollX, immediate)
	return (container:setScroll(scrollX, container._scrollY, immediate))
end
function Cs.container.setScrollY(container, scrollY, immediate)
	return (container:setScroll(container._scrollX, scrollY, immediate))
end

-- scrollChanged = container:scroll( deltaX, deltaY [, immediate=false ] )
function Cs.container.scroll(container, dx, dy, immediate)
	return (container:setScroll(container._scrollX+dx, container._scrollY+dy, immediate))
end

local function updateScroll(container)
	local gui                        = container._gui
	gui._scrollSoundSuppressionLevel = gui._scrollSoundSuppressionLevel + 1 -- There might be a possibility we get called recursively. Better not taking any chances and use a level instead of a bool.
	container:setScroll(container._scrollX, container._scrollY, false)
	gui._scrollSoundSuppressionLevel = gui._scrollSoundSuppressionLevel - 1
end



do
	local function getScrollHandle(container, padding, childAreaSize, contentSize, scroll)
		local insideSize = childAreaSize - padding

		local handleLen = math.max(
			round(childAreaSize * math.min(insideSize/contentSize, 1)),
			themeGet(container._gui, "scrollbarMinLength")
		)

		local handlePos    = 0
		local handleMaxPos = 0

		if contentSize > insideSize then
			handleMaxPos = childAreaSize - handleLen
			handlePos    = -scroll * handleMaxPos / (contentSize - insideSize)
			handlePos    = math.min(handlePos, handleMaxPos)
		end

		return handlePos, handleLen, handleMaxPos
	end

	-- @Incomplete: container:getScrollHandles()?

	-- position, length, maxPosition = container:getScrollHandleX( )
	-- position, length, maxPosition = container:getScrollHandleY( )
	-- Units are in pixels.
	function Cs.container.getScrollHandleX(container)
		updateLayoutIfNeeded(container._gui)
		return getScrollHandle(container, container._paddingLeft+container._paddingRight, container:getChildAreaWidth(), container._contentWidth, container._scrollX)
	end
	function Cs.container.getScrollHandleY(container)
		updateLayoutIfNeeded(container._gui)
		return getScrollHandle(container, container._paddingTop+container._paddingBottom, container:getChildAreaHeight(), container._contentHeight, container._scrollY)
	end
end



-- x, y = container:getScrollLimit( )
-- x = container:getScrollLimitX( )
-- y = container:getScrollLimitY( )
function Cs.container.getScrollLimit(container)
	local w, h = container:getChildAreaDimensions()
	return
		w - (container._paddingLeft+container._paddingRight) - container._contentWidth,
		h - (container._paddingTop+container._paddingBottom) - container._contentHeight
end
function Cs.container.getScrollLimitX(container)
	return container:getChildAreaWidth()  - (container._paddingLeft+container._paddingRight) - container._contentWidth
end
function Cs.container.getScrollLimitY(container)
	return container:getChildAreaHeight() - (container._paddingTop+container._paddingBottom) - container._contentHeight
end



-- child = container:getVisibleChild( [ number=1 ] )
function Cs.container.getVisibleChild(container, n)
	n = n or 1
	for _, child in ipairs(container) do
		if not child._hidden then
			n = n - 1
			if n == 0 then  return child  end
		end
	end
	return nil
end

-- number = container:getVisibleChildNumber( child )
function Cs.container.getVisibleChildNumber(container, el)
	local n = 0
	for _, child in ipairs(container) do
		if not child._hidden then
			n = n + 1
			if child == el then  return n  end
		end
	end
	return nil
end

-- count = container:getVisibleChildCount( )
function Cs.container.getVisibleChildCount(container)
	local count = 0
	for _, child in ipairs(container) do
		if not child._hidden then  count = count + 1  end
	end
	return count
end

-- visibleChild = container:setVisibleChild( id )
-- If multiple children have the given ID then the last one is returned.
-- @Cleanup: Rename to setVisibleChildById()? Maybe more functions should be changed too.
function Cs.container.setVisibleChild(container, id)
	local visibleChild = nil
	for _, child in ipairs(container) do
		if child._id == id then
			child:show()
			visibleChild = child
		else
			child:hide()
		end
	end
	return visibleChild
end



-- x, y = container:getVisualScroll( )
-- x = container:getVisualScrollX( )
-- y = container:getVisualScrollY( )
function Cs.container.getVisualScroll(container)
	return container._visualScrollX, container._visualScrollY
end
function Cs.container.getVisualScrollX(container)
	return container._visualScrollX
end
function Cs.container.getVisualScrollY(container)
	return container._visualScrollY
end



-- bool = container:canScrollAny( )
-- bool = container:canScrollX( ) -- Horizontal scrolling, scrollbar on the bottom side.
-- bool = container:canScrollY( ) -- Vertical scrolling, scrollbar on the right side.
function Cs.container.canScrollAny(container)
	return container._canScrollX or container._canScrollY
end
function Cs.container.canScrollX(container)
	return container._canScrollX
end
function Cs.container.canScrollY(container)
	return container._canScrollY
end



-- index|nil = container:indexOf( element )
-- Returns nil if the element isn't a child.
Cs.container.indexOf = indexOf



-- REPLACE  bool = container:isSolid( )
function Cs.container.isSolid(container)
	return container._solid or container._background ~= "" or container:canScrollAny()
end



-- child, index = container:get( index )
-- child, index = container:get( id )
-- Note: container:get(index) is the same as container[index].
-- Returns nil if no child matches.
function Cs.container.get(container, iOrId)
	if type(iOrId) == "string" then
		for i, child in ipairs(container) do
			if child._id == iOrId then  return child, i  end
		end
		return nil
	else
		local child = container[iOrId]
		return child, (child and iOrId or nil)
	end
end

-- for index, child in container:children( )
Cs.container.children = ipairs



-- width, height = container:getChildAreaDimensions( )
-- width  = container:getChildAreaWidth( )
-- height = container:getChildAreaHeight( )
function Cs.container.getChildAreaDimensions(container)
	updateLayoutIfNeeded(container._gui)
	local sbW = themeGet(container._gui, "scrollbarWidth")
	return
		(container:canScrollY() and container._layoutWidth -sbW or container._layoutWidth ),
		(container:canScrollX() and container._layoutHeight-sbW or container._layoutHeight)
end
function Cs.container.getChildAreaWidth(container)
	updateLayoutIfNeeded(container._gui)
	return
		container:canScrollY()
		and container._layoutWidth - themeGet(container._gui, "scrollbarWidth")
		or  container._layoutWidth
end
function Cs.container.getChildAreaHeight(container)
	updateLayoutIfNeeded(container._gui)
	return
		container:canScrollX()
		and container._layoutHeight - themeGet(container._gui, "scrollbarWidth")
		or  container._layoutHeight
end



-- child|nil = container:getChildWithData( dataKey, dataValue )
function Cs.container.getChildWithData(container, k, v)
	for _, child in ipairs(container) do
		if child._data[k] == v then  return child  end
	end
	return nil
end



-- element|nil = container:getElementAt( x, y [, includeNonSolid=false ] )
function Cs.container.getElementAt(container, x, y, nonSolid)
	updateLayoutIfNeeded(container._gui)

	if container:canScrollAny() then
		local containerX, containerY = container:getPositionOnScreen()
		if x <  containerX                                then  return nil  end
		if y <  containerY                                then  return nil  end
		if x >= containerX+container:getChildAreaWidth()  then  return nil  end
		if y >= containerY+container:getChildAreaHeight() then  return nil  end
	end

	for _, el in ipairs(container:_collectVisibleUntilInputCapture(x, y, @@STATIC{})) do
		if ((nonSolid or el:isSolid()) and el:isAt(x, y)) or (el._captureInput or el._captureGuiInput) then
			return el
		end
	end

	return nil
end



-- child = container:insert( elementData [, index=atEnd ] )
-- See gui:load() for the elementData format.
function Cs.container.insert(container, childData, i)
	!ARGS"2 childData:table ? i:number"

	local class = Cs[getTypeFromElementData(childData)] or errorf("Bad element type '%s'.", getTypeFromElementData(childData))
	local child = class(container._gui, childData, container)
	table.insert(container, (i or #container+1), child)

	printHeres(container._gui)
	scheduleLayoutUpdateIfDisplayed(child)

	local themeInit = themeGet(container._gui, "init")
	themeInit(child)
	if child:is(Cs.container) then
		for el in child:traverse() do
			themeInit(el)
		end
	end

	validateNavigationTarget(container._gui) -- Is this needed during insertions? @Cleanup
	scheduleLayoutUpdateIfDisplayed(child)

	return child
end

-- REPLACE  container:removeAt( index )
-- Note that grandchildren are also removed from their parent. (Is this good?)
function Cs.container.removeAt(container, i)
	!ARGS"2 i:number"

	local child = container[i]
	if not child then
		printerr(2, "Child index %d is out of bounds.", i)
		return
	end

	if child:is(Cs.container) then
		child:empty()
	end

	-- Note: The child still keeps the reference to the GUI.
	child._parent = nil
	table.remove(container, i)

	validateNavigationTarget(container._gui)
	scheduleLayoutUpdateIfDisplayed(container)
end

-- container:empty( )
-- Note that children are also emptied recursively. (Is this good?)
function Cs.container.empty(container)
	for i = #container, 1, -1 do
		container:removeAt(i)
	end
end



-- INTERNAL REPLACE  handled, grabMouseFocus = container:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.container._mousepressed(container, mx, my, mbutton, pressCount)
	if mbutton == 1 then
		local x0        , y0         = container:getPositionOnScreen()
		local childAreaW, childAreaH = container:getChildAreaDimensions()
		local sbW                    = themeGet(container._gui, "scrollbarWidth")

		-- Horizontal scrolling.
		----------------------------------------------------------------
		local x2, y2 = x0+childAreaW, y0+container._layoutHeight
		local x1, y1 = x0           , y2-sbW

		if mx >= x1 and mx < x2 and my >= y1 and my < y2 then
			local handlePos, handleLen      = container:getScrollHandleX()
			container._mouseScrollDirection = "x"

			-- Drag handle.
			if mx >= x1+handlePos and mx < x1+handlePos+handleLen then
				container._mouseScrollOffset = mx - x1 - handlePos

			-- Jump and drag.
			else
				container._mouseScrollOffset = handleLen / 2
				container:_mousemoved(mx, my)
			end

			return true, true
		end

		-- Vertical scrolling.
		----------------------------------------------------------------
		local y2, x2 = y0+childAreaH, x0+container._layoutWidth
		local y1, x1 = y0           , x2-sbW

		if mx >= x1 and mx < x2 and my >= y1 and my < y2 then
			local handlePos, handleLen      = container:getScrollHandleY()
			container._mouseScrollDirection = "y"

			-- Drag handle.
			if my >= y1+handlePos and my < y1+handlePos+handleLen then
				container._mouseScrollOffset = my - y1 - handlePos

			-- Jump and drag.
			else
				container._mouseScrollOffset = handleLen / 2
				container:_mousemoved(mx, my)
			end

			return true, true
		end

		----------------------------------------------------------------
	end

	return false, false
end

-- INTERNAL REPLACE  container:_mousemoved( mouseX, mouseY )
function Cs.container._mousemoved(container, mx, my)
	-- Horizontal scrolling.
	if container._mouseScrollDirection == "x" then
		local _, _, handleMaxPos = container:getScrollHandleX()
		container:setScrollX((mx - container:getXOnScreen() - container._mouseScrollOffset) * container:getScrollLimitX() / handleMaxPos, true)

	-- Vertical scrolling.
	elseif container._mouseScrollDirection == "y" then
		local _, _, handleMaxPos = container:getScrollHandleY()
		container:setScrollY((my - container:getYOnScreen() - container._mouseScrollOffset) * container:getScrollLimitY() / handleMaxPos, true)
	end
end

-- INTERNAL REPLACE  container:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.container._mousereleased(container, mx, my, mbutton, pressCount)
	if mbutton == 1 then
		container._mouseScrollDirection = ""
		container._mouseScrollOffset    = 0
	end
end

-- INTERNAL REPLACE  handled = container:_wheelmoved( deltaX, deltaY, deltaX0, deltaY0 )
function Cs.container._wheelmoved(container, dx, dy, dx0, dy0)
	if (dx ~= 0 and container:canScrollX()) or (dy ~= 0 and container:canScrollY()) then
		local gui   = container._gui
		local fontH = (gui._font or _M.getDefaultFont()):getHeight()

		if container:scroll(gui._scrollSpeedX*fontH*dx, gui._scrollSpeedY*fontH*dy) then
			return true
		end
	end

	return false
end



-- OVERRIDE  container:remove( )
function Cs.container.remove(container, _removeAt_i)
	if _removeAt_i ~= nil then
		warn(2, "container:remove() called with an argument. Did you mean to call container:removeAt(index)?")
	end
	return Cs.container.super.remove(container)
end



-- OVERRIDE  container:reprocessTexts( )
function Cs.container.reprocessTexts(container)
	Cs.container.super.reprocessTexts(container)
	for _, child in ipairs(container) do
		child:reprocessTexts()
	end
end



-- container:setChildrenActive( bool )
function Cs.container.setChildrenActive(container, active)
	for _, child in ipairs(container) do
		if child:is(Cs.widget) then  child:setActive(active)  end
	end
end



-- container:setChildrenHidden( bool )
function Cs.container.setChildrenHidden(container, hidden)
	for _, child in ipairs(container) do
		child:setHidden(hidden)
	end
end



-- button|nil = container:getToggledChild( [ includeGrandchildren=false ] )
function Cs.container.getToggledChild(container, deep)
	if deep then
		for button in container:traverseType"button" do
			if button:isToggled() then  return button  end
		end
	else
		for _, child in ipairs(container) do
			if child:is(Cs.button) and child:isToggled() then  return child  end
		end
	end
	return nil
end

-- button|nil = container:setToggledChild( id [, includeGrandchildren=false ] )
-- If multiple children have the given ID then the last one is returned.
function Cs.container.setToggledChild(container, id, deep)
	local toggledChild = nil
	if deep then
		for button in container:traverseType"button" do
			if button._id == id then
				button:setToggled(true)
				toggledChild = button
			else
				button:setToggled(false)
			end
		end
	else
		for _, child in ipairs(container) do
			if child:is(Cs.button) then
				if child._id == id then
					child:setToggled(true)
					toggledChild = child
				else
					child:setToggled(false)
				end
			end
		end
	end
	return toggledChild
end



-- container:sort( sortFunction )
-- aIsLessThanB = sortFunction( elementA, elementB )
function Cs.container.sort(container, func)
	!ARGS"2 func:function"
	table.sort(container, func)
	scheduleLayoutUpdateIfDisplayed(container)
end



!-- @@eachElement( )
!-- @@eachElement( condition )
!local function eachElement(condition)
	return function(stack) -- @Memory
		local len = stack[0]
		local child

		!(if condition then )repeat!( end)
			-- Get next child.
			repeat
				local i    = stack[len] + 1
				stack[len] = i
				child      = stack[len-1][i]

				if not child then
					len = len - 2 -- Don't bother removing values from the stack.
					if len == 0 then  return  end -- Done traversing!
				end
			until child

			if child:is(Cs.container) then
				len          = len + 2
				stack[len-1] = child
				stack[len  ] = 0
			end
		!(if condition then )until $condition!( end)

		stack[0] = len
		return child
	end, {[0--[[length]]]=2, container, 0} -- @Memory
!end

-- for element in container:traverse( )
function Cs.container.traverse(container)
	@@eachElement()
end

-- for element in container:traverseType( elementType )
function Cs.container.traverseType(container, elType)
	local class = requireElementClass(elType, 2)
	@@eachElement(child:is(class))
end

do
	!local function eachVisible(whenContainer, whenTarget, whenLoopTrail)
		for i = #el, 1, -1 do
			local child = el[i]

			if not child._hidden then
				if child:is(Cs.container) then
					$whenContainer
				end
				$whenTarget
			end

			$whenLoopTrail
		end
	!end
	local function _traverseVisible(el)
		!eachVisible(
			`_traverseVisible(child)`,
			`coroutine.yield(child)`,
			``
		)
	end
	local function _visitVisible(el, cb)
		!eachVisible(
			`if _visitVisible(child, cb) == "stop" then  return "stop"  end`,
			`if cb(child) == "stop" then  return "stop"  end`,
			``
		)
	end
	local function _collectVisible(el, elements)
		!eachVisible(
			`_collectVisible(child, elements)`,
			`table.insert(elements, child)`,
			``
		)
	end
	local function _collectVisibleUntilInputCapture(el, elements)
		!eachVisible(
			`if _collectVisibleUntilInputCapture(child, elements) then  return true  end`,
			`table.insert(elements, child)`,
			`if child._captureInput or child._captureGuiInput then  return true  end`
		)
	end

	!local function eachVisibleAt(whenChildren, whenTarget, whenLoopTrail)
		for i = #el, 1, -1 do
			local child = el[i]

			if not child._hidden then
				local isContainer     = child:is(Cs.container)
				local includeSelf     = true
				local includeChildren = isContainer

				if isContainer and child:canScrollAny() then
					local childX, childY, childW, childH = xywhOnScreen(child)
					if x < childX or y < childY then
						includeSelf     = false
						includeChildren = false
					else
						includeSelf     = (x < childX+childW and y < childY+childH)
						includeChildren = (includeSelf and x < childX+child:getChildAreaWidth() and y < childY+child:getChildAreaHeight())
					end
				end

				if includeSelf then
					if includeChildren then
						$whenChildren
					end
					$whenTarget
				end
			end

			$whenLoopTrail
		end
	!end
	local function _traverseVisibleAt(el, x, y, sbW)
		!eachVisibleAt(
			`_traverseVisibleAt(child, x, y, sbW)`,
			`coroutine.yield(child)`,
			``
		)
	end
	local function _visitVisibleAt(el, x, y, sbW, cb)
		!eachVisibleAt(
			`if _visitVisibleAt(child, x, y, sbW, cb) == "stop" then  return "stop"  end`,
			`if cb(child) == "stop" then  return "stop"  end`,
			``
		)
	end
	local function _collectVisibleAt(el, x, y, sbW, elements)
		!eachVisibleAt(
			`_collectVisibleAt(child, x, y, sbW, elements)`,
			`table.insert(elements, child)`,
			``
		)
	end
	local function _collectVisibleUntilInputCaptureAt(el, x, y, sbW, elements)
		!eachVisibleAt(
			`if _collectVisibleUntilInputCaptureAt(child, x, y, sbW, elements) then  return true  end`,
			`table.insert(elements, child)`,
			`if child._captureInput or child._captureGuiInput then  return true  end`
		)
	end

	-- for element in container:traverseVisible( ) -- @Cleanup: Maybe remove in favor of visitVisible()? Easy way to get rid of newIteratorCoroutine()!
	-- for element in container:traverseVisible( x, y )
	function Cs.container.traverseVisible(container, x, y)
		if x then  return newIteratorCoroutine(_traverseVisibleAt, container, x, y, themeGet(container._gui, "scrollbarWidth"))
		else       return newIteratorCoroutine(_traverseVisible  , container)  end
	end

	-- container:visitVisible( callback ) -- @Doc and maybe @Cleanup.
	-- container:visitVisible( x, y, callback )
	-- traversalAction = callback( element )
	-- traversalAction = "continue" | "stop" -- Returning nil means "continue".
	function Cs.container.visitVisible(container, x, y, cb)
		if y then  _visitVisibleAt(container, x, y, themeGet(container._gui, "scrollbarWidth"), cb)
		else       _visitVisible  (container, x)  end
	end

	-- elements = container:collectVisible( [ array={} ] ) -- @Doc and maybe @Cleanup.
	-- elements = container:collectVisible( x, y, [, array={} ] )
	function Cs.container.collectVisible(container, x, y, elements)
		if y then
			elements = elements or {}
			for i = 1, #elements do  elements[i] = nil  end
			_collectVisibleAt(container, x, y, themeGet(container._gui, "scrollbarWidth"), elements)
		else
			elements = x or {}
			for i = 1, #elements do  elements[i] = nil  end
			_collectVisible(container, elements)
		end
		return elements
	end

	-- INTERNAL  elements = container:_collectVisibleUntilInputCapture( array )
	-- INTERNAL  elements = container:_collectVisibleUntilInputCapture( x, y, array )
	function Cs.container._collectVisibleUntilInputCapture(container, x, y, elements)
		if y then
			for i = 1, #elements do  elements[i] = nil  end
			_collectVisibleUntilInputCaptureAt(container, x, y, themeGet(container._gui, "scrollbarWidth"), elements)
		else
			elements = x
			for i = 1, #elements do  elements[i] = nil  end
			_collectVisibleUntilInputCapture(container, elements)
		end
		return elements
	end
end



-- INTERNAL REPLACE  container:_calculateNaturalSize( )
function Cs.container._calculateNaturalSize(container)
	calculateContainerChildNaturalSizes(container)

	local maxX = 0
	local maxY = 0

	for _, child in ipairs(container) do
		if not (child._hidden or child._floating) then
			-- Note: We don't consider the anchor as we only care about the size here.
			-- We do treat the position offset as part of the size (added to the top left of the child).
			-- (Maybe the reasoning is flawed somewhere here but it seems to work.)
			maxX = math.max(maxX, child._x+child._layoutWidth )
			maxY = math.max(maxY, child._y+child._layoutHeight)
		end
	end

	updateContainerNaturalSize(container, maxX, maxY)
end

-- INTERNAL REPLACE  container:_expandAndPositionChildren( )
function Cs.container._expandAndPositionChildren(container)
	local innerW = container._layoutWidth  - container:getInnerSpaceX() -- Should we use _content* here? I think no.
	local innerH = container._layoutHeight - container:getInnerSpaceY()

	for _, child in ipairs(container) do
		if not child._hidden then
			expandAndPositionFloatingElement(child, innerW, innerH) -- All children count as floating in plain/non-layout containers.
		end
	end

	updateScroll(container)
end



--==============================================================
--= Bar element class (abstract) ===============================
--==============================================================



Cs.bar = newElementClass(true, "GuiBar", Cs.container, {}, {
	-- Parameters.
	_expandPerpendicular = true,  -- Perpendicular to the layout direction of the bar.
	_homogeneous         = false, -- If children should be the same size.
	--

	_layoutInnerStaticWidth  = 0,
	_layoutInnerStaticHeight = 0,
	_layoutInnerSpacingsX    = 0,
	_layoutInnerSpacingsY    = 0,
	_layoutWeight            = 0.0,
}, {
	-- void
})

function Cs.bar.init(bar, gui, elData, parent)
	Cs.bar.super.init(bar, gui, elData, parent)

	@@retrieve(bar, elData, _expandPerpendicular)
	@@retrieve(bar, elData, _homogeneous)
end



--==============================================================
--= Hbar and Vbar element classes ==============================
--==============================================================



Cs.hbar = newElementClass(false, "GuiHorizontalBar", Cs.bar, {}, {
	-- void
}, {
	-- void
})
Cs.vbar = newElementClass(false, "GuiVerticalBar", Cs.bar, {}, {
	-- void
}, {
	-- void
})

-- function Cs.hbar.init(bar, gui, elData, parent)
-- 	Cs.hbar.super.init(bar, gui, elData, parent)
-- end
-- function Cs.vbar.init(bar, gui, elData, parent)
-- 	Cs.vbar.super.init(bar, gui, elData, parent)
-- end



-- INTERNAL REPLACE  hbar:_calculateNaturalSize( )
-- INTERNAL REPLACE  vbar:_calculateNaturalSize( )
function Cs.hbar._calculateNaturalSize(bar)
	calculateContainerChildNaturalSizes(bar)

	local staticW, dynamicW, highestW, highestDynamicW, sumSpaceX,
	      staticH, dynamicH, highestH, highestDynamicH, sumSpaceY,
	      totalWeight = barGetNaturalSizeValues(bar)

	local innerW = (bar._homogeneous and highestDynamicW*totalWeight or dynamicW) + staticW + sumSpaceX

	innerW   = math.max(innerW,   bar._minWidth -bar:getInnerSpaceX())
	highestH = math.max(highestH, bar._minHeight-bar:getInnerSpaceY())

	bar._layoutInnerStaticHeight, bar._layoutInnerStaticWidth = 0, staticW
	bar._layoutInnerSpacingsY   , bar._layoutInnerSpacingsX   = 0, sumSpaceX

	bar._layoutWeight = totalWeight

	updateContainerNaturalSize(bar, innerW, highestH)
end
function Cs.vbar._calculateNaturalSize(bar)
	calculateContainerChildNaturalSizes(bar)

	local staticW, dynamicW, highestW, highestDynamicW, sumSpaceX,
	      staticH, dynamicH, highestH, highestDynamicH, sumSpaceY,
	      totalWeight = barGetNaturalSizeValues(bar)

	local innerH = (bar._homogeneous and highestDynamicH*totalWeight or dynamicH) + staticH + sumSpaceY

	innerH   = math.max(innerH,   bar._minHeight-bar:getInnerSpaceY())
	highestW = math.max(highestW, bar._minWidth -bar:getInnerSpaceX())

	bar._layoutInnerStaticWidth, bar._layoutInnerStaticHeight = 0, staticH
	bar._layoutInnerSpacingsX  , bar._layoutInnerSpacingsY    = 0, sumSpaceY

	bar._layoutWeight = totalWeight

	updateContainerNaturalSize(bar, highestW, innerH)
end

!local function barExpandAndPositionChildren(vertical)
	!local WH     = vertical and `Height`  or `Width`
	!local WHPERP = vertical and `Width`   or `Height`
	!local XY     = vertical and `Y`       or `X`
	!local XYPERP = vertical and `X`       or `Y`

	--
	-- Calculate amount of space for children to expand into (total if homogeneous,
	-- extra if not) and convert relative sizes into static.
	--
	local childSizeSum = 0
	local innerSize    = bar._layout$WH - bar:getInnerSpace$XY() - bar._layoutInnerSpacings$XY
	local staticSize   = bar._layoutInnerStatic$WH
	local homogeneous  = bar._homogeneous

	for _, child in ipairs(bar) do
		if not (child._hidden or child._floating) then
			if child:hasRelative$WH() and not (child._weight > 0 and homogeneous) then
				local size       = round(child._relative$WH*innerSize)
				staticSize       = staticSize - child._layout$WH + size
				child._layout$WH = size
			end
			childSizeSum = childSizeSum + child._layout$WH
		end
	end

	local canScrollPerp = bar:canScroll$XYPERP()
	local expandPerp    = bar._expandPerpendicular and (bar._layout$WHPERP - bar:getInnerSpace$XYPERP()) or nil

	if canScrollPerp then
		expandPerp = math.max(expandPerp, bar._content$WHPERP)
	end

	local expansionWeight0 = bar._layoutWeight
	local expansionSpace0  = innerSize - (homogeneous and staticSize or childSizeSum)

	--
	-- Expand and position children.
	--

	-- Calculate dimensions.
	local widths  = @@STATIC{}
	local heights = @@STATIC{}
	local ignore  = @@STATIC{}

	for phase = 1, 2 do -- We need two phases to apply min/max size properly when also expanding.
		local advance         = 0
		local expansionWeight = expansionWeight0
		local expansionSpace  = expansionSpace0

		for i, child in ipairs(bar) do
			if phase == 1 then
				ignore[i] = false
			end

			if not (child._hidden or child._floating or ignore[i]) then
				local childWidth  = child._layoutWidth
				local childHeight = child._layoutHeight

				if child._weight > 0 then
					local space     = round(expansionSpace * child._weight/expansionWeight)
					child$WH        = (homogeneous and 0 or child$WH) + space
					expansionSpace  = expansionSpace  - space
					expansionWeight = expansionWeight - child._weight
				end

				if expandPerp then
					child$WHPERP = expandPerp -- Expand all children the same amount. (Better, I think.)
					-- child$WHPERP = canScrollPerp and math.max(child$WHPERP, expandPerp) or expandPerp -- Only expand too short children. (Worse, I think.)
				end

				local beforeLimit       = child$WH
				childWidth, childHeight = applySizeLimits(child, childWidth, childHeight)

				-- This is what's necessary for min/max to work.
				if child$WH ~= beforeLimit then
					ignore[i]        = true
					expansionWeight0 = expansionWeight0 - child._weight

					if homogeneous then
						expansionSpace0 = expansionSpace0 - child$WH
					else
						local diffFromNaturalSize = child._layout$WH - child$WH
						expansionSpace0           = expansionSpace0 + diffFromNaturalSize
					end
				end

				widths[i]  = childWidth
				heights[i] = childHeight
				advance    = advance + child$WH
			end
		end

		if advance == innerSize or bar._layoutWeight == 0 then
			break
		end

		--[[ @Debug
		if phase == 1 then
			local ignores = 0
			for i = 1, #bar do
				if ignore[i] then  ignores = ignores+1  end
			end
			printf("diff=%-5d ignores=%d %s", advance-innerSize, ignores, bar:getPathDescription())
		end
		--]]
	end

	-- Update children.
	local innerWidth  = bar._layoutWidth  - bar:getInnerSpaceX() -- Should we use _content* here? I think no.
	local innerHeight = bar._layoutHeight - bar:getInnerSpaceY()
	local baseX       = bar._layoutX + bar._paddingLeft
	local baseY       = bar._layoutY + bar._paddingTop
	local x           = 0
	local y           = 0
	local spacing     = 0
	local first       = true
	!local advance    = vertical and `y` or `x`

	for i, child in ipairs(bar) do
		if not (child._hidden or child._floating) then
			if not first then
				spacing  = math.max(spacing, child.!!(vertical and `_spacingTop` or `_spacingLeft`))
				$advance = $advance + spacing
			end

			child._layoutX      = baseX + x
			child._layoutY      = baseY + y
			child._layoutWidth  = widths[i]
			child._layoutHeight = heights[i]

			$advance = $advance + child._layout$WH
			spacing  = child.!!(vertical and `_spacingBottom` or `_spacingRight`)
			first    = false
		end
	end

	for _, child in ipairs(bar) do
		if child._hidden then
			-- void
		elseif child._floating then
			expandAndPositionFloatingElement(child, innerWidth, innerHeight)
		else
			child:_expandAndPositionChildren()
		end
	end

	-- Make sure scrolling uses the final expanded content size.
	bar._content$WH = $advance

	updateScroll(bar)
!end

-- INTERNAL REPLACE  hbar:_expandAndPositionChildren( )
-- INTERNAL REPLACE  vbar:_expandAndPositionChildren( )
function Cs.hbar._expandAndPositionChildren(bar)
	!barExpandAndPositionChildren(false)
end
function Cs.vbar._expandAndPositionChildren(bar)
	!barExpandAndPositionChildren(true)
end



--==============================================================
--= Root element class =========================================
--==============================================================



Cs.root = newElementClass(false, "GuiRoot", Cs.container, {}, {
	--[[REPLACE]] _width  = 0, -- The root always has a fixed size (i.e. not dynamic).
	--[[REPLACE]] _height = 0,
}, {
	-- void
})

-- function Cs.root.init(root, gui, elData, parent)
-- 	Cs.root.super.init(root, gui, elData, parent)
-- end



-- INTERNAL REPLACE  root:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.root._draw(root, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if root._hidden then  return  end

	local x, y, w, h = xywhOnScreen(root)

	if not root._gui.debug then
		triggerIncludingAnimations(root, "beforedraw", x, y, w, h)
	end

	drawLayoutBackground(root)
	root:_drawDebug(0, 0, 1, 0)

	-- @Cleanup: Move root culling from caller to here.
	drawChildrenAndMaybeNavigationTarget(root, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)

	if not root._gui.debug then
		triggerIncludingAnimations(root, "afterdraw", x, y, w, h)
	end
end



-- OVERRIDE  root:setDimensions( width, height )
-- OVERRIDE  root:setWidth( width )
-- OVERRIDE  root:setHeight( height )
function Cs.root.setDimensions(root, w, h)
	!ARGS"2 w,h:number"
	Cs.root.super.setDimensions(root, math.max(w, 0), math.max(h, 0))
end
function Cs.root.setWidth(root, w)
	!ARGS"2 w:number"
	Cs.root.super.setWidth(root, math.max(w, 0))
end
function Cs.root.setHeight(root, h)
	!ARGS"2 h:number"
	Cs.root.super.setHeight(root, math.max(h, 0))
end



-- INTERNAL REPLACE  root:_calculateNaturalSize( )
function Cs.root._calculateNaturalSize(root)
	root._layoutWidth  = root._width
	root._layoutHeight = root._height
	calculateContainerChildNaturalSizes(root)
end

-- INTERNAL OVERRIDE  root:_expandAndPositionChildren( )
function Cs.root._expandAndPositionChildren(root)
	root._layoutX = root._x
	root._layoutY = root._y
	Cs.root.super._expandAndPositionChildren(root)
end



--==============================================================
--= Leaf element class (abstract) ==============================
--==============================================================



Cs.leaf = newElementClass(true, "GuiLeaf", Cs.element, {}, {
	-- Parameters.
	_align = "center", -- "left" | "right" | "center"

	_font = nil, -- Overrides gui._font if set.

	_mnemonics = false,

	_text = "",

	_textColor = nil,
	--

	_mnemonicBytePosition = 0, -- 0 means no position.
	_textWidth            = 0, _textHeight = 0,
	_unprocessedText      = "",
}, {
	-- void
})

function Cs.leaf.init(leaf, gui, elData, parent)
	Cs.leaf.super.init(leaf, gui, elData, parent)

	@@retrieve(leaf, elData, _align)
	@@retrieve(leaf, elData, _font)
	@@retrieve(leaf, elData, _mnemonics)
	-- @@retrieve(leaf, elData, _text)
	@@retrieve(leaf, elData, _textColor)

	if elData.text ~= nil then
		leaf:setText(elData.text)
	end
end



-- align = leaf:getAlign( )
function Cs.leaf.getAlign(leaf)
	return leaf._align
end

-- leaf:setAlign( align )
function Cs.leaf.setAlign(leaf, align)
	leaf._align = align -- Note: We shouldn't have to update the layout after changing the alignment.
end



-- font|nil = leaf:getFont( )
function Cs.leaf.getFont(leaf)
	return leaf._font
end

-- font = leaf:getResultingFont( )
function Cs.leaf.getResultingFont(leaf)
	return leaf._font or leaf._gui._font or _M.getDefaultFont()
end

-- leaf:setFont( font|nil )
function Cs.leaf.setFont(leaf, font)
	if leaf._font == font then  return  end
	leaf._font = font
	scheduleLayoutUpdateIfDisplayed(leaf)
end

-- fontBeingUsed = leaf:useFont( )
-- Tell LÖVE to use the leaf's resulting font.
function Cs.leaf.useFont(leaf)
	local font = leaf:getResultingFont()
	$LG.setFont(font)
	return font
end



-- offsetX, offsetY, width = leaf:getMnemonicOffset( )
-- Returns nil if there's no mnemonic.
function Cs.leaf.getMnemonicOffset(leaf)
	if leaf._mnemonicBytePosition == 0 then  return nil  end

	local font = leaf:getResultingFont()
	local text = leaf._text

	-- @Polish: Handle kerning.
	local    i1 = leaf._mnemonicBytePosition
	local _, i2 = text:find(!("^"..UTF8_CHAR_PATTERN), i1)
	local x1    = font:getWidth(text:sub(1, i1-1)) -- @Speed @Memory
	local x2    = font:getWidth(text:sub(1, i2  ))

	return x1, font:getBaseline(), math.max(x2-x1, 1)
end



-- text = leaf:getText( )
function Cs.leaf.getText(leaf)
	return leaf._text
end

-- text = leaf:getUnprocessedText( )
-- Also see gui:setTextPreprocessor().
function Cs.leaf.getUnprocessedText(leaf)
	return leaf._unprocessedText
end

-- leaf:setText( text )
function Cs.leaf.setText(leaf, unprocessedText)
	unprocessedText = tostring(unprocessedText == nil and "" or unprocessedText)

	local text = preprocessText(leaf._gui, unprocessedText, leaf, leaf._mnemonics)
	if leaf._text == text then  return  end

	-- Check text for mnemonics (using "&").
	leaf._mnemonicBytePosition = 0

	if leaf._mnemonics then
		local matchCount    = 0
		local mnemonicCount = 0

		local cleanText = text:gsub("()&(.)", function(pos, c)
			if c ~= "&" then
				if mnemonicCount == 0 then
					leaf._mnemonicBytePosition = pos - matchCount
				end
				mnemonicCount = mnemonicCount + 1
			end
			matchCount = matchCount + 1
			return c
		end)

		if mnemonicCount > 1 then
			printerr(2, "Multiple mnemonics in '%s'.", text)
		end

		text = cleanText
	end

	leaf._text            = text
	leaf._unprocessedText = unprocessedText

	local oldW      = leaf._textWidth
	leaf._textWidth = leaf:getResultingFont():getWidth(text)

	if leaf._textWidth ~= oldW then
		scheduleLayoutUpdateIfDisplayed(leaf)
	end
end



-- leaf:drawText( x, y )
function Cs.leaf.drawText(leaf, x, y)
	$LG.print(leaf._text, x, y)
end

-- leaf:drawAlignedText( areaX, areaY, areaWidth [, align=leaf:getAlign() ] )
function Cs.leaf.drawAlignedText(leaf, x, y, w, align)
	align = align or leaf._align
	if align == "right" then
		x = x + w - leaf._textWidth
	elseif align == "center" then
		x = x + math.floor((w-leaf._textWidth)/2)
	end
	leaf:drawText(x, y)
end



-- colorTable|nil = leaf:getTextColor( )
function Cs.leaf.getTextColor(leaf)
	return leaf._textColor
end

-- leaf:setTextColor( colorTable|nil )
function Cs.leaf.setTextColor(leaf, color)
	leaf._textColor = color
end

-- bool = leaf:hasTextColor( )
function Cs.leaf.hasTextColor(leaf)
	return leaf._textColor ~= nil
end

-- hasTextColor = leaf:useTextColor( [ alphaMultiplier=1 ] )
-- Tell LÖVE to use the leaf's resulting text color.
function Cs.leaf.useTextColor(leaf, opacity)
	local color = leaf._textColor
	useColor((color or COLOR_WHITE), opacity)
	return color ~= nil
end



-- REPLACE  bool = leaf:isSolid( )
function Cs.leaf.isSolid(leaf)
	return true
end



-- OVERRIDE  leaf:reprocessTexts( )
function Cs.leaf.reprocessTexts(leaf)
	Cs.leaf.super.reprocessTexts(leaf)
	leaf:setText(leaf._unprocessedText)
end



--==============================================================
--= Canvas element class =======================================
--==============================================================



Cs.canvas = newElementClass(false, "GuiCanvas", Cs.leaf, {}, {
	-- Parameters.
	_canvasBackgroundColor = nil,
	-- @Incomplete: Padding?
}, {
	"draw", -- function( canvasElement, event, drawAreaWidth, drawAreaHeight )
})

function Cs.canvas.init(canvas, gui, elData, parent)
	Cs.canvas.super.init(canvas, gui, elData, parent)

	@@retrieve(canvas, elData, _canvasBackgroundColor)
end



-- INTERNAL REPLACE  canvas:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.canvas._draw(canvas, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if canvas._hidden then  return  end

	local gui = canvas._gui
	if gui.debug then  return canvas:_drawDebug(1, 0, 0)  end

	local x, y, w, h = xywhOnScreen(canvas)

	triggerIncludingAnimations(canvas, "beforedraw", x, y, w, h)
	drawLayoutBackground(canvas)

	-- Draw canvas.
	-- We don't call themeRender() for canvases as they should only draw things through the "draw" event.
	local cw = canvas:hasFixedWidth () and canvas._width  or w -- Good behavior? @Revise
	local ch = canvas:hasFixedHeight() and canvas._height or h

	if cw > 0 and ch > 0 then
		$LG.push("all")

		local cx      = x + math.floor((w-cw)/2)
		local cy      = y + math.floor((h-ch)/2)
		local bgColor = canvas._canvasBackgroundColor

		if bgColor then
			setColor(unpack(bgColor))
			$LG.rectangle("fill", cx, cy, cw, ch)
		end

		setScissor(gui, cx, cy, cw, ch)
		$LG.translate(cx, cy)
		setColor(1, 1, 1)

		triggerIncludingAnimations(canvas, "draw", cw, ch)
		canvas:unsetScissor()

		setScissor(gui, nil) -- Why do we call unsetScissor() and then this? 2022-04-04
		$LG.pop()
	end

	triggerIncludingAnimations(canvas, "afterdraw", x, y, w, h)
end



-- colorTable|nil = canvas:getCanvasBackgroundColor( )
function Cs.canvas.getCanvasBackgroundColor(canvas)
	return canvas._canvasBackgroundColor
end

-- canvas:setCanvasBackgroundColor( colorTable|nil )
function Cs.canvas.setCanvasBackgroundColor(canvas, color)
	canvas._canvasBackgroundColor = color
end



-- INTERNAL REPLACE  handled, grabMouseFocus = canvas:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.canvas._mousepressed(canvas, mx, my, mbutton, pressCount)
	return true, true
end



-- INTERNAL REPLACE  canvas:_calculateNaturalSize( )
function Cs.canvas._calculateNaturalSize(canvas)
	-- We don't call themeGetSize() for canvases - they always have their own private "theme".
	canvas._layoutWidth  = math.max(canvas._width , 0)
	canvas._layoutHeight = math.max(canvas._height, 0)
end



--==============================================================
--= Image element class ========================================
--==============================================================



Cs.image = newElementClass(false, "GuiImage", Cs.leaf, {"imageInclude"}, {
	-- void
}, {
	-- void
})

function Cs.image.init(imageEl, gui, elData, parent)
	Cs.image.super.init(imageEl, gui, elData, parent)
	initImageInclude(imageEl, elData)
end



-- INTERNAL OVERRIDE  image:_update( deltaTime )
function Cs.image._update(imageEl, dt)
	Cs.image.super._update(imageEl, dt)
	local sprite = imageEl._sprite
	if sprite then  updateSprite(sprite, dt)  end
end



-- INTERNAL REPLACE  image:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.image._draw(imageEl, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if imageEl._hidden    then  return  end
	if imageEl._gui.debug then  return imageEl:_drawDebug(1, 0, 0)  end

	local x, y, w, h = xywhOnScreen(imageEl)

	triggerIncludingAnimations(imageEl, "beforedraw", x, y, w, h)
	drawLayoutBackground(imageEl)

	local image = nil
	local quad  = nil
	local iw    = 0
	local ih    = 0

	if imageEl._sprite then
		image, quad, iw, ih = getCurrentViewOfSprite(imageEl._sprite)
	end
	themeRender(imageEl, "image", round(iw*imageEl._imageScaleX), round(ih*imageEl._imageScaleY))

	triggerIncludingAnimations(imageEl, "afterdraw", x, y, w, h)
end



-- INTERNAL REPLACE  image:_calculateNaturalSize( )
function Cs.image._calculateNaturalSize(imageEl)
	local iw, ih = imageEl:getImageDimensions()
	local  w,  h = themeGetSize(imageEl, "image", round(iw*imageEl._imageScaleX), round(ih*imageEl._imageScaleY))

	imageEl._layoutWidth, imageEl._layoutHeight = applySizeLimits(imageEl, w, h)

	if imageEl:hasFixedWidth () then  imageEl._layoutWidth  = imageEl._width   end
	if imageEl:hasFixedHeight() then  imageEl._layoutHeight = imageEl._height  end
end



--==============================================================
--= Text element class =========================================
--==============================================================



Cs.text = newElementClass(false, "GuiText", Cs.leaf, {}, {
	-- Parameters.
	_wrapText      = false,
	_textWrapLimit = -1, -- Negative means no limit.
}, {
	-- void
})

function Cs.text.init(textEl, gui, elData, parent)
	Cs.text.super.init(textEl, gui, elData, parent)

	@@retrieve(textEl, elData, _wrapText,_textWrapLimit)
end



-- INTERNAL REPLACE  text:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.text._draw(textEl, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if textEl._hidden    then  return  end
	if textEl._gui.debug then  return textEl:_drawDebug(1, 0, 0)  end

	local x, y, w, h = xywhOnScreen(textEl)

	triggerIncludingAnimations(textEl, "beforedraw", x, y, w, h)
	drawLayoutBackground(textEl)

	local textIndent = themeGet(textEl._gui, "textIndentation")
	themeRender(textEl, "text", textIndent, textEl._textWidth, textEl._textHeight)

	triggerIncludingAnimations(textEl, "afterdraw", x, y, w, h)
end



-- INTERNAL REPLACE  text:_calculateNaturalSize( )
function Cs.text._calculateNaturalSize(textEl)
	local wrapLimit = textEl._textWrapLimit
	if wrapLimit < 0 then  wrapLimit = 1/0  end

	if wrapLimit == 1/0 and textEl._wrapText then
		local innerSpaceSum = 0

		for _, parent in textEl:parents() do
			innerSpaceSum = innerSpaceSum + parent:getInnerSpaceX()

			-- At most this will be the root, as the root always has a fixed size.
			if parent:hasFixedWidth() then
				wrapLimit = parent._width - innerSpaceSum - 2*themeGet(textEl._gui, "textIndentation")

				if wrapLimit <= 0 then
					-- Maybe the root's size is 0x0?
					wrapLimit = 1/0
				end

				break
			end
		end
	end

	local textW, textH = getTextDimensions(textEl:getResultingFont(), textEl._text, wrapLimit)
	textEl._textWidth  = textW
	textEl._textHeight = textH

	local textIndent = themeGet(textEl._gui, "textIndentation")
	local w, h       = themeGetSize(textEl, "text", textIndent, textW, textH)

	textEl._layoutWidth, textEl._layoutHeight = applySizeLimits(textEl, w, h)

	if textEl:hasFixedWidth () then  textEl._layoutWidth  = textEl._width   end
	if textEl:hasFixedHeight() then  textEl._layoutHeight = textEl._height  end
end



-- REPLACE  text:drawText( x, y )
function Cs.text.drawText(textEl, x, y)
	if textEl._wrapText or textEl._textWrapLimit >= 0 then
		$LG.printf(textEl._text, x, y, textEl._textWidth, textEl._align)
	else
		$LG.print(textEl._text, x, y)
	end
end



--==============================================================
--= Widget element class (abstract) ============================
--==============================================================



Cs.widget = newElementClass(true, "GuiWidget", Cs.leaf, {}, {
	-- Parameters.
	_active   = true, -- If the widget can be interacted with or is grayed out.
	_priority = 0,    -- Navigation priority.
}, {
	"navigate" , -- suppress = function( widgetElement, event )
	"navupdate", --            function( widgetElement, event, deltaTime )
})

function Cs.widget.init(widget, gui, elData, parent)
	Cs.widget.super.init(widget, gui, elData, parent)

	@@retrieve(widget, elData, _active)
	@@retrieve(widget, elData, _priority)
end



-- priority = widget:getPriority( )
function Cs.widget.getPriority(widget)
	return widget._priority
end

-- widget:setPriority( priority )
function Cs.widget.setPriority(widget, priority)
	widget._priority = priority
end



-- bool = widget:isActive( )
function Cs.widget.isActive(widget)
	return widget._active
end

-- stateChanged = widget:setActive( bool )
function Cs.widget.setActive(widget, active)
	if widget._active == active then  return false  end
	widget._active = active
	return true
end



--==============================================================
--= Button element class =======================================
--==============================================================



Cs.button = newElementClass(false, "GuiButton", Cs.widget, {"imageInclude"}, {
	-- Parameters.
	_pressable = true,
	_canToggle = false,
	_close     = false,

	_toggled = false,
	_radio   = "", -- Only used if canToggle is set.

	_text2 = "",

	_imagePadding = 0,

	_toggledSprite   = nil,
	_untoggledSprite = nil,

	_arrow = nil, -- @Cleanup: We're not using this internally. Should it be removed in favor of element.data?
	--

	_isPressed = false,

	_textWidth1 = 0,
	_textWidth2 = 0,

	_unprocessedText2 = "",
}, {
	"press" , -- function( buttonElement, event )
	"toggle", -- function( buttonElement, event )
})

function Cs.button.init(button, gui, elData, parent)
	Cs.button.super.init(button, gui, elData, parent)
	initImageInclude(button, elData)

	@@retrieve(button, elData, _arrow)
	@@retrieve(button, elData, _canToggle)
	@@retrieve(button, elData, _close)
	@@retrieve(button, elData, _imagePadding)
	@@retrieve(button, elData, _pressable)
	@@retrieve(button, elData, _radio)
	-- @@retrieve(button, elData, _text2)
	@@retrieve(button, elData, _toggled)
	@@retrieve(button, elData, _toggledSprite,_untoggledSprite)

	if elData.sprite then
		-- void
	elseif button._toggledSprite and button._toggled then
		button:setSprite(button._toggledSprite)
	elseif button._untoggledSprite and not button._toggled then
		button:setSprite(button._untoggledSprite)
	end

	if elData.text2 ~= nil then
		button:setText2(elData.text2)
	end
end



-- INTERNAL OVERRIDE  button:_update( deltaTime )
function Cs.button._update(button, dt)
	Cs.button.super._update(button, dt)
	local sprite = button._sprite
	if sprite then  updateSprite(sprite, dt)  end
end



-- INTERNAL REPLACE  button:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.button._draw(button, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if button._hidden    then  return  end
	if button._gui.debug then  return button:_drawDebug(0, 180, 0)  end

	local x, y, w, h = xywhOnScreen(button)

	triggerIncludingAnimations(button, "beforedraw", x, y, w, h)
	drawLayoutBackground(button)

	local image = nil
	local quad  = nil
	local iw    = 0
	local ih    = 0

	if button._sprite then
		image, quad, iw, ih = getCurrentViewOfSprite(button._sprite)
	end
	themeRender(
		button, "button", button._textWidth1, button._textWidth2, button._textHeight,
		round(iw*button._imageScaleX+2*button._imagePadding),
		round(ih*button._imageScaleY+2*button._imagePadding)
	)

	triggerIncludingAnimations(button, "afterdraw", x, y, w, h)
end



-- arrow|nil = button:getArrow( )
function Cs.button.getArrow(button)
	return button._arrow
end



-- text2 = button:getText2( )
function Cs.button.getText2(button)
	return button._text2
end

-- text = button:getUnprocessedText2( )
function Cs.button.getUnprocessedText2(button)
	return button._unprocessedText2
end

-- OVERRIDE  button:setText( text )
function Cs.button.setText(button, text)
	local oldText = button._text
	local oldW    = button._textWidth

	Cs.button.super.setText(button, text)
	text = nil -- Don't use this anymore!

	if button._text == oldText then  return  end

	button._textWidth1 = button._textWidth
	button._textWidth  = button._textWidth1 + button._textWidth2

	if button._textWidth ~= oldW then
		scheduleLayoutUpdateIfDisplayed(button)
	end
end

-- button:setText2( text )
function Cs.button.setText2(button, unprocessedText)
	unprocessedText = tostring(unprocessedText == nil and "" or unprocessedText)

	local text = preprocessText(button._gui, unprocessedText, button, false)
	if button._text2 == text then  return  end

	button._text2            = text
	button._unprocessedText2 = unprocessedText

	local oldW         = button._textWidth
	button._textWidth2 = button:getResultingFont():getWidth(text)
	button._textWidth  = button._textWidth1 + button._textWidth2

	if button._textWidth ~= oldW then
		scheduleLayoutUpdateIfDisplayed(button)
	end
end



-- button:drawText2( x, y )
function Cs.button.drawText2(button, x, y)
	$LG.print(button._text2, x, y)
end

-- button:drawAlignedText2( areaX, areaY, areaWidth [, align=button:getAlign() ] )
function Cs.button.drawAlignedText2(button, x, y, w, align)
	align = align or button._align
	if align == "right" then
		x = x + w - button._textWidth2
	elseif align == "center" then
		x = x + math.floor((w-button._textWidth2)/2)
	end
	button:drawText(x, y)
end



-- bool = button:isPressable( )
function Cs.button.isPressable(button)
	return button._pressable
end

-- button:setPressable( bool )
function Cs.button.setPressable(button, pressable)
	button._pressable = pressable
end



-- bool = button:isToggled( )
function Cs.button.isToggled(button)
	return button._toggled
end

-- button:setToggled( bool )
function Cs.button.setToggled(button, toggled)
	if button._toggled == toggled then  return  end

	button._toggled = toggled

	if toggled and button._toggledSprite then
		button:setSprite(button._toggledSprite)
	elseif not toggled and button._untoggledSprite then
		button:setSprite(button._untoggledSprite)
	end

	trigger(button, "toggle")
end



-- INTERNAL REPLACE  handled, grabMouseFocus = button:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.button._mousepressed(button, mx, my, mbutton, pressCount)
	if mbutton == 1 then
		if not button._active then  return true, false  end

		button._isPressed = true
		button._gui:navigateTo(button._gui._navigationTarget and button or nil)

		return true, true
	end
	-- @Incomplete: Trigger events and stuff for other mouse buttons.

	return false, false
end

-- -- INTERNAL REPLACE  button:_mousemoved( mouseX, mouseY )
-- function Cs.button._mousemoved(button, mx, my)
-- end

-- INTERNAL REPLACE  button:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.button._mousereleased(button, mx, my, mbutton, pressCount)
	if mbutton == 1 then
		button._isPressed = false
		if button:isHovered() then  button:press()  end
	end
end



-- INTERNAL REPLACE  handled = button:_ok( )
function Cs.button._ok(button)
	button:press()
	return true
end



-- success = button:press( [ ignoreActiveState=false ] )
function Cs.button.press(button, ignoreActiveState)
	if not ignoreActiveState and not (button._active and button._pressable) then
		return false
	end

	-- Press/toggle the button.
	local preparedSound = button._canToggle and prepareSound(button, "toggle") or prepareSound(button, "press") -- 'toggle' falls back to 'press'.

	if button._canToggle then
		if button._radio ~= "" then
			if button._toggled then  return true  end -- Assume this is the only toggled button in the radio group.

			for otherButton in button:getRoot():traverseType"button" do
				if otherButton == button then
					-- void
				elseif otherButton._radio == button._radio then
					-- Should we collect all buttons first so we don't invoke user code during traversal? @Robustness
					otherButton:setToggled(false)
				end
			end
		end

		local toggled   = not button._toggled
		button._toggled = toggled -- We need to toggle before the press event in case the callback uses the value.

		if toggled and button._toggledSprite then
			button:setSprite(button._toggledSprite)
		elseif not toggled and button._untoggledSprite then
			button:setSprite(button._untoggledSprite)
		end
	end

	button._gui._ignoreKeyboardInputThisFrame = true

	trigger(button, "press")
	if button._canToggle then  trigger(button, "toggle")  end

	button:triggerBubbling("pressed", button)

	-- Close closest closable. heh
	local closedAnything = false

	if not button._close then
		-- void
	elseif button:canClose() then
		closedAnything = button:close()
	else
		for _, parent in button:parents() do
			if parent:canClose() then
				closedAnything = parent:close()
				break
			end
		end
	end
	if preparedSound and not closedAnything then
		preparedSound() -- 'close' has its own sound.
	end

	return true
end

-- bool = button:isPressed( )
function Cs.button.isPressed(button)
	return button._isPressed
end



-- OVERRIDE  button:reprocessTexts( )
function Cs.button.reprocessTexts(button)
	Cs.button.super.reprocessTexts(button)
	button:setText2(button._unprocessedText2)
end



-- INTERNAL REPLACE  button:_calculateNaturalSize( )
function Cs.button._calculateNaturalSize(button)
	local font         = button:getResultingFont()
	button._textWidth1 = font:getWidth(button._text)
	button._textWidth2 = font:getWidth(button._text2)
	button._textWidth  = button._textWidth1 + button._textWidth2 -- This value is pretty useless...
	button._textHeight = font:getHeight()

	local iw, ih = button:getImageDimensions()
	local  w,  h = themeGetSize(
		button, "button", button._textWidth1, button._textWidth2, button._textHeight,
		round(iw*button._imageScaleX+2*button._imagePadding),
		round(ih*button._imageScaleY+2*button._imagePadding)
	)

	button._layoutWidth, button._layoutHeight = applySizeLimits(button, w, h)

	if button:hasFixedWidth () then  button._layoutWidth  = button._width   end
	if button:hasFixedHeight() then  button._layoutHeight = button._height  end
end



--==============================================================
--= Input element class ========================================
--==============================================================



Cs.input = newElementClass(false, "GuiInput", Cs.widget, {}, {
	-- Parameters.
	--[[OVERRIDE]] _mouseCursor = "ibeam",

	--[[REPLACE]] _minWidth = 10,

	_placeholder = "",

	_mask = "",

	_spin = 0, -- Non-zero enables number value spinning.

	_spinMin = -1/0,
	_spinMax = 1/0,
	--

	_field = nil,

	_savedKeyRepeat = false,
	_savedValue     = "",
}, {
	"change"     , -- function( inputElement, event )
	"submit"     , -- function( inputElement, event )
	"valuechange", -- function( inputElement, event )
})

function Cs.input.init(inputEl, gui, elData, parent)
	Cs.input.super.init(inputEl, gui, elData, parent)

	-- @@retrieve(inputEl, elData, _fieldType) -- This is saved in the field instead.
	@@retrieve(inputEl, elData, _mask)
	@@retrieve(inputEl, elData, _placeholder)
	@@retrieve(inputEl, elData, _spin)
	@@retrieve(inputEl, elData, _spinMin,_spinMax)
	-- @@retrieve(inputEl, elData, _value) -- This is saved in the field instead.

	inputEl._field = InputField(elData.value--[[default=""]], elData.fieldType--[[default="normal"]])
	inputEl._field:setFont(inputEl:getResultingFont())
	inputEl._field:setFontFilteringActive(true)
end



-- INTERNAL OVERRIDE  input:_update( deltaTime )
function Cs.input._update(inputEl, dt)
	Cs.input.super._update(inputEl, dt)
	inputEl._field:update(dt)
end



-- INTERNAL REPLACE  input:_draw( cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter )
function Cs.input._draw(inputEl, cullX1, cullY1, cullX2, cullY2, childToDrawNavTargetAfter)
	if inputEl._hidden    then  return  end
	if inputEl._gui.debug then  return inputEl:_drawDebug(0, 180, 0)  end

	local x, y, w, h                     = xywhOnScreen(inputEl)
	local valueX, valueY, valueW, valueH = inputEl:getValueLayout()
	local curOffsetX, curOffsetY, curH   = inputEl._field:getCursorLayout()

	-- @Incomplete: Draw scrollbars. (We really ought to handle mouse events for them too!)

	triggerIncludingAnimations(inputEl, "beforedraw", x, y, w, h)

	drawLayoutBackground(inputEl)
	themeRender(inputEl, "input", valueX, valueY, valueW, valueH, curOffsetX, curOffsetY, curH)

	triggerIncludingAnimations(inputEl, "afterdraw", x, y, w, h)
end



-- input:drawValue( x, y )
function Cs.input.drawValue(inputEl, x0, y0)
	for _, line, x, y in inputEl._field:eachVisibleLine() do
		$LG.print(line, x0+x, y0+y)
	end
end

-- input:drawPlaceholder( x, y )
function Cs.input.drawPlaceholder(inputEl, x, y)
	$LG.print(inputEl._placeholder, x, y)
end

-- input:drawValueOrPlaceholder( x, y )
function Cs.input.drawValueOrPlaceholder(inputEl, x, y)
	if    inputEl:getValue() ~= ""
	then  inputEl:drawValue(x, y)
	else  inputEl:drawPlaceholder(x, y)  end
end

-- input:drawSelections( x, y [, callback ] )
-- callback = function( x, y, width, height )
-- If no callback is given then a filled rectangle is drawn for each selection.
function Cs.input.drawSelections(input, x0, y0, cb)
	for _, x, y, w, h in input._field:eachSelectionOptimized() do
		if cb then  cb           (        x0+x, y0+y, w, h)
		else        $LG.rectangle("fill", x0+x, y0+y, w, h)  end
	end
end



-- input:focus( )
function Cs.input.focus(inputEl)
	local gui = inputEl._gui
	if gui._keyboardFocus == inputEl then  return  end

	inputEl._savedValue     = inputEl:getValue()
	inputEl._savedKeyRepeat = love.keyboard.hasKeyRepeat()

	gui:navigateTo(gui._navigationTarget and inputEl or nil)
	gui._lockNavigation = true

	setKeyboardFocus(gui, inputEl)

	love.keyboard.setKeyRepeat(true)
	inputEl._field:resetBlinking()

	inputEl:playSound("focus")
	inputEl:triggerBubbling("focused", inputEl)
end

-- success = input:blur( )
function Cs.input.blur(inputEl)
	local gui = inputEl._gui
	if gui._keyboardFocus ~= inputEl then  return false  end

	blurKeyboardFocus(gui)
	gui._lockNavigation = false

	love.keyboard.setKeyRepeat(inputEl._savedKeyRepeat)

	inputEl._field:setScroll(0, 0)

	local v = inputEl:getValue()
	if v ~= inputEl._savedValue then
		trigger(inputEl, "change", v)
	end

	inputEl:triggerBubbling("blurred", inputEl)
	return true
end

-- bool = input:isFocused( )
function Cs.input.isFocused(inputEl)
	return inputEl:isKeyboardFocus()
end



--
-- inputField = input:getField( )
--
-- Inputs use the InputField library for many things. This method gives direct access to
-- the internal InputField instance. (See https://github.com/ReFreezed/InputField)
--
-- Warning: Changing things in the inputField directly may mess up GuiLove!
--
function Cs.input.getField(inputEl)
	return inputEl._field
end



-- value = input:getValue( )
function Cs.input.getValue(inputEl)
	return inputEl._field:getText()
end

-- input:setValue( value )
function Cs.input.setValue(inputEl, value)
	inputEl._field:setText(value)
end

-- value = input:getVisibleValue( )
-- Returns *** for passwords.
function Cs.input.getVisibleValue(inputEl)
	return inputEl._field:getVisibleText()
end



-- fieldType = input:getFieldType( )
function Cs.input.getFieldType(inputEl)
	return inputEl._field:getType()
end

-- input:setFieldType( fieldType )
-- fieldType = "normal" | "password" | "multiwrap" | "multinowrap"
function Cs.input.setFieldType(inputEl, fieldType)
	inputEl._field:setType(fieldType)
end



-- INTERNAL REPLACE  handled, grabKeyboardFocus = input:_keypressed( key, scancode, isRepeat )
function Cs.input._keypressed(inputEl, key, scancode, isRepeat)
	if not inputEl:isKeyboardFocus() then  return false, false  end

	local oldCurOffsetX, oldCurOffsetY = inputEl._field:getCursorLayout()

	if key == "escape" then
		if not isRepeat then
			if inputEl:getValue() ~= inputEl._savedValue then
				inputEl._field:setText(inputEl._savedValue)
				trigger(inputEl, "valuechange")
			end
			inputEl:blur()
			inputEl:playSound("inputrevert")
		end

	elseif (key == "return" or key == "kpenter") and not (inputEl._field:isMultiline() and not love.keyboard.isDown(LCTRL,RCTRL)) then
		if not isRepeat then
			inputEl:blur()
			inputEl:playSound("inputsubmit")
			trigger(inputEl, "submit")
		end

	elseif inputEl._spin ~= 0 and (key == "up" or key == "down") then
		local oldValue = inputEl:getValue()
		local n        = tonumber(oldValue) or 0

		if key == "up" then
			n = n + inputEl._spin
		elseif key == "down" then
			n = n - inputEl._spin
		end
		n = math.min(math.max(n, inputEl._spinMin), inputEl._spinMax)

		local newValue = tostring(n)
		if newValue ~= oldValue then
			inputEl:setValue(newValue)
			inputEl._field:selectAll()
			-- @Incomplete: Play a sound here. :TypingSound
			trigger(inputEl, "valuechange")
		end

	else
		local oldValue             = inputEl:getValue()
		local handled, textChanged = inputEl._field:keypressed(key, isRepeat)

		if not textChanged then
			-- void
		elseif inputEl._mask ~= "" and not inputEl:getValue():find(inputEl._mask) then
			inputEl:setValue(oldValue) -- Undo the change.  @UX: Handle the cursor better.
		else
			-- :TypingSound
			trigger(inputEl, "valuechange")
		end
	end

	if inputEl:isFocused() then
		local curOffsetX, curOffsetY = inputEl._field:getCursorLayout()
		if curOffsetX ~= oldCurOffsetX or curOffsetY ~= oldCurOffsetY then
			inputEl:scrollIntoView(true)
		end
	end

	return true, false
end

-- -- INTERNAL REPLACE  input:_keyreleased( key, scancode )
-- function Cs.input._keyreleased(inputEl, key, scancode)
-- end

-- INTERNAL REPLACE  handled = input:_textinput( text )
function Cs.input._textinput(inputEl, text)
	if not inputEl:isKeyboardFocus() then  return false  end

	local oldValue             = inputEl:getValue()
	local handled, textChanged = inputEl._field:textinput(text)

	if not textChanged then
		-- void
	elseif inputEl._mask ~= "" and not inputEl:getValue():find(inputEl._mask) then
		inputEl:setValue(oldValue) -- Undo the change.  @UX: Handle the cursor better.
		inputEl:scrollIntoView(true)
	else
		inputEl:scrollIntoView(true)
		-- :TypingSound
		trigger(inputEl, "valuechange")
	end

	return true
end



-- INTERNAL REPLACE  handled, grabMouseFocus = input:_mousepressed( mouseX, mouseY, mouseButton, pressCount )
function Cs.input._mousepressed(inputEl, mx, my, mbutton, pressCount)
	if not inputEl._active then  return true, false  end

	inputEl:focus()

	if mbutton == 1 then
		local x, y        = inputEl:getPositionOnScreen()
		local inputIndent = themeGet(inputEl._gui, "inputIndentation")
		inputEl._field:mousepressed(mx-x-inputIndent, my-y-inputIndent, mbutton, pressCount)
		inputEl:scrollIntoView(true) -- @Incomplete: Scroll to the mouse cursor instead of the text cursor (but do it smoothly over time in the update event). :SmoothScrollInputToMouse
		return true, true
	else
		return true, false
	end
end

-- INTERNAL REPLACE  input:_mousemoved( mouseX, mouseY )
function Cs.input._mousemoved(inputEl, mx, my)
	local x, y        = inputEl:getPositionOnScreen()
	local inputIndent = themeGet(inputEl._gui, "inputIndentation")
	inputEl._field:mousemoved(mx-x-inputIndent, my-y-inputIndent)
	inputEl:scrollIntoView(true) -- :SmoothScrollInputToMouse
end

-- INTERNAL REPLACE  input:_mousereleased( mouseX, mouseY, mouseButton, pressCount )
function Cs.input._mousereleased(inputEl, mx, my, mbutton, pressCount)
	local x, y        = inputEl:getPositionOnScreen()
	local inputIndent = themeGet(inputEl._gui, "inputIndentation")
	inputEl._field:mousereleased(mx-x-inputIndent, my-y-inputIndent, mbutton)
end

-- INTERNAL REPLACE  handled = input:_wheelmoved( deltaX, deltaY, deltaX0, deltaY0 )
function Cs.input._wheelmoved(inputEl, dx, dy, dx0, dy0)
	return (inputEl._field:wheelmoved(dx0, dy0)) -- @Incomplete: Smooth scrolling for inputs. (Maybe it should be implemented in InputField?)
end



-- INTERNAL REPLACE  handled = input:_ok( )
function Cs.input._ok(inputEl)
	inputEl._gui._ignoreKeyboardInputThisFrame = true
	if not inputEl:isFocused() then
		inputEl:focus()
	else
		inputEl:blur()
	end
	return true
end



-- OVERRIDE  input:setActive( bool )
function Cs.input.setActive(inputEl, active)
	if not active then  inputEl:blur()  end
	Cs.input.super.setActive(inputEl, active)
end



-- INTERNAL REPLACE  input:_calculateNaturalSize( )
function Cs.input._calculateNaturalSize(inputEl)
	local font = inputEl:getResultingFont()
	inputEl._field:setFont(font)

	local _, h = themeGetSize(inputEl, "input", _, font:getHeight())

	inputEl._layoutWidth, inputEl._layoutHeight = applySizeLimits(inputEl, 0, h)

	if inputEl:hasFixedWidth () then  inputEl._layoutWidth  = inputEl._width   end
	if inputEl:hasFixedHeight() then  inputEl._layoutHeight = inputEl._height  end
end

-- INTERNAL OVERRIDE  input:_expandAndPositionChildren( )
function Cs.input._expandAndPositionChildren(inputEl)
	Cs.input.super._expandAndPositionChildren(inputEl)

	local inputIndent = themeGet(inputEl._gui, "inputIndentation")
	inputEl._field:setDimensions(inputEl._layoutWidth-2*inputIndent, inputEl._layoutHeight-2*inputIndent) -- Maybe there should be a separate vertical inputIndentation? @Incomplete
end



-- valueX, valueY, valueWidth, valueHeight = input:getValueLayout( )
function Cs.input.getValueLayout(inputEl)
	updateLayoutIfNeeded(inputEl._gui)

	local inputIndent    = themeGet(inputEl._gui, "inputIndentation")
	local valueW, valueH = inputEl._field:getTextDimensions()
	local valueX         = inputIndent
	local valueY         = inputEl._field:isMultiline() and inputIndent or math.floor((inputEl._layoutHeight-valueH)/2) -- @Incomplete: Maybe add parameters for aligning the value.

	return valueX, valueY, valueW, valueH
end

-- offsetX, offsetY, height = input:getCursorLayout( )
function Cs.input.getCursorLayout(inputEl)
	return inputEl._field:getCursorLayout()
end



-- phase = input:getBlinkPhase( )
function Cs.input.getBlinkPhase(inputEl)
	return inputEl._field:getBlinkPhase()
end



--==============================================================
--= Default theme ==============================================
--==============================================================

do
local Gui    = _M
defaultTheme = (function()  @insert "src/defaultTheme.luapart"  end)()
end



--==============================================================
--==============================================================
--==============================================================

return setmetatable(_M, {
	__call = function(_M, ...)
		return (Gui(...))
	end,
})

--==============================================================
--=
--=  MIT License
--=
--=  Copyright © 2017-2022 Marcus 'ReFreezed' Thunström
--=
--=  Permission is hereby granted, free of charge, to any person obtaining a copy
--=  of this software and associated documentation files (the "Software"), to deal
--=  in the Software without restriction, including without limitation the rights
--=  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--=  copies of the Software, and to permit persons to whom the Software is
--=  furnished to do so, subject to the following conditions:
--=
--=  The above copyright notice and this permission notice shall be included in all
--=  copies or substantial portions of the Software.
--=
--=  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--=  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--=  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--=  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--=  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--=  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
--=  SOFTWARE.
--=
--==============================================================
